<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java中的IO流详细讲解----字节流</title>
      <link href="/2018/08/15/java-io2/"/>
      <url>/2018/08/15/java-io2/</url>
      <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20171122201546188?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171122201608552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><h6 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h6><p>==FileInputStream和FileOutputStream==</p><p> Java提供了一系列的读写文件的类和方法。在Java 中，所有的文件都是字节形式的。Java提供从文 件读写字节的方法。而且，Java允许在字符形式 的对象中使用字节文件流。</p><p> 两个最常用的流类是FileInputStream和 FileOutputStream，它们生成与文件链接的字节流。 为打开文件，你只需创建这些类中某一个类的一 个对象，在构造方法中以参数形式指定文件的名称</p><p>当你对文件的操作结束后，需要调用close( )来关闭文件。 </p><p>读取音频，图片等数据的时候只能使用字节流，下面来看一下使用文件流实现复制的功能。（这里主要说IO流，对于异常我直接抛出，后面不在提及）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.byteio.test;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 功能：通过字节输入输出流，完成文件copy  InputStream OutputStream</span><br><span class="line"> * 分析：</span><br><span class="line"> *    源文件                       程序                       目标文件</span><br><span class="line"> *    1.找到源文件</span><br><span class="line"> *    2.读取源文件里的信息  输入 程序</span><br><span class="line"> *    3.将程序读到的数据  写入   源文件</span><br><span class="line"> * </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestCopy3 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//1.选择合适流 InputStream OutputStream</span><br><span class="line">FileInputStream fis=new FileInputStream(new File(&quot;D:\\qf1717\\Wildlife.wmv&quot;));</span><br><span class="line">FileOutputStream fos=new FileOutputStream(new File(&quot;D:\\qf1717\\Wildlife(复制).wmv&quot;)); </span><br><span class="line">//2.处理数据</span><br><span class="line">    //2.1 创建缓存区</span><br><span class="line">    byte [] buf=new byte[1024];</span><br><span class="line">    //2.2从缓存区读数据</span><br><span class="line">    int len = fis.read(buf);</span><br><span class="line">    while(len!=-1)&#123;</span><br><span class="line">    //将读的数据写入 新文件中</span><br><span class="line">    fos.write(buf);</span><br><span class="line">    len=fis.read(buf);//注意点  len再次赋值  读 缓存区的数据</span><br><span class="line">    &#125;</span><br><span class="line">//3.关流</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">System.out.println(&quot;复制完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件的复制例子1：（一个字符一个字符的读）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 功能：通过字节输入输出流，完成文件copy  InputStream OutputStream</span><br><span class="line"> * 分析：</span><br><span class="line"> *    源文件                       程序                       目标文件</span><br><span class="line"> *    1.找到源文件</span><br><span class="line"> *    2.读取源文件里的信息  输入 程序</span><br><span class="line"> *    3.将程序读到的数据  写入   源文件</span><br><span class="line"> *    </span><br><span class="line"> * 第一步：找到源文件    读取源文件里的信息  输入 程序</span><br><span class="line"> *       将程序读到内容打印到控制台</span><br><span class="line"> *       流的操作</span><br><span class="line"> *          1选择合适的流（流的分类）</span><br><span class="line"> *          2处理数据</span><br><span class="line"> *          3.关流</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestInputStream2 &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">  //找到源文件    读取源文件里的信息  输入 程序  将程序读到内容打印到控制台</span><br><span class="line">  //1选择合适的流（流的分类）</span><br><span class="line">  File f=new File(&quot;D:\\qf1717\\abc.txt&quot;);</span><br><span class="line">  //File f=new File(&quot;D:/qf1717/abc.txt&quot;);</span><br><span class="line">  InputStream fis=new FileInputStream(f);</span><br><span class="line">  //2处理数据</span><br><span class="line"> </span><br><span class="line">  /*int n=fis.read();//97</span><br><span class="line">  while(n!=-1)&#123;</span><br><span class="line">  System.out.print((char)n);</span><br><span class="line">  n=fis.read();//迭代式 -1</span><br><span class="line">  &#125;*/</span><br><span class="line">  int n=0;</span><br><span class="line">  while((n=fis.read())!=-1)&#123;//97</span><br><span class="line">  System.out.print((char)n);</span><br><span class="line">  &#125;</span><br><span class="line">  //3关流</span><br><span class="line">  fis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件的复制例子2：（使用临时处理区，多个字符的读）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.byteio.test;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 功能：通过字节输入输出流，完成文件copy  InputStream OutputStream</span><br><span class="line"> * 分析：</span><br><span class="line"> *    源文件                       程序                       目标文件</span><br><span class="line"> *    1.找到源文件</span><br><span class="line"> *    2.读取源文件里的信息  输入 程序</span><br><span class="line"> *    3.将程序读到的数据  写入   源文件</span><br><span class="line"> *    </span><br><span class="line"> * 第一步：找到源文件    读取源文件里的信息  输入 程序</span><br><span class="line"> *       将程序读到内容打印到控制台</span><br><span class="line"> *       流的操作</span><br><span class="line"> *          1选择合适的流（流的分类）</span><br><span class="line"> *          2处理数据</span><br><span class="line"> *          3.关流</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestInputStream4 &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">  //找到源文件    读取源文件里的信息  输入 程序  将程序读到内容打印到控制台</span><br><span class="line">  //1选择合适的流（流的分类）</span><br><span class="line">  File f=new File(&quot;D:\\qf1717\\abc.txt&quot;);</span><br><span class="line">  //File f=new File(&quot;D:/qf1717/abc.txt&quot;);</span><br><span class="line">  InputStream fis=new FileInputStream(f);</span><br><span class="line">  //2处理数据</span><br><span class="line">  //2.1 创建一个临时区域 一次性存多个值</span><br><span class="line">     byte [] buf=new byte[1024];//abcdef</span><br><span class="line">  //2.2从临时区域读数据</span><br><span class="line">     /*int len=fis.read(buf);</span><br><span class="line">     //System.out.println(len);//字节数</span><br><span class="line">     //System.out.println(Arrays.toString(buf));</span><br><span class="line">     System.out.println(new String(buf));</span><br><span class="line">     System.out.println(new String(buf,0,len));//0 5</span><br><span class="line">*/     </span><br><span class="line">     int len=fis.read(buf);</span><br><span class="line">     while(len!=-1)&#123;</span><br><span class="line">     System.out.println(new String(buf,0,len));</span><br><span class="line">     len=fis.read(buf);</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">  //3关流</span><br><span class="line">  fis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>available( )判定剩余的字节个数及怎样用，skip( )方法跳过不必要的字节</p><p>文件的复制例子2：（使用临时处理区，多个字符的读）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 功能：通过字节输入输出流，完成文件copy  InputStream OutputStream</span><br><span class="line"> * 分析：</span><br><span class="line"> *    源文件                       程序                       目标文件</span><br><span class="line"> *    1.找到源文件</span><br><span class="line"> *    2.读取源文件里的信息  输入 程序</span><br><span class="line"> *    3.将程序读到的数据  写入   源文件</span><br><span class="line"> * </span><br><span class="line"> * 将程序读到的数据写入目标文件</span><br><span class="line"> */</span><br><span class="line">public class TestOutputStream2 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line"> //1.选择合适的流</span><br><span class="line"> FileOutputStream fos=new FileOutputStream(new File(&quot;D:\\qf1717\\byte写1.txt&quot;));</span><br><span class="line"> //2.处理数据</span><br><span class="line">  String s=&quot;abcdefghijklmn&quot;;</span><br><span class="line">  byte[] buf = s.getBytes();</span><br><span class="line">  fos.write(buf);</span><br><span class="line"> //3.关闭流</span><br><span class="line">  fos.close();</span><br><span class="line">  System.out.println(&quot;程序结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：<br>文件输出流有个构造方法两个参数，<br> public FileOutputStream(File file, boolean append)</p><p>file - 为了进行写入而打开的文件。<br>append - 如果为 true，则将字节写入文件末尾处，而不是写入文件开始处 ，默认是false</p><h6 id="字节数组输入输出流"><a href="#字节数组输入输出流" class="headerlink" title="字节数组输入输出流"></a>字节数组输入输出流</h6><p>==ByteArrayInputStream和ByteArrayOutputStream==</p><p>字节数组输入输出流又称为内存流，下面通过内存流实现图片的复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.bytearrayio.test;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件字节输入流  文件字节输出流  字节数组输入流  字节数组输出流</span><br><span class="line"> * 功能：借助 内存流完成图片copy</span><br><span class="line"> *    分析：</span><br><span class="line"> *       文件字节输入流  找到资源文件  read </span><br><span class="line"> *       字节数组输出流  写</span><br><span class="line"> *       程序</span><br><span class="line"> *        字节数组输入流 读</span><br><span class="line"> *         文件字节输出流 写</span><br><span class="line"> */</span><br><span class="line">public class TestCopy &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建流的对象</span><br><span class="line">FileInputStream fis=new FileInputStream(new File(&quot;Koala.jpg&quot;));</span><br><span class="line">ByteArrayOutputStream bos=new ByteArrayOutputStream();</span><br><span class="line">//处理数据</span><br><span class="line">byte [] buf=new byte[1024];</span><br><span class="line">int len=fis.read(buf);</span><br><span class="line">while(len!=-1)&#123;</span><br><span class="line">//写</span><br><span class="line">bos.write(buf, 0, len);</span><br><span class="line">//再读</span><br><span class="line">len=fis.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;写入内存流中成功&quot;);</span><br><span class="line"></span><br><span class="line">byte[] buf1 = bos.toByteArray();//将内存流中的数据取出形参字节数组</span><br><span class="line">//读的流的对象</span><br><span class="line">ByteArrayInputStream bis=new ByteArrayInputStream(buf1);</span><br><span class="line">FileOutputStream fos=new FileOutputStream(new File(&quot;Koala(复制).jpg&quot;));</span><br><span class="line">//处理数据</span><br><span class="line">/*int n = bis.read();</span><br><span class="line">while(n!=-1)&#123;</span><br><span class="line">fos.write(n);</span><br><span class="line">n=bis.read();</span><br><span class="line">&#125;*/</span><br><span class="line">int n=0;</span><br><span class="line">while((n=bis.read())!=-1)&#123;</span><br><span class="line">fos.write(n);</span><br><span class="line">&#125;</span><br><span class="line">//关闭流</span><br><span class="line">fos.close();</span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br><span class="line">fis.close();</span><br><span class="line">System.out.println(&quot;复制完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>writeTo方法:将此字节数组输出流的全部内容写 入到指定的输出流参数中</li><li>reset:将此字节数组输出流的 count 字段重置 为零，从而丢弃输出流中目前已累积的所有输 出。通过重新使用已分配的缓冲区空间，可以再次使用该输出流</li></ul><p>使用内存流实现数据的读写操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 字节数组输入流 ：</span><br><span class="line"> *    ByteArrayInputStream:内存流</span><br><span class="line"> *                         读</span><br><span class="line"> *   String.getBytes():  String ------&gt;byte[]</span><br><span class="line"> * 字节数组输出流：</span><br><span class="line"> *    ByteArrayOutputStream:内存流</span><br><span class="line"> *                          写</span><br><span class="line"> *                bos.toByteArray();将内存中数据取出来 转换为字节数组</span><br><span class="line"> */</span><br><span class="line">public class Test2 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">ByteArrayOutputStream bos=new ByteArrayOutputStream();</span><br><span class="line">//向字节数组输出流写入数据</span><br><span class="line">bos.write(&quot;nihao123&quot;.getBytes());</span><br><span class="line">System.out.println(&quot;写入成功&quot;);</span><br><span class="line">//2.处理数据</span><br><span class="line">//将内存流的数据转换为字节数组 byte[]**</span><br><span class="line">byte[] buf = bos.toByteArray();</span><br><span class="line">System.out.println(buf.length);//nihao123</span><br><span class="line">ByteArrayInputStream bis=new ByteArrayInputStream(buf);//byte[]</span><br><span class="line">//从内存数组输入流读到数据 打印到控制台</span><br><span class="line">byte [] buf1=new byte[1024];</span><br><span class="line">int len = bis.read(buf1);</span><br><span class="line">while(len!=-1)&#123;</span><br><span class="line">System.out.println(new String(buf1,0,len));</span><br><span class="line">len=bis.read(buf1);</span><br><span class="line">&#125;</span><br><span class="line">//3关闭流</span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">System.out.println(&quot;程序结束&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h5><p>==BufferedInputStream和BufferedOutputStream==</p><p>实现图片的复制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedOutputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestCopy &#123;</span><br><span class="line">public static void main(String[] args)  &#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">BufferedInputStream bis=null;</span><br><span class="line">BufferedOutputStream bos=null;</span><br><span class="line">try &#123;</span><br><span class="line">bis = new BufferedInputStream(new FileInputStream(&quot;D:\\qf1717\\Koala.jpg&quot;));</span><br><span class="line">bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\qf1717\\Koala复制(BUF).jpg&quot;));</span><br><span class="line">//2.处理数据</span><br><span class="line">  byte [] buf=new byte[1024];</span><br><span class="line">  int len=bis.read(buf);</span><br><span class="line">  while(len!=-1)&#123;</span><br><span class="line">  bos.write(buf, 0, len);//保证最后一次读取数据有效</span><br><span class="line">  len=bis.read(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">if(bos!=null)&#123;</span><br><span class="line">//3.关闭流</span><br><span class="line">  try &#123;</span><br><span class="line">bos.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">if(bis!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">bis.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;复制完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>public BufferedInputStream(InputStream in,int size)这个构造方法中size默认的大小是8192</li><li>用flush()方法更新流，要想在程序结束之前将缓冲区里的数据写 入磁盘，除了填满缓冲区或关闭输出流外， 还可以显式调用flush()方法</li></ul><h6 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h6><p>==DataInputStream和DataOutputStream==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.dataio.test;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedOutputStream;</span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * DataInputStream  DataOutputStream</span><br><span class="line"> *   里面提供存储java基本数据类型： 四类八种   String</span><br><span class="line"> *   处理流  只针对字节流 （二进制文件）</span><br><span class="line"> *  IOException 的子类  java.io.EOFException</span><br><span class="line"> *    EOF：End of File</span><br><span class="line"> */</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//write();</span><br><span class="line">//read();</span><br><span class="line">System.out.println(System.getProperties());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void write() throws IOException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileOutputStream fos=new FileOutputStream(new File(&quot;D:\\qf1717\\DataIO.txt&quot;));</span><br><span class="line">BufferedOutputStream bos=new BufferedOutputStream(fos);</span><br><span class="line">DataOutputStream dos=new DataOutputStream(bos);</span><br><span class="line">//2.处理数据</span><br><span class="line">  //基本数据类型</span><br><span class="line">  dos.writeInt(12);</span><br><span class="line">  dos.writeDouble(34.5);</span><br><span class="line">  dos.writeChar(&apos;A&apos;);</span><br><span class="line">  dos.writeBoolean(true);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //处理字符串</span><br><span class="line">  dos.writeUTF(&quot;我爱你中国&quot;);</span><br><span class="line">//3.关闭流</span><br><span class="line">  dos.close();</span><br><span class="line">&#125;</span><br><span class="line">public static void read() throws IOException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileInputStream fis=new FileInputStream(new File(&quot;D:\\qf1717\\DataIO.txt&quot;));</span><br><span class="line">BufferedInputStream bis=new BufferedInputStream(fis);</span><br><span class="line">DataInputStream dis=new DataInputStream(bis);</span><br><span class="line">//2.处理数据</span><br><span class="line">  //基本数据类型</span><br><span class="line">System.out.println(dis.readInt());</span><br><span class="line">System.out.println(dis.readDouble());</span><br><span class="line">System.out.println(dis.readChar());</span><br><span class="line">System.out.println(dis.readBoolean());</span><br><span class="line"></span><br><span class="line">  //String</span><br><span class="line">System.out.println(dis.readUTF());</span><br><span class="line">//3.关闭流</span><br><span class="line">dis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h6><p>==PrintStream==</p><p>功能：键盘录入信息 通过打印流 将数据保存到文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">PrintWriter pw=new PrintWriter(new FileWriter(new File(&quot;D:\\qf1717\\123(打印流).txt&quot;)));</span><br><span class="line">//2.处理数据</span><br><span class="line">String data = br.readLine();</span><br><span class="line">while(data!=null)&#123;</span><br><span class="line">pw.write(data);</span><br><span class="line">pw.flush();</span><br><span class="line">data=br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">//3关闭流</span><br><span class="line">pw.close();</span><br><span class="line">br.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h6><p>==ObjectInputStream和ObjectOutputStream==</p><p>这里涉及到对象的序列化和反序列化，这里我来简单的介绍一下。</p><p>序列化</p><p>将对象转换为字节流保存起来，并在以后 还原这个对象，这种机制叫做对象序列化，将一个对象保存到永久存储设备上称为持久化， 一个对象要想能够实现序列化，必须实现 Serializable接口或Externalizable接口。</p><p>序列化（serialization）是把一个对象的状态写入 一个字节流的过程。当你想要把你的程序状态存 到一个固定的存储区域例如文件时，它是很管用 的。稍后一点时间，你就可以运用序列化过程存储这些对象  </p><p> 假设一个被序列化的对象引用了其他对象，同样，其他对象又引用了更多的对象对象 和它们的关系形成了一个顺序图表。图表中也有循环引用。也就是说，对象X可以含有一个对象Y的引用，对象Y同样可以包含一个对象X的引用。对象同样可以包含它们自己的引用。对象序列化和反序列化的工具被设计出来并在这 一假定条件下运行良好。如果你试图序列化一个 对象图表中顶层的对象，所有的其他的引用对象 都被循环的定位和序列化。同样，在反序列化过 程中，所有的这些对象以及它们的引用都被正确 的恢复  </p><p>• 当一个对象被序列化时，只保存对象的非静态成 员变量，不能保存任何的成员方法和静态的成员 变量。</p><p>• 如果一个对象的成员变量是一个对象，那么这个 对象的数据成员也会被保存。</p><p>• 如果一个可序列化的对象包含对某个不可序列化 的对象的引用，那么整个序列化操作将会失败， 并且会抛出一个NotSerializableException。我 们可以将这个引用标记为transient，那么对象仍 然可以序列化 </p><p><strong>Serializable接口</strong> </p><ul><li>只有一个实现Serializable接口的对象可以被 序列化工具存储和恢复。Serializable接口没 有定义任何成员。它只用来表示一个类可以被 序列化。如果一个类可以序列化，它的所有子 类都可以序列化。</li><li>声明成transient的变量不被序列化工具存储。 同样，static变量也不被存储 </li></ul><p> Externalizable接口 </p><ul><li>Java的序列化和反序列化的工具被设计出来，所以很多存 储和恢复对象状态的工作自动进行。然而，在某些情况下， 程序员必须控制这些过程。例如，在需要使用压缩或加密 技术时，Externalizable接口为这些情况而设计。 </li></ul><p>Externalizable 接口定义了两个方法：</p><ul><li>– void readExternal(ObjectInput inStream)      throws IOException, ClassNotFoundException</li><li>– void writeExternal(ObjectOutput outStream)      throws IOException </li></ul><p>这些方法中，inStream是对象被读取的字节流，outStream是 对象被写入的字节流。 </p><p>• Externalizable 实例类的惟一特性是可以 被写入序列化流中，该类负责保存和恢复 实例内容。 若某类要完全控制某一对象及 其超类型的流格式和内容，则它要实现 Externalizable 接口的 writeExternal 和 readExternal 方法。这些方法必须显式与 超类型进行协调以保存其状态。这些方法 将代替自定义的 writeObject 和 readObject 方法实现 </p><p>接下来我们来看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.objectio.test;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Student implements Serializable&#123;</span><br><span class="line">   private int sid;</span><br><span class="line">   private String name;</span><br><span class="line">   private int age;</span><br><span class="line">   public Student() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public Student(int sid, String name, int age) &#123;</span><br><span class="line">super();</span><br><span class="line">this.sid = sid;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public int getSid() &#123;</span><br><span class="line">return sid;</span><br><span class="line">&#125;</span><br><span class="line">public void setSid(int sid) &#123;</span><br><span class="line">this.sid = sid;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Student [sid=&quot; + sid + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.objectio.test;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对象流</span><br><span class="line"> * 对象序列化： 对象数据   -------》 文件 （二进制文件）</span><br><span class="line"> * 对象反序列化：文件中的数据-----&gt;对象 </span><br><span class="line"> *  java.io.NotSerializableException: com.qf.objectio.test.Student</span><br><span class="line"> *  </span><br><span class="line"> *  联通  UTF-8**</span><br><span class="line"> */</span><br><span class="line">public class TestStudent &#123;</span><br><span class="line">public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">//writeObject();</span><br><span class="line">readObject();</span><br><span class="line">&#125;</span><br><span class="line">public static void writeObject() throws IOException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileOutputStream fos=new FileOutputStream(new File(&quot;D:\\qf1717\\对象流.txt&quot;));</span><br><span class="line">ObjectOutputStream oos=new ObjectOutputStream(fos);</span><br><span class="line">//2.处理数据</span><br><span class="line">Student stu1=new Student(1001,&quot;aa&quot;,17);</span><br><span class="line">oos.writeObject(stu1);//Object</span><br><span class="line">//3.关闭流</span><br><span class="line">oos.close();</span><br><span class="line">System.out.println(&quot;完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void readObject() throws IOException, ClassNotFoundException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileInputStream fis=new FileInputStream(new File(&quot;D:\\qf1717\\对象流.txt&quot;));</span><br><span class="line">ObjectInputStream ois=new ObjectInputStream(fis);</span><br><span class="line">//2.处理数据</span><br><span class="line">Student stu=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu);</span><br><span class="line">System.out.println(stu.getSid()+&quot;\t&quot;+stu.getName()+&quot;\t&quot;+stu.getAge());</span><br><span class="line">//3.关闭流</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当我们可序列化的对象引用了其他的对象的时候结果怎样呢，我们继续来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Grade implements Serializable &#123;</span><br><span class="line">    /**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = 7208450044584117263L;</span><br><span class="line">private int gid;</span><br><span class="line">    private String gname;</span><br><span class="line">public Grade(int gid, String gname) &#123;</span><br><span class="line">super();</span><br><span class="line">this.gid = gid;</span><br><span class="line">this.gname = gname;</span><br><span class="line">&#125;</span><br><span class="line">public Grade() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public int getGid() &#123;</span><br><span class="line">return gid;</span><br><span class="line">&#125;</span><br><span class="line">public void setGid(int gid) &#123;</span><br><span class="line">this.gid = gid;</span><br><span class="line">&#125;</span><br><span class="line">public String getGname() &#123;</span><br><span class="line">return gname;</span><br><span class="line">&#125;</span><br><span class="line">public void setGname(String gname) &#123;</span><br><span class="line">this.gname = gname;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Grade [gid=&quot; + gid + &quot;, gname=&quot; + gname + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.objectio.test;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Student2 implements Serializable&#123;</span><br><span class="line">   /**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">private int sid;</span><br><span class="line">   private static String name=&quot;张三&quot;;</span><br><span class="line">   private transient int age=18;//瞬时属性</span><br><span class="line">   private Grade grade;</span><br><span class="line">   </span><br><span class="line">   public Student2() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">public Student2(int sid, String name, int age) &#123;</span><br><span class="line">super();</span><br><span class="line">this.sid = sid;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student2(int sid, String name, int age, Grade grade) &#123;</span><br><span class="line">super();</span><br><span class="line">this.sid = sid;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Grade getGrade() &#123;</span><br><span class="line">return grade;</span><br><span class="line">&#125;</span><br><span class="line">public void setGrade(Grade grade) &#123;</span><br><span class="line">this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line">public int getSid() &#123;</span><br><span class="line">return sid;</span><br><span class="line">&#125;</span><br><span class="line">public void setSid(int sid) &#123;</span><br><span class="line">this.sid = sid;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Student [sid=&quot; + sid + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.objectio.test;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * java.io.NotSerializableException: com.qf.objectio.test.Grade</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestStudent2 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">writeObject();</span><br><span class="line">readObject();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 序列化</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void writeObject() throws IOException&#123;</span><br><span class="line">//1.选择合适流</span><br><span class="line">FileOutputStream fos=new FileOutputStream(new File(&quot;D:\\qf1717\\对象流2.txt&quot;));</span><br><span class="line">ObjectOutputStream oos=new ObjectOutputStream(fos);</span><br><span class="line">//2处理数据</span><br><span class="line">Grade g=new Grade(1,&quot;1717&quot;);</span><br><span class="line">Student2 stu1=new Student2(1001,&quot;aa&quot;,17,g);</span><br><span class="line">oos.writeObject(stu1);</span><br><span class="line">//3.关闭流</span><br><span class="line">oos.close();</span><br><span class="line">System.out.println(&quot;完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 反序列化</span><br><span class="line"> * @throws IOException</span><br><span class="line"> * @throws ClassNotFoundException </span><br><span class="line"> */</span><br><span class="line">public static void readObject() throws IOException, ClassNotFoundException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileInputStream fis=new FileInputStream(new File(&quot;D:\\qf1717\\对象流2.txt&quot;));</span><br><span class="line">ObjectInputStream ois=new ObjectInputStream(fis);</span><br><span class="line">//2.处理数据</span><br><span class="line">Student2 stu1=(Student2)ois.readObject();</span><br><span class="line">System.out.println(stu1);</span><br><span class="line">System.out.println(stu1.getGrade().getGid());</span><br><span class="line">System.out.println(stu1.getGrade().getGname());</span><br><span class="line">//3.关闭流</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.objectio.test;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对象流</span><br><span class="line"> * 对象序列化： 对象数据   -------》 文件 （二进制文件）</span><br><span class="line"> * 对象反序列化：文件中的数据-----&gt;对象 </span><br><span class="line"> *  java.io.NotSerializableException: com.qf.objectio.test.Student</span><br><span class="line"> *  </span><br><span class="line"> *  联通  UTF-8**</span><br><span class="line"> */</span><br><span class="line">public class TestStudent3 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">//writeObject();</span><br><span class="line">readObject();</span><br><span class="line">&#125;</span><br><span class="line">public static void writeObject() throws IOException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileOutputStream fos=new FileOutputStream(new File(&quot;D:\\qf1717\\对象流.txt&quot;));</span><br><span class="line">ObjectOutputStream oos=new ObjectOutputStream(fos);</span><br><span class="line">//2.处理数据</span><br><span class="line">Student stu1=new Student(1001,&quot;aa&quot;,17);</span><br><span class="line">Student stu2=new Student(1002,&quot;aa&quot;,18);</span><br><span class="line">Student stu3=new Student(1003,&quot;aa&quot;,19);</span><br><span class="line">Student stu4=new Student(1004,&quot;aa&quot;,17);</span><br><span class="line">Student stu5=new Student(1005,&quot;aa&quot;,16);</span><br><span class="line">oos.writeInt(5);</span><br><span class="line">oos.writeObject(stu1);//Object</span><br><span class="line">oos.writeObject(stu2);//Object</span><br><span class="line">oos.writeObject(stu3);//Object</span><br><span class="line">oos.writeObject(stu4);//Object</span><br><span class="line">oos.writeObject(stu5);//Object</span><br><span class="line">//3.关闭流</span><br><span class="line">oos.close();</span><br><span class="line">System.out.println(&quot;完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void readObject() throws IOException, ClassNotFoundException&#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">FileInputStream fis=new FileInputStream(new File(&quot;D:\\qf1717\\对象流.txt&quot;));</span><br><span class="line">ObjectInputStream ois=new ObjectInputStream(fis);</span><br><span class="line">//2.处理数据</span><br><span class="line">/*Student stu1=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu1);</span><br><span class="line">Student stu2=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu2);</span><br><span class="line">Student stu3=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu3);</span><br><span class="line">Student stu4=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu4);</span><br><span class="line">Student stu5=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu5);*/</span><br><span class="line"></span><br><span class="line">int count = ois.readInt();</span><br><span class="line">for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">Student stu=(Student)ois.readObject();</span><br><span class="line">System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line">//3.关闭流</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果边读边写，那么静态变量为输入的数据，瞬时变量为默认值，如果写完之后再读，那么静态变量是初始值，瞬时变量为默认值。</p><p>反序列化时不会调用对象的任何构造方法，仅 仅根据所保存的对象状态信息，在内存中重新 构建对象 </p><p><strong>小结</strong>：</p><ol><li><p>一个类若想被序列化，则需要实现java.io.Serializable接口，该接口中没有定义任何方法，是一个标识性接口（Marker Interface），当一个类实现了该接口，就表示这个类的对象是可以序列化的。</p></li><li><p>在序列化时，static变量是无法序列化的；如果A包含了对B的引用，那么在序列化A的时候也会将B一并地序列化；如果此时A可以序列化，B无法序列化，那么当序列化A的时候就会发生异常，这时就需要将对B的引用设为transient，该关键字表示变量不会被序列化。</p></li><li><p>当我们在一个待序列化/反序列化的类中实现了以上两个private方法（方法声明要与上面的保持完全的一致），那么就允许我们以更加底层、更加细粒度的方式控制序列化/反序列化的过程。</p></li></ol><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">csdn博客相关内容</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的IO流总结（1）</title>
      <link href="/2018/07/15/java-io/"/>
      <url>/2018/07/15/java-io/</url>
      <content type="html"><![CDATA[<p>IO流这块知识点比较多而且琐碎，今天我就来总结一下IO流的知识点。</p><h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><hr><p>File类的直接父类是Object类。</p><p>下面的<strong>构造方法</strong>可以用来生成File 对象：</p><ul><li>File(String directoryPath) </li><li>File(String directoryPath, String filename) </li><li>File(File dirObj, String filename) </li></ul><p>这里，directoryPath是文件的路径名， filename 是文件名，dirObj 是一个指定目录的File 对象.</p><p><strong>目录操作的主要方法</strong>为： </p><ul><li>public boolean mkdir() 根据抽象路径名创建目录。 </li><li>public String[] list() 返回抽象路径名表示路径中 的文件名和目录名。 </li></ul><p>File类是++不对称++的。说它不对 称，意思是虽然存在允许验证一个简单文 件对象属性的很多方法，但是没有相应的 方法来改变这些属性</p><p> <strong>File类中的常用方法</strong> </p><ul><li>String getName() </li><li>String getPath() </li><li>String getAbsolutePath()</li><li>String getParent()</li><li>boolean renameTo( File newName)</li><li>long length()</li><li>boolean delete() </li><li>boolean mkdir()</li><li>String[] list()<ul><li>boolean exists() </li><li>boolean canWrite() </li><li>boolean canRead()</li><li>boolean isFile()<br>-boolean isDirectory()</li><li>File[ ] listFiles()</li></ul></li></ul><p><strong>路径分隔符</strong></p><p>Windows里面的\表示转义，在程序中需要使用双反斜杠\,或者是使用/，其他的系统都是使用的/。</p><h4 id="流类"><a href="#流类" class="headerlink" title="流类"></a>流类</h4><hr><ul><li>输入/输出时，数据在通信通道中流动。所谓“数 据流(stream)”指的是所有数据通信通道之中， 数据的起点和终点。信息的通道就是一个数据流。 只要是数据从一个地方“流”到另外一个地方， 这种数据流动的通道都可以称为数据流。 </li><li>输入/输出是相对于程序来说的。程序在使用数据 时所扮演的角色有两个：一个是源，一个是目的。 若程序是数据流的源，即数据的提供者，这个数 据流对程序来说就是一个“输出数据流”(数据从 程序流出)。若程序是数据流的终点，这个数据流 对程序而言就是一个“输入数据流” ( 数据从程 序外流向程序)</li></ul><p>Java 2 定义了两种类型的流：<br><strong>字节流和字符流</strong>。</p><p><strong>字节流</strong>（byte stream）为处理字 节的输入和输出提供了方便的方法。例如 使用字节流读取或写入二进制数据。<strong>字符流</strong>（character stream）为字符的输入和 输出处理提供了方便。它们采用了统一的 编码标准，因而可以国际化。当然，在某 些场合，字符流比字节流更有效</p><p>==在最底层，所有的输入/输出都 是字节形式的==。基于字符的流只为处理字符提供方便有效的方法.</p><ul><li>字节流类（Byte Streams） 字节流类用于 向字节流读写8位二进制的字节。一般地， 字节流类主要用于读写诸如图象或声音等 的二进制数据。</li><li>字符流类（Character Streams） 字符流 类用于向字符流读写16位二进制字符</li></ul><h6 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h6><ol><li>两种基本的流是：输入流(Input Stream) 和输出流(Output Stream)。可从中读出 一系列字节的对象称为输入流。而能向其 中写入一系列字节的对象称为输出流。</li></ol><p>2.节点流：从特定的地方读写的流类，例如：磁盘或一块内存区域。 过滤流：使用节点流作为输入或输出。过滤流是使用一个已经存在的 输入流或输出流连接创建的。</p><h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><p>字节流类以InputStream 和 OutputStream为顶层类,他们都是抽象类 (abstract)，抽象类InputStream 和 OutputStream定义了实现其 他流类的关键方法。最重要的两种方法是read()和write()，它们分别对数据的字节进行读写。两种 方法都在InputStream 和OutputStream中被定义为 抽象方法。它们被派生的流类重写。每个抽象类都有多个具体的子类，这些子类对不同的外设进行处理，例如磁盘文件，网络连接，甚至是内存缓冲区。 要使用流类，必须导入java.io包。</p><p> 三个基本的读方法 </p><ul><li>abstract int read() ：读取一个字节数据， 并返回读到的数据，如果返回-1，表示读到了输 入流的末尾。 </li><li>int read(byte[] b) ：将数据读入一个字节 数组，同时返回实际读取的字节数。如果返回-1， 表示读到了输入流的末尾。</li><li>int read(byte[] b, int off, int len) ：将数 据读入一个字节数组，同时返回实际读取的字节 数。如果返回-1，表示读到了输入流的末尾。off 指定在数组b中存放数据的起始偏移位置；len指 定读取的最大字节数。</li></ul><p>为什么只有第一个read方法是抽象 的，而其余两个read方法都是具体的？</p><ul><li>因为第二个read方法依靠第三个read方法 来实现，而第三个read方法又依靠第一个 read方法来实现，所以说只有第一个read 方法是与具体的I/O设备相关的，它需要 InputStream的子类来实现</li></ul><p>其它方法 </p><ul><li>long skip(long n) ：在输入流中跳过n个字节，并返 回实际跳过的字节数。 </li><li>int available() ：返回在不发生阻塞的情况下，可读 取的字节数。</li><li>void close() ：关闭输入流，释放和这个流相关的系 统资源。</li><li>void mark(int readlimit) ：在输入流的当前位置放 置一个标记，如果读取的字节数多于readlimit设置的值， 则流忽略这个标记。 </li><li>void reset() ：返回到上一个标记。 </li><li>boolean markSupported() ：测试当前流是否支持 mark和reset方法。如果支持，返回true，否则返回 false。</li></ul><ul><li>InputStream中包含一套字节输入流需要的方法， 可以完成最基本的从输入流读入数据的功能。当 Java程序需要外设的数据时，可根据数据的不同 形式，创建一个适当的InputStream子类类型的对 象来完成与该外设的连接，然后再调用执行这个 流类对象的特定输入方法来实现对相应外设的输 入操作。</li><li>InputStream 类 子 类 对 象 自 然 也 继 承 了 InputStream类的方法。常用的方法有：读数据的 方法read() ， 获取输入流字节数的方法 available()，定位输入位置指针的方法skip()、 reset()、mark()等。</li></ul><p> 三个基本的写方法:</p><ul><li>abstract void write(int b) ：往输出 流中写入一个字节。 </li><li>void write(byte[] b) ：往输出流中写 入数组b中的所有字节。</li><li>void write(byte[] b, int off, int len) ：往输出流中写入数组b中从偏移 量off开始的len个字节的数据</li></ul><p>其它方法 </p><ul><li>void flush() ：刷新输出流，强制缓冲 区中的输出字节被写出。 </li><li>void close() ：关闭输出流，释放和这 个流相关的系统资源。</li></ul><h5 id="过滤流"><a href="#过滤流" class="headerlink" title="过滤流"></a>过滤流</h5><p>在InputStream类和OutputStream类子类中， FilterInputStream 和 FilterOutputStream 过滤流抽象类又派生出DataInputStream和 DataOutputStream数据输入输出流类等子 类。</p><p>过滤流的主要特点是在输入输出数据的同时能对所传输的 数据做指定类型或格式的转换，即可实现对二进制字节数 据的理解和编码转换。</p><ul><li>数据输入流DataInputStream中定义了多个针对不同类型 数 据 的 读 方 法 ， 如 readByte() 、 readBoolean() 、 readShort()、readChar()、readInt()、readLong()、 readFloat()、readDouble()、readLine()等。 </li><li>数据输出流DataOutputStream中定义了多个针对不同类型 数 据 的 写 方 法 ， 如 writeByte() 、 writeBoolean() 、 writeShort()、writeChar()、writeInt()、writeLong()、 writeFloat()、writeDouble()、writeChars()等。</li><li>过滤流在读/写数据的同时可以对数据进行 处理，它提供了同步机制，使得某一时刻 只有一个线程可以访问一个I/O流，以防止 多个线程同时对一个I/O流进行操作所带来 的意想不到的结果。 </li><li>类FilterInputStream和 FilterOutputStream分别作为所有过滤输 入流和输出流的父类。</li></ul><h6 id="基本的流类"><a href="#基本的流类" class="headerlink" title="基本的流类"></a>基本的流类</h6><ul><li>FileInputStream和FileOutputStream 节点流，用于从文件中读取或往文件中写入字节流。如果在构造 FileOutputStream时，文件已经存在，则覆盖这个文件。</li><li>BufferedInputStream和 BufferedOutputStream 过滤流，需要使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率。</li><li>DataInputStream和DataOutputStream 过滤流，需要使用已经存在的节点流来构造，提供了读写Java中的基本数 据类型的功能。 </li><li>PipedInputStream和PipedOutputStream 管道流，用于线程间的通信。一个线程的PipedInputStream对象 从另一个线程的PipedOutputStream对象读取输入。要使管道流有 用，必须同时构造管道输入流和管道输出流。</li></ul><p>java的IO库的设计原则是利用的装饰设计模式，前面我介绍过了。</p><p><a href="http://blog.csdn.net/prairie97/article/details/78599420" target="_blank" rel="noopener">装饰设计模式</a></p><h5 id="预定义流"><a href="#预定义流" class="headerlink" title="预定义流"></a>预定义流</h5><p>所有的Java程序自动导入java.lang包。该包 定义了一个名为System的类，该类封装了运 行时环境的多方面信息。例如，使用它的 某些方法，你能获得当前时间和与系统有 关的不同属性。System 同时包含三个预定 义的流变量，in，out和err。这些成员在 System中是被定义成public 和static型的，这 意味着它们可以不引用特定的System对象而 被用于程序的其他部分。</p><p>System.out是标准的输出流。默认情况下，它是一 个控制台。System.in是标准输入，默认情况下， 它指的是键盘。System.err指的是标准错误流，它 默认是控制台。然而，这些流可以重定向到任何 兼容的输入/输出设备 • System.in 是InputStream的对象；System.out和 System.err是PrintStream的对象。它们都是字节流， 尽管它们用来读写外设的字符。如果愿意，你可 以用基于字符的流来包装它们</p><p>• System类的类变量in表示标准输入流，其 定义为：</p><ul><li>public static final InputStream in </li><li>标准输入流已打开，作好提供输入数据的 准备。一般这个流对应键盘输入，可以使 用InputStream 类的read()和skip(long n)等方法来从输入流获得数据。read()从 输入流中读一个字节，skip(long n)在输 入流中跳过n个字节。</li></ul><p>System类的类变量out表示标准输出流，其定义 为：</p><ul><li>public static final PrintStream out</li><li>标准输出流也已打开，作好接收数据的准备。一 般这个流对应显示器输出。可以使用PrintStream 类的print()和println() 等方法来输出数据，这两个方法支持Java的任意 基本类型作为参数。</li></ul><p>System类的类变量err表示标准错误输出 流，其定义为：</p><ul><li>public static final PrintStream err</li><li>标准错误输出流已打开，作好接收数据的 准备。一般这个流也对应显示器输出，与 System.out一样，可以访问PrintStream 类的方法。</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">csdn博客相关内容</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>机器学习----逻辑斯蒂回归算法</title>
      <link href="/2018/04/16/logistics/"/>
      <url>/2018/04/16/logistics/</url>
      <content type="html"><![CDATA[<h1 id="逻辑斯蒂回归"><a href="#逻辑斯蒂回归" class="headerlink" title="逻辑斯蒂回归"></a>逻辑斯蒂回归</h1><h2 id="【关键词】Logistics函数，最大似然估计，梯度下降法"><a href="#【关键词】Logistics函数，最大似然估计，梯度下降法" class="headerlink" title="【关键词】Logistics函数，最大似然估计，梯度下降法"></a>【关键词】Logistics函数，最大似然估计，梯度下降法</h2><h2 id="1、Logistics回归的原理"><a href="#1、Logistics回归的原理" class="headerlink" title="1、Logistics回归的原理"></a>1、Logistics回归的原理</h2><p>利用Logistics回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。这里的“回归” 一词源于最佳拟合，表示要找到最佳拟合参数集。</p><p>训练分类器时的做法就是寻找最佳拟合参数，使用的是最优化算法。接下来介绍这个二值型输出分类器的数学原理</p><p>Logistic Regression和Linear Regression的原理是相似的，可以简单的描述为这样的过程：</p><p>（1）找一个合适的预测函数，一般表示为h函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。这个过程是非常关键的，需要对数据有一定的了解或分析，知道或者猜测预测函数的“大概”形式，比如是线性函数还是非线性函数。</p><p>（2）构造一个Cost函数（损失函数），该函数表示预测的输出（h）与训练数据类别（y）之间的偏差，可以是二者之间的差（h-y）或者是其他的形式。综合考虑所有训练数据的“损失”，将Cost求和或者求平均，记为J(θ)函数，表示所有训练数据预测值与实际类别的偏差。</p><p>（3）显然，J(θ)函数的值越小表示预测函数越准确（即h函数越准确），所以这一步需要做的是找到J(θ)函数的最小值。找函数的最小值有不同的方法，Logistic Regression实现时有梯度下降法（Gradient Descent）。</p><h3 id="1-构造预测函数"><a href="#1-构造预测函数" class="headerlink" title="1)  构造预测函数"></a>1)  构造预测函数</h3><p>Logistic Regression虽然名字里带“回归”，但是它实际上是一种分类方法，用于两分类问题（即输出只有两种）。首先需要先找到一个预测函数（h），显然，该函数的输出必须是两类值（分别代表两个类别），所以利用了<em>Logistic函数（或称为Sigmoid函数）</em>，函数形式为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172751.PNG" alt="Untitled-1-2018416172751"><br>该函数形状为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841617280.PNG" alt="Untitled-1-201841617280"></p><p>预测函数可以写为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841617284.jpg" alt="Untitled-1-201841617284"></p><h3 id="2）构造损失函数"><a href="#2）构造损失函数" class="headerlink" title="2）构造损失函数"></a>2）构造损失函数</h3><p>Cost函数和J(θ)函数是基于<em>最大似然估计</em>推导得到的。</p><p>每个样本属于其真实标记的概率，即似然函数，可以写成：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841617287.jpg" alt="Untitled-1-201841617287"></p><p>所有样本都属于其真实标记的概率为</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172811.jpg" alt="Untitled-1-2018416172811"></p><p>对数似然函数为</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172855.jpg" alt="Untitled-1-2018416172855"></p><p>最大似然估计就是要求得使l(θ)取最大值时的θ，其实这里可以使用梯度上升法求解，求得的θ就是要求的最佳参数</p><h3 id="3-梯度下降法求J-θ-的最小值"><a href="#3-梯度下降法求J-θ-的最小值" class="headerlink" title="3) 梯度下降法求J(θ)的最小值"></a>3) 梯度下降法求J(θ)的最小值</h3><p>求J(θ)的最小值可以使用<em>梯度下降法</em>，根据梯度下降法可得θ的更新过程:</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172859.jpg" alt="Untitled-1-2018416172859"></p><p>式中为α学习步长，下面来求偏导：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841617294.jpg" alt="Untitled-1-201841617294"></p><p>上式求解过程中用到如下的公式：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172910.jpg" alt="Untitled-1-2018416172910"></p><p>因此，θ的更新过程可以写成:</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172913.jpg" alt="Untitled-1-2018416172913"></p><p>因为式中α本来为一常量，所以1/m一般将省略，所以最终的θ更新过程为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416172918.jpg" alt="Untitled-1-2018416172918"></p><h2 id="2、实战"><a href="#2、实战" class="headerlink" title="2、实战"></a>2、实战</h2><p><code>sklearn.linear_model.LogisticRegression(penalty=&#39;l2&#39;, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=&#39;liblinear&#39;, max_iter=100, multi_class=&#39;ovr&#39;, verbose=0, warm_start=False, n_jobs=1)</code></p><p>solver参数的选择：</p><ul><li>“liblinear”：小数量级的数据集</li><li>“lbfgs”, “sag” or “newton-cg”：大数量级的数据集以及多分类问题</li><li>“sag”：极大的数据集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑斯提 Logistic </span></span><br><span class="line"><span class="comment"># 是一个线性回归模型，处理二分类问题</span></span><br><span class="line"><span class="comment"># 概率论</span></span><br><span class="line"><span class="comment"># 对分类边界建立回归公式</span></span><br><span class="line"><span class="comment"># 不能处理回归问题</span></span><br></pre></td></tr></table></figure><h3 id="1-手写数字数据集的分类"><a href="#1-手写数字数据集的分类" class="headerlink" title="1) 手写数字数据集的分类"></a>1) 手写数字数据集的分类</h3><p>使用KNN与Logistic回归两种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digits = load_digits()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digits</span><br></pre></td></tr></table></figure><pre><code>{&apos;DESCR&apos;: &quot;Optical Recognition of Handwritten Digits Data Set\n===================================================\n\nNotes\n-----\nData Set Characteristics:\n    :Number of Instances: 5620\n    :Number of Attributes: 64\n    :Attribute Information: 8x8 image of integer pixels in the range 0..16.\n    :Missing Attribute Values: None\n    :Creator: E. Alpaydin (alpaydin &apos;@&apos; boun.edu.tr)\n    :Date: July; 1998\n\nThis is a copy of the test set of the UCI ML hand-written digits datasets\nhttp://archive.ics.uci.edu/ml/datasets/Optical+Recognition+of+Handwritten+Digits\n\nThe data set contains images of hand-written digits: 10 classes where\neach class refers to a digit.\n\nPreprocessing programs made available by NIST were used to extract\nnormalized bitmaps of handwritten digits from a preprinted form. From a\ntotal of 43 people, 30 contributed to the training set and different 13\nto the test set. 32x32 bitmaps are divided into nonoverlapping blocks of\n4x4 and the number of on pixels are counted in each block. This generates\nan input matrix of 8x8 where each element is an integer in the range\n0..16. This reduces dimensionality and gives invariance to small\ndistortions.\n\nFor info on NIST preprocessing routines, see M. D. Garris, J. L. Blue, G.\nT. Candela, D. L. Dimmick, J. Geist, P. J. Grother, S. A. Janet, and C.\nL. Wilson, NIST Form-Based Handprint Recognition System, NISTIR 5469,\n1994.\n\nReferences\n----------\n  - C. Kaynak (1995) Methods of Combining Multiple Classifiers and Their\n    Applications to Handwritten Digit Recognition, MSc Thesis, Institute of\n    Graduate Studies in Science and Engineering, Bogazici University.\n  - E. Alpaydin, C. Kaynak (1998) Cascading Classifiers, Kybernetika.\n  - Ken Tang and Ponnuthurai N. Suganthan and Xi Yao and A. Kai Qin.\n    Linear dimensionalityreduction using relevance weighted LDA. School of\n    Electrical and Electronic Engineering Nanyang Technological University.\n    2005.\n  - Claudio Gentile. A New Approximate Maximal Margin Classification\n    Algorithm. NIPS. 2000.\n&quot;, &apos;data&apos;: array([[ 0.,  0.,  5., ...,  0.,  0.,  0.],        [ 0.,  0.,  0., ..., 10.,  0.,  0.],        [ 0.,  0.,  0., ..., 16.,  9.,  0.],        ...,        [ 0.,  0.,  1., ...,  6.,  0.,  0.],        [ 0.,  0.,  2., ..., 12.,  0.,  0.],        [ 0.,  0., 10., ..., 12.,  1.,  0.]]), &apos;images&apos;: array([[[ 0.,  0.,  5., ...,  1.,  0.,  0.],         [ 0.,  0., 13., ..., 15.,  5.,  0.],         [ 0.,  3., 15., ..., 11.,  8.,  0.],         ...,         [ 0.,  4., 11., ..., 12.,  7.,  0.],         [ 0.,  2., 14., ..., 12.,  0.,  0.],         [ 0.,  0.,  6., ...,  0.,  0.,  0.]],        [[ 0.,  0.,  0., ...,  5.,  0.,  0.],         [ 0.,  0.,  0., ...,  9.,  0.,  0.],         [ 0.,  0.,  3., ...,  6.,  0.,  0.],         ...,         [ 0.,  0.,  1., ...,  6.,  0.,  0.],         [ 0.,  0.,  1., ...,  6.,  0.,  0.],         [ 0.,  0.,  0., ..., 10.,  0.,  0.]],        [[ 0.,  0.,  0., ..., 12.,  0.,  0.],         [ 0.,  0.,  3., ..., 14.,  0.,  0.],         [ 0.,  0.,  8., ..., 16.,  0.,  0.],         ...,         [ 0.,  9., 16., ...,  0.,  0.,  0.],         [ 0.,  3., 13., ..., 11.,  5.,  0.],         [ 0.,  0.,  0., ..., 16.,  9.,  0.]],        ...,        [[ 0.,  0.,  1., ...,  1.,  0.,  0.],         [ 0.,  0., 13., ...,  2.,  1.,  0.],         [ 0.,  0., 16., ..., 16.,  5.,  0.],         ...,         [ 0.,  0., 16., ..., 15.,  0.,  0.],         [ 0.,  0., 15., ..., 16.,  0.,  0.],         [ 0.,  0.,  2., ...,  6.,  0.,  0.]],        [[ 0.,  0.,  2., ...,  0.,  0.,  0.],         [ 0.,  0., 14., ..., 15.,  1.,  0.],         [ 0.,  4., 16., ..., 16.,  7.,  0.],         ...,         [ 0.,  0.,  0., ..., 16.,  2.,  0.],         [ 0.,  0.,  4., ..., 16.,  2.,  0.],         [ 0.,  0.,  5., ..., 12.,  0.,  0.]],        [[ 0.,  0., 10., ...,  1.,  0.,  0.],         [ 0.,  2., 16., ...,  1.,  0.,  0.],         [ 0.,  0., 15., ..., 15.,  0.,  0.],         ...,         [ 0.,  4., 16., ..., 16.,  6.,  0.],         [ 0.,  8., 16., ..., 16.,  8.,  0.],         [ 0.,  1.,  8., ..., 12.,  1.,  0.]]]), &apos;target&apos;: array([0, 1, 2, ..., 8, 9, 8]), &apos;target_names&apos;: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train = digits.data</span><br><span class="line">target = digits.target</span><br><span class="line">images = digits.images</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.imshow(images[0])</span></span><br><span class="line">plt.imshow(train[<span class="number">0</span>].reshape(<span class="number">8</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416173051.png" alt="Untitled-1-2018416173051"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(train,target)</span><br></pre></td></tr></table></figure><p>导入数据load_digits()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br></pre></td></tr></table></figure><p>创建模型，训练和预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logistic = LogisticRegression(C=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># C惩罚系数 允许误差的阈值</span></span><br><span class="line"><span class="comment"># C越大，允许的误差越大</span></span><br><span class="line">logistic.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">y_ = logistic.predict(X_test)</span><br><span class="line"></span><br><span class="line">logistic.score(X_test,y_test)</span><br></pre></td></tr></table></figure><pre><code>0.9688888888888889</code></pre><p>展示结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    axes = plt.subplot(<span class="number">10</span>,<span class="number">10</span>,i+<span class="number">1</span>)</span><br><span class="line">    data = X_test[i].reshape(<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line">    plt.imshow(data,cmap=<span class="string">'gray'</span>)</span><br><span class="line">    t = y_test[i]</span><br><span class="line">    p = y_[i]</span><br><span class="line">    title = <span class="string">'T:'</span>+str(t) + <span class="string">'\nP:'</span>+str(p)</span><br><span class="line">    axes.set_title(title)</span><br><span class="line">    axes.axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416173120.png" alt="Untitled-1-2018416173120"></p><h3 id="2-使用make-blobs产生数据集进行分类"><a href="#2-使用make-blobs产生数据集进行分类" class="headerlink" title="2) 使用make_blobs产生数据集进行分类"></a>2) 使用make_blobs产生数据集进行分类</h3><p>导包使用datasets.make_blobs创建一系列点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><p>设置三个中心点，随机创建100个点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train,target = make_blobs(n_samples=<span class="number">150</span>,n_features=<span class="number">2</span>,centers=[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(train[:,<span class="number">0</span>],train[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416173123.png" alt="Untitled-1-2018416173123"></p><p>创建机器学习模型，训练数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logistic = LogisticRegression()</span><br><span class="line">knnclf = KNeighborsClassifier()</span><br><span class="line"></span><br><span class="line">logistic.fit(train,target)</span><br><span class="line">knnclf.fit(train,target)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=5, p=2,           weights=&apos;uniform&apos;)</code></pre><p>提取坐标点，对坐标点进行处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取边界</span></span><br><span class="line">xmin,xmax = train[:,<span class="number">0</span>].min()<span class="number">-0.5</span>, train[:,<span class="number">1</span>].max()+<span class="number">0.5</span></span><br><span class="line">ymin,ymax = train[:,<span class="number">1</span>].min()<span class="number">-0.5</span>, train[:,<span class="number">1</span>].max()+<span class="number">0.5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等差数列</span></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">200</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">200</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x和y交叉</span></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_test.shape</span><br></pre></td></tr></table></figure><pre><code>(40000, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416173127.png" alt="Untitled-1-2018416173127"></p><p>预测坐标点数据，并进行reshape()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time y1_ = logistic.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 3.97 ms</code></pre><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time y2_ = knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 87.2 ms</code></pre><p>​    </p><p>绘制图形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">colormap = ListedColormap([<span class="string">'#aa00ff'</span>,<span class="string">'#00aaff'</span>,<span class="string">'#aaffff'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_classifier_bounds</span><span class="params">(X_train,y_train,X_test,y_test)</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">    axes = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    axes.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_test,cmap=colormap)</span><br><span class="line">    axes.scatter(X_train[:,<span class="number">0</span>],X_train[:,<span class="number">1</span>],c=y_train)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_classifier_bounds(train,target,X_test,y1_)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416173132.png" alt="Untitled-1-2018416173132"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw_classifier_bounds(train,target,X_test,y2_)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018416173137.png" alt="Untitled-1-2018416173137"></p><p>【第1题】预测年收入是否大于50K美元</p><p>读取adult.txt文件，并使用逻辑斯底回归算法训练模型，根据种族、职业、工作时长来预测一个人的性别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples = pd.read_csv(<span class="string">'../data/adults.txt'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train = samples[[<span class="string">'race'</span>,<span class="string">'occupation'</span>,<span class="string">'hours_per_week'</span>]].copy()</span><br><span class="line">target = samples[<span class="string">'sex'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="string">'race'</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;White&apos;, &apos;Black&apos;, &apos;Asian-Pac-Islander&apos;, &apos;Amer-Indian-Eskimo&apos;,       &apos;Other&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">race_dic = &#123;</span><br><span class="line">    <span class="string">'White'</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">'Black'</span>:<span class="number">1</span>, </span><br><span class="line">    <span class="string">'Asian-Pac-Islander'</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">'Amer-Indian-Eskimo'</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">'Other'</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="string">'race'</span>] = train[<span class="string">'race'</span>].map(race_dic)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_arr = train[<span class="string">'occupation'</span>].unique()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_occ</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.argwhere(x == unique_arr)[<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="string">'occupation'</span>] = train[<span class="string">'occupation'</span>].map(transform_occ)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train,X_test,y_train,y_test = train_test_split(train,target,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logistic = LogisticRegression(C=<span class="number">100</span>)</span><br><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">logistic.fit(X_train,y_train)</span><br><span class="line">knnclf.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">y1_ = logistic.predict(X_test)</span><br><span class="line">y2_ = knnclf.predict(X_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'logistic score is %f'</span>%logistic.score(X_test,y_test))</span><br><span class="line">print(<span class="string">'knnclf score is %f'</span>%knnclf.score(X_test,y_test))</span><br></pre></td></tr></table></figure><pre><code>logistic score is 0.681406knnclf score is 0.714417</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于评分较低，把所有的数据特征都保留</span></span><br><span class="line"></span><br><span class="line">train = samples.drop(<span class="string">'sex'</span>,axis=<span class="number">1</span>).copy()</span><br><span class="line">target = samples.sex</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train.head(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">columns = train.columns[train.dtypes == object]</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> columns:</span><br><span class="line">    unique_arr = train[column].unique()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_obj</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.argwhere(x == unique_arr)[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    train[column] = train[column].map(transform_obj)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train.dtypes</span><br></pre></td></tr></table></figure><pre><code>age               int64workclass         int64final_weight      int64education         int64education_num     int64marital_status    int64occupation        int64relationship      int64race              int64capital_gain      int64capital_loss      int64hours_per_week    int64native_country    int64salary            int64dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train,X_test,y_train,y_test = train_test_split(train,target,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logistic = LogisticRegression(C=<span class="number">0.01</span>)</span><br><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">logistic.fit(X_train,y_train)</span><br><span class="line">knnclf.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">y1_ = logistic.predict(X_test)</span><br><span class="line">y2_ = knnclf.predict(X_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'logistic score is %f'</span>%logistic.score(X_test,y_test))</span><br><span class="line">print(<span class="string">'knnclf score is %f'</span>%knnclf.score(X_test,y_test))</span><br></pre></td></tr></table></figure><pre><code>logistic score is 0.668356knnclf score is 0.667895</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>进程和线程的区别与联系</title>
      <link href="/2018/04/14/thread-process/"/>
      <url>/2018/04/14/thread-process/</url>
      <content type="html"><![CDATA[<h2 id="进程和线程分析"><a href="#进程和线程分析" class="headerlink" title="进程和线程分析"></a>进程和线程分析</h2><p>下面就两者的区别和联系分析如下：</p><table><thead><tr><th></th><th><strong>进程</strong></th><th><strong>线程</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>资源（CPU时间、内存等）分配的最小单位</td><td>程序执行的最小单位</td></tr><tr><td><strong>区别</strong></td><td>1.独立的地址空间，每创建一个进程，就会给改进程分配一个4G的虚拟内存空间；2.进程是建立在虚拟内存的基础之上的。</td><td>1.没有单独的地址空间（同一进程内的线程共享进程的地址空间）；2.主要是为了将进程的资源申请和调度属性分开。</td></tr></tbody></table><table><thead><tr><th></th><th>进程与线程</th></tr></thead><tbody><tr><td><strong>联系</strong></td><td>1.一个进程有几个线程组成；2.线程与同属一个进程的其他的线程共享进程所拥有的全部资源。</td></tr><tr><td><strong>OS而言</strong></td><td>1.uCOS只有线程的概念，uCOS的整个程序可以理解为一个进程，而其中的任务就可以理解为一个个线程，有自己的堆栈和局部变量，但没有单独的地址空间；2.对于windows，linux等，其有进程和线程。</td></tr><tr><td><strong>线程的优势</strong></td><td>1.和进程相比，它是一种非常”节俭”的多任务操作方式。对进程而言，创建一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间；2.与进程相比，线程间的通信机制更方便。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便；3.提高应用程序响应。使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程；4.使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；5.改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</td></tr></tbody></table><p><strong>区分进程，用户进程，内核线程</strong><br><img src="https://img-blog.csdn.net/20160608152609878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><strong>uCOS/Linux</strong><br><strong>状态区别</strong></p><p><img src="https://img-blog.csdn.net/20160608152628491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p><img src="https://img-blog.csdn.net/20160608152635956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>异步非阻塞IO模块</title>
      <link href="/2018/04/14/io-asynchronous/"/>
      <url>/2018/04/14/io-asynchronous/</url>
      <content type="html"><![CDATA[<blockquote><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1></blockquote><h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def fetch_async(url):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url_list = [&apos;http://www.github.com&apos;, &apos;http://www.bing.com&apos;]</span><br><span class="line"></span><br><span class="line">for url in url_list:</span><br><span class="line">    fetch_async(url)</span><br></pre></td></tr></table></figure><h3 id="多线程实现并发"><a href="#多线程实现并发" class="headerlink" title="多线程实现并发"></a>多线程实现并发</h3><ul><li>两种编写形式<ol><li>请求和处理放在一起</li><li>请求和处理分开，请求成功后执行回调函数，降低了耦合性</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">可以实现并发</span><br><span class="line">但是，请求发送出去和返回之前，中间时期线程空闲</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">########### 编写方式一################</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def task(url):</span><br><span class="line"> response = requests.get(url) print(url,response) # 处理返回值 # 写正则</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(7)</span><br><span class="line">url_list = [</span><br><span class="line"> &apos;https://www.baidu.com/&apos;, &apos;https://www.sina.com/&apos;, &apos;https://www.zhihu.com/&apos;, &apos;https://www.autohome.com/&apos;, &apos;https://www.bing.com/&apos;, &apos;https://www.csdn.net/&apos;, &apos;https://www.oschina.net/&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for url in url_list:</span><br><span class="line"> pool.submit(task,url) pool.shutdown(wait=True)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">########### 编写方式二 回调函数################</span><br><span class="line"></span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def task(url):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"> 只下载页面  :param url:  :return:</span><br><span class="line"> &apos;&apos;&apos;  response = requests.get(url)</span><br><span class="line">    print(url,response)</span><br><span class="line"></span><br><span class="line">def done(future,*args,**kwargs):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"> 请求成功之后，执行的回调函数，处理一些东西 与编写方式一来说，降低了耦合度  :param future:  :param args:  :param kwargs:  :return:</span><br><span class="line"> &apos;&apos;&apos;  print(future,args,kwargs)</span><br><span class="line">    print(future.result,args,kwargs)</span><br><span class="line">    response = future.result()</span><br><span class="line">    print(response.status_code,response.content)</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(7)</span><br><span class="line">url_list = [</span><br><span class="line">    &apos;https://www.baidu.com/&apos;,</span><br><span class="line">    &apos;https://www.sina.com/&apos;,</span><br><span class="line">    &apos;https://www.zhihu.com/&apos;,</span><br><span class="line">    &apos;https://www.autohome.com/&apos;,</span><br><span class="line">    &apos;https://www.bing.com/&apos;,</span><br><span class="line">    &apos;https://www.csdn.net/&apos;,</span><br><span class="line">    &apos;https://www.oschina.net/&apos;,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for url in url_list:</span><br><span class="line">    v= pool.submit(task,url)</span><br><span class="line">    # 执行回调函数，可以有多个回调</span><br><span class="line">  v.add_done_callback(done)</span><br><span class="line"></span><br><span class="line">pool.shutdown(wait=True)</span><br></pre></td></tr></table></figure><h3 id="多进程实现并发"><a href="#多进程实现并发" class="headerlink" title="多进程实现并发"></a>多进程实现并发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">可以实现并发</span><br><span class="line">但是，请求发送出去和返回之前，中间时期线程空闲</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">########### 编写方式一################</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def task(url):</span><br><span class="line"> response = requests.get(url) print(url,response) # 处理返回值 # 写正则</span><br><span class="line"></span><br><span class="line">pool = ProcessPoolExecutor(7)</span><br><span class="line">url_list = [</span><br><span class="line"> &apos;https://www.baidu.com/&apos;, &apos;https://www.sina.com/&apos;, &apos;https://www.zhihu.com/&apos;, &apos;https://www.autohome.com/&apos;, &apos;https://www.bing.com/&apos;, &apos;https://www.csdn.net/&apos;, &apos;https://www.oschina.net/&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for url in url_list:</span><br><span class="line"> pool.submit(task,url) pool.shutdown(wait=True)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">########### 编写方式二  回调函数################</span><br><span class="line"></span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def task(url):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"> 只下载页面  :param url:  :return:</span><br><span class="line"> &apos;&apos;&apos;  response = requests.get(url)</span><br><span class="line">    print(url,response)</span><br><span class="line"></span><br><span class="line">def done(future,*args,**kwargs):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"> 请求成功之后，执行的回调函数，处理一些东西 与编写方式一来说，降低了耦合度  :param future:  :param args:  :param kwargs:  :return:</span><br><span class="line"> &apos;&apos;&apos;  print(future,args,kwargs)</span><br><span class="line">    print(future.result,args,kwargs)</span><br><span class="line">    response = future.result()</span><br><span class="line">    print(response.status_code,response.content)</span><br><span class="line"></span><br><span class="line">pool = ProcessPoolExecutor(7)</span><br><span class="line">url_list = [</span><br><span class="line">    &apos;https://www.baidu.com/&apos;,</span><br><span class="line">    &apos;https://www.sina.com/&apos;,</span><br><span class="line">    &apos;https://www.zhihu.com/&apos;,</span><br><span class="line">    &apos;https://www.autohome.com/&apos;,</span><br><span class="line">    &apos;https://www.bing.com/&apos;,</span><br><span class="line">    &apos;https://www.csdn.net/&apos;,</span><br><span class="line">    &apos;https://www.oschina.net/&apos;,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for url in url_list:</span><br><span class="line">    v= pool.submit(task,url)</span><br><span class="line">    # 执行回调函数，可以有多个回调</span><br><span class="line">  v.add_done_callback(done)</span><br><span class="line"></span><br><span class="line">pool.shutdown(wait=True)</span><br></pre></td></tr></table></figure><blockquote><h1 id="多线程和多进程的区别"><a href="#多线程和多进程的区别" class="headerlink" title="多线程和多进程的区别"></a>多线程和多进程的区别</h1></blockquote><ul><li><p>多线程 IO密集型，不用通过cpu</p></li><li><p>多进程 计算密集型</p><p><a href="https://yuansuixin.github.io/2018/04/14/thread-process/" title="区别">详细的区别和联系讲解</a></p></li></ul><blockquote><h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1></blockquote><h3 id="协程（微线程）"><a href="#协程（微线程）" class="headerlink" title="协程（微线程）"></a>协程（微线程）</h3><pre><code>- 协程能完成切换，什么时候切换得需要咱们自己设- 加上http请求的话，就是请求回来之后切换- 加上异步IO的功能就等同于一个线程发送N个http请求，asyncio可以帮助我们完成这个操作</code></pre><blockquote><h1 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h1></blockquote><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><pre><code>- 使用socket实现​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client = socket()</span><br><span class="line">client.connect(...)</span><br><span class="line">client.send(b&apos;ffdsafdsa&apos;)</span><br><span class="line">​</span><br></pre></td></tr></table></figure></code></pre><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><pre><code>- HTTP是基于TCP做的- 也是使用socket实现​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#http是基于tcp的，只不过发送的数据不一样，http有固定的数据格式</span><br><span class="line">data = &quot;GET %s HTTP/1.0\r\nHost: %s\r\n\r\n&quot;</span><br><span class="line">client = socket()</span><br><span class="line">client.connect(...)</span><br><span class="line">client.send(data)</span><br><span class="line">​</span><br></pre></td></tr></table></figure></code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><blockquote><h4 id="角色-：使用者"><a href="#角色-：使用者" class="headerlink" title="角色 ：使用者"></a>角色 ：使用者</h4></blockquote></blockquote><ul><li>asyncio.sleep(5) 等待</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'before ....task'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 发送http请求，但是asyncio只支持TCP获取结果，那么我们就需要自己弄成http请求</span></span><br><span class="line">    print(<span class="string">'end ....task'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [task(),task()]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><ul><li>自己封装Http数据包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">###自己封装http的数据包</span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def task(host, url=&apos;/&apos;):</span><br><span class="line">    print(host, url)</span><br><span class="line">    # 创建链接</span><br><span class="line">    reader, writer = yield from asyncio.open_connection(host, 80)</span><br><span class="line"></span><br><span class="line">    # http请求的格式</span><br><span class="line">    request_header_content = &quot;&quot;&quot;GET %s HTTP/1.0\r\nHost: %s\r\n\r\n&quot;&quot;&quot; % (url, host,)</span><br><span class="line">    request_header_content = bytes(request_header_content, encoding=&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">    writer.write(request_header_content)</span><br><span class="line">    yield from writer.drain()</span><br><span class="line">    text = yield from reader.read()</span><br><span class="line">    print(host, url, text)</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    task(&apos;www.cnblogs.com&apos;, &apos;/wupeiqi/&apos;),</span><br><span class="line">    task(&apos;dig.chouti.com&apos;, &apos;/pic/show?nid=4073644713430508&amp;lid=10273091&apos;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results = loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><ul><li>aiohttp模块，封装了Http数据包，这个包需要下载，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import aiohttp</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def fetch_async(url):</span><br><span class="line">    print(url)</span><br><span class="line">    response = yield from aiohttp.request(&apos;GET&apos;, url)</span><br><span class="line">    # data = yield from response.read()</span><br><span class="line">    # print(url, data)</span><br><span class="line">    print(url, response)</span><br><span class="line">    response.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [fetch_async(&apos;http://www.baidu.com/&apos;), fetch_async(&apos;http://www.chouti.com/&apos;)]</span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line">results = event_loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">event_loop.close()</span><br></pre></td></tr></table></figure><ul><li>requests模块，封装了Http数据包，也是需要下载的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def task(func, *args):</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    future = loop.run_in_executor(None, func, *args)</span><br><span class="line">    response = yield from future</span><br><span class="line">    print(response.url, response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    task(requests.get, &apos;http://www.cnblogs.com/wupeiqi/&apos;),</span><br><span class="line">    task(requests.get, &apos;http://dig.chouti.com/pic/show?nid=4073644713430508&amp;lid=10273091&apos;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results = loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><blockquote><h1 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h1></blockquote><ul><li>和asyncio的本质原理一致，实现方式不同，依赖了协程的greenlet模块，和异步IO的结合</li><li><p>需要安装greenlet，gevent</p></li><li><p>gevent+requests模块</p></li><li>gevent(协程池，最多发多少个请求)+requests模块 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">from gevent import monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fetch_async(method, url, req_kwargs):</span><br><span class="line">    print(method, url, req_kwargs)</span><br><span class="line">    response = requests.request(method=method, url=url, **req_kwargs)</span><br><span class="line">    print(response.url, response.content)</span><br><span class="line"></span><br><span class="line"># ##### 发送请求 #####</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fetch_async, method=&apos;get&apos;, url=&apos;https://www.python.org/&apos;, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=&apos;get&apos;, url=&apos;https://www.yahoo.com/&apos;, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=&apos;get&apos;, url=&apos;https://github.com/&apos;, req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># ##### 发送请求（协程池控制最大协程数量） #####</span><br><span class="line"># from gevent.pool import Pool</span><br><span class="line"># pool = Pool(None)</span><br><span class="line"># gevent.joinall([</span><br><span class="line">#     pool.spawn(fetch_async, method=&apos;get&apos;, url=&apos;https://www.python.org/&apos;, req_kwargs=&#123;&#125;),</span><br><span class="line">#     pool.spawn(fetch_async, method=&apos;get&apos;, url=&apos;https://www.yahoo.com/&apos;, req_kwargs=&#123;&#125;),</span><br><span class="line">#     pool.spawn(fetch_async, method=&apos;get&apos;, url=&apos;https://www.github.com/&apos;, req_kwargs=&#123;&#125;),</span><br><span class="line"># ])</span><br></pre></td></tr></table></figure><ul><li>gevent+requests==》 grequests 模块，需要下载，其实原理就是gevent和requests的原理，只不过做了个封装而已</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import grequests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">request_list = [</span><br><span class="line">    grequests.get(&apos;http://httpbin.org/delay/1&apos;, timeout=0.001),</span><br><span class="line">    grequests.get(&apos;http://fakedomain/&apos;),</span><br><span class="line">    grequests.get(&apos;http://httpbin.org/status/500&apos;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 执行并获取响应列表 #####</span><br><span class="line"># response_list = grequests.map(request_list)</span><br><span class="line"># print(response_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##### 执行并获取响应列表（处理异常） #####</span><br><span class="line"># def exception_handler(request, exception):</span><br><span class="line"># print(request,exception)</span><br><span class="line">#     print(&quot;Request failed&quot;)</span><br><span class="line"></span><br><span class="line"># response_list = grequests.map(request_list, exception_handler=exception_handler)</span><br><span class="line"># print(response_list)</span><br></pre></td></tr></table></figure><blockquote><h1 id="Twisted"><a href="#Twisted" class="headerlink" title="Twisted"></a>Twisted</h1></blockquote><ul><li>scarpy框架底层使用的Twisted实现的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from twisted.internet import defer</span><br><span class="line">from twisted.web.client import getPage</span><br><span class="line">from twisted.internet import reactor</span><br><span class="line"></span><br><span class="line">def one_done(arg):</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">def all_done(arg):</span><br><span class="line">    print(&apos;done&apos;)</span><br><span class="line">    reactor.stop()</span><br><span class="line"></span><br><span class="line">@defer.inlineCallbacks</span><br><span class="line">def task(url):</span><br><span class="line">    res = getPage(bytes(url, encoding=&apos;utf8&apos;)) # 发送Http请求</span><br><span class="line">    res.addCallback(one_done)</span><br><span class="line">    yield res</span><br><span class="line"></span><br><span class="line">url_list = [</span><br><span class="line">    &apos;http://www.cnblogs.com&apos;,</span><br><span class="line">    &apos;http://www.cnblogs.com&apos;,</span><br><span class="line">    &apos;http://www.cnblogs.com&apos;,</span><br><span class="line">    &apos;http://www.cnblogs.com&apos;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">defer_list = [] # [特殊，特殊，特殊(已经向url发送请求)],都是defer对象</span><br><span class="line">## 对URl进行循环，拿到一个url就执行task任务，发送Http请求，发完请求就返回，已经向url发送完请求的特殊对象</span><br><span class="line"># 将这些特殊对象添加到defer_list列表中，将这个列表传入DeferredList对象中，那么这些特殊的对象就成了defer对象，</span><br><span class="line"># 这些请求每返回一个请求就会执行一次one_done方法，同时reactor.run()死循环一直在检测是否所有请求都返回了，这里做了请求返回数量统计，如果所有的请求都返回了，</span><br><span class="line"># #执行all_done方法，将reactor死循环结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for url in url_list:</span><br><span class="line">    v = task(url)</span><br><span class="line">    defer_list.append(v)</span><br><span class="line"></span><br><span class="line">d = defer.DeferredList(defer_list)</span><br><span class="line">d.addBoth(all_done)</span><br><span class="line">reactor.run() # 死循环</span><br></pre></td></tr></table></figure><blockquote><h1 id="tonado"><a href="#tonado" class="headerlink" title="tonado"></a>tonado</h1></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line">from tornado.httpclient import HTTPRequest</span><br><span class="line">from tornado import ioloop</span><br><span class="line"></span><br><span class="line">COUNT = 0</span><br><span class="line">def handle_response(response):</span><br><span class="line">    global COUNT</span><br><span class="line">    COUNT -= 1</span><br><span class="line">    if response.error:</span><br><span class="line">        print(&quot;Error:&quot;, response.error)</span><br><span class="line">    else:</span><br><span class="line">        print(response.body)</span><br><span class="line">        # 方法同twisted</span><br><span class="line">        # ioloop.IOLoop.current().stop()</span><br><span class="line">    if COUNT == 0:</span><br><span class="line">        ioloop.IOLoop.current().stop()</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    url_list = [</span><br><span class="line">        &apos;http://www.baidu.com&apos;,</span><br><span class="line">        &apos;http://www.bing.com&apos;,</span><br><span class="line">    ]</span><br><span class="line">    global COUNT</span><br><span class="line">    COUNT = len(url_list)</span><br><span class="line">    for url in url_list:</span><br><span class="line">        print(url)</span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        http_client.fetch(HTTPRequest(url), handle_response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ioloop.IOLoop.current().add_callback(func)</span><br><span class="line">ioloop.IOLoop.current().start() # 死循环</span><br></pre></td></tr></table></figure><h4 id="使用哪个最好呢，一般都是直接使用的框架，人家已经帮我们封装好了，如果是需要自己写，-》gevent-gt-Twisted-gt-Tornado-gt-asyncio"><a href="#使用哪个最好呢，一般都是直接使用的框架，人家已经帮我们封装好了，如果是需要自己写，-》gevent-gt-Twisted-gt-Tornado-gt-asyncio" class="headerlink" title="使用哪个最好呢，一般都是直接使用的框架，人家已经帮我们封装好了，如果是需要自己写，=======》gevent &gt;  Twisted  &gt;   Tornado  &gt; asyncio"></a>使用哪个最好呢，一般都是直接使用的框架，人家已经帮我们封装好了，如果是需要自己写，=======》gevent &gt;  Twisted  &gt;   Tornado  &gt; asyncio</h4><p>以上均是Python内置以及第三方模块提供异步IO请求模块，使用简便大大提高效率，而对于异步IO请求的本质则是【非阻塞Socket】+【IO多路复用】</p><blockquote><blockquote><h4 id="角色：-NB开发者"><a href="#角色：-NB开发者" class="headerlink" title="角色： NB开发者"></a>角色： NB开发者</h4></blockquote></blockquote><h3 id="学习自定义异步IO框架必备知识点"><a href="#学习自定义异步IO框架必备知识点" class="headerlink" title="学习自定义异步IO框架必备知识点"></a>学习自定义异步IO框架必备知识点</h3><h6 id="1-socket客户端，服务端"><a href="#1-socket客户端，服务端" class="headerlink" title="1. socket客户端，服务端"></a>1. socket客户端，服务端</h6><pre><code>- 连接是阻塞的，receive也会阻塞- setblocking(0)的话连接就不会阻塞了，无数据（连接无响应，数据未返回）就报错- 不管阻塞或者是非阻塞，连接都会发到远程，阻塞的话就会等，等着连接回来</code></pre><h6 id="2-IO多路复用"><a href="#2-IO多路复用" class="headerlink" title="2. IO多路复用"></a>2. IO多路复用</h6><pre><code>- 客户端</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">   socket对象1.connet（）</span><br><span class="line">   socket对象2.connet（）</span><br><span class="line">   socket对象3.connet（）</span><br><span class="line">except EX...</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line"># 监听对象</span><br><span class="line">    r,w,e = select.select([socket对象，socket对象。。。],[socket对象，socket对象。。。],[],0.05)</span><br><span class="line">    e 表示多路复用发生异常，错误就会放到e里面</span><br><span class="line">    # 表示有人给我发送数据</span><br><span class="line">    r = [socket对象1，]</span><br><span class="line">       xx = socket对象1.recv()</span><br><span class="line">    # 表示我已经和别人创建链接成功</span><br><span class="line">    w = [socket对象1，]</span><br><span class="line">        socket对象1.send(&apos;GET %s HTTP/1.0\r\nHost: %s\r\n\r\n&apos;)</span><br></pre></td></tr></table></figure><h6 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h6><ul><li>select.select监听对象的内部并不是只能有socket对象，但是必须有，fileno方法，并且返回一个文件描述符<ul><li>select内部：对象.fileno()</li><li>Foo（）内部封装socket文件描述符</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def fileno(self):</span><br><span class="line">        obj = socket()</span><br><span class="line">        return obj.fileno()</span><br><span class="line"></span><br><span class="line">#这个对象必须有：fileno方法，并返回一个文件描述符</span><br><span class="line">    r,w,e = select.select([对象，对象。。。],[对象，对象。。。],[],0.05)</span><br></pre></td></tr></table></figure><h3 id="自定义异步IO框架"><a href="#自定义异步IO框架" class="headerlink" title="自定义异步IO框架"></a>自定义异步IO框架</h3><ul><li>Http请求的本质，阻塞的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">####################HTTP请求本质，阻塞的#######################</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line"># 1.链接</span><br><span class="line">sk.connect((&apos;www.baidu.com&apos;,80,)) # 阻塞</span><br><span class="line">print(&apos;连接成功了。。。&apos;)</span><br><span class="line"></span><br><span class="line"># 2，链接成功后发送消息</span><br><span class="line">sk.send(b&apos;GET / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\n&apos;)</span><br><span class="line"># sk.send(b&apos;POST / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\nk1=v1&amp;k2=v2&apos;)</span><br><span class="line"># 3，等待着服务端响应</span><br><span class="line">data = sk.recv(8096)  # 阻塞</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"># 关闭链接</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><ul><li>Http请求本质，非阻塞的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sk = socket.socket()</span><br><span class="line">sk.setblocking(False)</span><br><span class="line"># 1.链接</span><br><span class="line">try:</span><br><span class="line">    sk.connect((&apos;www.baidu.com&apos;,80,)) # 阻塞</span><br><span class="line">    print(&apos;连接成功了。。。&apos;)</span><br><span class="line">except BlockingIOError as e:</span><br><span class="line">    print(e)</span><br><span class="line"># 发送数据就需要连接成功后发送，需要检测着sk是否连接成功，然而这种方法就不好了，那么下面的方法就产生了</span><br><span class="line"># 2，链接成功后发送消息</span><br><span class="line">sk.send(b&apos;GET / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\n&apos;)</span><br><span class="line"># sk.send(b&apos;POST / HTTP/1.0\r\nHost:www.baidu.com\r\n\r\nk1=v1&amp;k2=v2&apos;)</span><br><span class="line"># 3，等待着服务端响应</span><br><span class="line">data = sk.recv(8096)  # 阻塞</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"># 关闭链接</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><ul><li>非阻塞异步IO框架</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Socket客户端的本质</span><br><span class="line"># ### 所有的框架分割请求头和请求体的时候都是使用的split方法</span><br><span class="line"></span><br><span class="line">### 封装socket和主机名</span><br><span class="line">class HttpRequest:</span><br><span class="line">    def __init__(self,sk,host,callback):</span><br><span class="line">        self.socket = sk</span><br><span class="line">        self.host = host</span><br><span class="line">        self.callback = callback</span><br><span class="line"></span><br><span class="line">    def fileno(self):</span><br><span class="line">        return self.socket.fileno()</span><br><span class="line"></span><br><span class="line">class HttpResponse:</span><br><span class="line">    def __init__(self,recv_data):</span><br><span class="line">        self.recv_data = recv_data</span><br><span class="line">        self.header_dict = &#123;&#125;</span><br><span class="line">        self.body= None</span><br><span class="line">        self.initialize()</span><br><span class="line"></span><br><span class="line">    def initialize(self):</span><br><span class="line">        # 将请求头和请求题分割</span><br><span class="line">        headers, body = self.recv_data.split(b&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">        self.body = body</span><br><span class="line">        headers_list = headers.split(b&apos;\r\n&apos;)</span><br><span class="line">        for h in headers_list:</span><br><span class="line">            h_str = str(h,encoding=&apos;utf-8&apos;)</span><br><span class="line">            v = h_str.split(&apos;:&apos;,1)</span><br><span class="line">            if len(v) ==2:</span><br><span class="line">                self.header_dict[v[0]] = v[1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AsyncRequest:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.conn = []</span><br><span class="line">        self.connection = [] # 用于检测是否已经连接成功，有谁，谁就还没有连接成功呢</span><br><span class="line"></span><br><span class="line">    def add_request(self,host,callback):</span><br><span class="line">        try:</span><br><span class="line">            sk = socket.socket()</span><br><span class="line">            # 将其变成非阻塞的</span><br><span class="line">            sk.setblocking(0)</span><br><span class="line">            sk.connect((host,80,))</span><br><span class="line">        except BlockingIOError as e:</span><br><span class="line">            pass</span><br><span class="line">        request = HttpRequest(sk,host,callback)</span><br><span class="line">        self.conn.append(request)</span><br><span class="line">        self.connection.append(request)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        # 事件循环</span><br><span class="line">        while True:</span><br><span class="line">            # IO的多路复用</span><br><span class="line">            rlist,wlist,elist = select.select(self.conn,self.connection,self.conn,0.05)</span><br><span class="line">            #每一个w表示一个HttpRequest对象</span><br><span class="line">            for w in wlist:</span><br><span class="line">                print(w.host,&apos;连接成功&apos;)</span><br><span class="line">                # 只要能循环到，表示socket和服务器端已经连接成功</span><br><span class="line">                tp1 = &quot;GET / HTTP/1.0\r\nHost:%s\r\n\r\n&quot;%(w.host)</span><br><span class="line">                w.socket.send(bytes(tp1,encoding=&apos;utf-8&apos;))</span><br><span class="line">                # 连接只连接一次，成功之后删掉就可以了</span><br><span class="line">                self.connection.remove(w)</span><br><span class="line"></span><br><span class="line">            # 接收的数据</span><br><span class="line">            for r in rlist:</span><br><span class="line">                print(r.host, &apos;有数据返回&apos;)</span><br><span class="line">                # r是HttpRequest对象</span><br><span class="line">                #  如果有数据就去接收</span><br><span class="line">                recv_data = bytes()</span><br><span class="line">                while True:</span><br><span class="line">                    try:</span><br><span class="line">                        chunk = r.socket.recv(8096)</span><br><span class="line">                        recv_data += chunk</span><br><span class="line">                    except Exception as e:</span><br><span class="line">                        break</span><br><span class="line">                response = HttpResponse(recv_data)</span><br><span class="line">                # 真正用户返回过来的数据</span><br><span class="line">                print(r.host,&apos;返回的数据&apos;,recv_data)</span><br><span class="line">                # 对返回的数据进行处理，执行相对应的回调函数</span><br><span class="line">                r.callback(response)</span><br><span class="line">                r.socket.close()</span><br><span class="line">                self.conn.remove(r)</span><br><span class="line"></span><br><span class="line">            if len(self.conn) == 0:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">def f1(response):</span><br><span class="line">    print(&apos;保存文件&apos;,response.header_dict)</span><br><span class="line">def f2(response):</span><br><span class="line">    print(&apos;保存文件到数据库&apos;, response.header_dict)</span><br><span class="line"></span><br><span class="line"># 字典格式，每个url对应着他的回调函数</span><br><span class="line">url_list = [</span><br><span class="line">    &#123;&apos;host&apos;:&apos;www.baidu.com&apos;,&apos;callback&apos;:f1&#125;,</span><br><span class="line">    &#123;&apos;host&apos;:&apos;cn.bing.com&apos;,&apos;callback&apos;:f2&#125;,</span><br><span class="line">    &#123;&apos;host&apos;:&apos;www.enblogs.com&apos;,&apos;callback&apos;:f2&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">req = AsyncRequest()</span><br><span class="line">for item in url_list:</span><br><span class="line">    req.add_request(item[&apos;host&apos;],item[&apos;callback&apos;])</span><br><span class="line">req.run()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/yuansuixin/IO-Asynchronous" title="源码下载" target="_blank" rel="noopener">以上所有源码下载</a></p><ul><li>什么是异步IO<ul><li>异步IO是相对来说的，如果有人来用的话，只需要给url和回调函数就可以，请求完成之后，会自动调用回调函数，对于使用的人来说就是异步，其实就是回调</li><li>对于开发者来说，就不是异步的</li><li>select仅仅是IO多路复用，只能同时监听多个对象，他自己完成不了，不能实现异步，只能监听对象，谁又变化就记录下来，利用其特性可以开发出异步IO模块</li><li>异步IO  （非阻塞的socket+IO多路复用就可以开发出）<ul><li>异步的IO请求，当有多个请求的时候，可以做多个事情，而不是一直等着，请求返回时自动调用回调函数<br>-（单个线程伪造了好多请求发过去，多并发）</li><li>socket非阻塞</li><li>select监听的时候，可以封装成自己的对象</li></ul></li></ul></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>机器学习算法剖析----KNN近邻算法</title>
      <link href="/2018/04/13/KNN/"/>
      <url>/2018/04/13/KNN/</url>
      <content type="html"><![CDATA[<h1 id="K-近邻算法（KNN）"><a href="#K-近邻算法（KNN）" class="headerlink" title="K-近邻算法（KNN）"></a>K-近邻算法（KNN）</h1><p>K nearest neighbour</p><ul><li>说明：本文采用的是jupyter-notebook环境，我直接贴的IPython代码，小伙伴们要到jypyter-notebook上运行哟！:smile:</li><li>案例下载<a href="https://github.com/yuansuixin/k-Nearest-Neighbor" title="案例" target="_blank" rel="noopener">案例</a></li></ul><h2 id="0、导引"><a href="#0、导引" class="headerlink" title="0、导引"></a>0、导引</h2><h3 id="如何进行电影分类"><a href="#如何进行电影分类" class="headerlink" title="如何进行电影分类"></a>如何进行电影分类</h3><p>众所周知，电影可以按照题材分类，然而题材本身是如何定义的?由谁来判定某部电影属于哪<br>个题材?也就是说同一题材的电影具有哪些公共特征?这些都是在进行电影分类时必须要考虑的问<br>题。没有哪个电影人会说自己制作的电影和以前的某部电影类似，但我们确实知道每部电影在风格<br>上的确有可能会和同题材的电影相近。那么动作片具有哪些共有特征，使得动作片之间非常类似，<br>而与爱情片存在着明显的差别呢？动作片中也会存在接吻镜头，爱情片中也会存在打斗场景，我们<br>不能单纯依靠是否存在打斗或者亲吻来判断影片的类型。但是爱情片中的亲吻镜头更多，动作片中<br>的打斗场景也更频繁，基于此类场景在某部电影中出现的次数可以用来进行电影分类。</p><p>本章介绍第一个机器学习算法：K-近邻算法，它非常有效而且易于掌握。</p><h2 id="1、k-近邻算法原理"><a href="#1、k-近邻算法原理" class="headerlink" title="1、k-近邻算法原理"></a>1、k-近邻算法原理</h2><p>简单地说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。</p><ul><li>优点：精度高、对异常值不敏感、无数据输入假定。</li><li>缺点：时间复杂度高、空间复杂度高。</li><li>适用数据范围：数值型和标称型。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据<br>与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的<br>特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们<br>只选择样本数据集中前K个最相似的数据，这就是K-近邻算法中K的出处,通常<em>K是不大于20的整数。<br>最后 ，选择K个最相似数据中出现次数最多的分类，作为新数据的分类</em>。</p><p>回到前面电影分类的例子，使用K-近邻算法分类爱情片和动作片。有人曾经统计过很多电影的打斗镜头和接吻镜头，下图显示了6部电影的打斗和接吻次数。假如有一部未看过的电影，如何确定它是爱情片还是动作片呢？我们可以使用K-近邻算法来解决这个问题。</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192352.PNG" alt="Untitled-1-2018413192352"></p><p>首先我们需要知道这个未知电影存在多少个打斗镜头和接吻镜头，上图中问号位置是该未知电影出现的镜头数图形化展示，具体数字参见下表。<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841319243.PNG" alt="Untitled-1-201841319243"></p><p>即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先计算未知电影与样本集中其他电影的距离，如图所示。</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192410.PNG" alt="Untitled-1-2018413192410"></p><p>现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到K个距<br>离最近的电影。假定k=3，则三个最靠近的电影依次是California Man、He’s Not Really into Dudes、Beautiful Woman。K-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。</p><h3 id="欧几里得距离-Euclidean-Distance"><a href="#欧几里得距离-Euclidean-Distance" class="headerlink" title="欧几里得距离(Euclidean Distance)"></a>欧几里得距离(Euclidean Distance)</h3><p>欧氏距离是最常见的距离度量，衡量的是多维空间中各个点之间的绝对距离。公式如下：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192416.png" alt="Untitled-1-2018413192416"></p><h2 id="2、在scikit-learn库中使用k-近邻算法"><a href="#2、在scikit-learn库中使用k-近邻算法" class="headerlink" title="2、在scikit-learn库中使用k-近邻算法"></a>2、在scikit-learn库中使用k-近邻算法</h2><ul><li><p>分类问题：from sklearn.neighbors import KNeighborsClassifier</p></li><li><p>回归问题：from sklearn.neighbors import KNeighborsRegressor</p></li></ul><h3 id="0）一个最简单的例子"><a href="#0）一个最简单的例子" class="headerlink" title="0）一个最简单的例子"></a>0）一个最简单的例子</h3><p>身高、体重、鞋子尺码数据对应性别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理分类问题</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment"># 处理回归问题</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建KNN分类器对象</span></span><br><span class="line"><span class="comment"># n_neighbors应设置为一个奇数，表示距离预测样本最近的n个样本点</span></span><br><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X_train必须是一个列向量（二维数组）</span></span><br><span class="line">X_train = np.array([[<span class="number">19</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">18</span>],[<span class="number">25</span>,<span class="number">1</span>],[<span class="number">24</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">17</span>]])</span><br><span class="line">y_train = np.array([<span class="string">'动作'</span>,<span class="string">'爱情'</span>,<span class="string">'动作'</span>,<span class="string">'动作'</span>,<span class="string">'爱情'</span>])</span><br><span class="line">display(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>array([[19,  1],       [ 2, 18],       [25,  1],       [24,  3],       [ 3, 17]])array([&apos;动作&apos;, &apos;爱情&apos;, &apos;动作&apos;, &apos;动作&apos;, &apos;爱情&apos;], dtype=&apos;&lt;U2&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练分类器模型</span></span><br><span class="line">knnclf.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=3, p=2,           weights=&apos;uniform&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_test = np.array([[<span class="number">13</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">10</span>]])</span><br><span class="line">knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>array([&apos;动作&apos;, &apos;爱情&apos;], dtype=&apos;&lt;U2&apos;)</code></pre><h3 id="1）用于分类"><a href="#1）用于分类" class="headerlink" title="1）用于分类"></a>1）用于分类</h3><p>导包，机器学习的算法KNN、数据鸢尾花</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load_iris是机器学习库提供给我们研究算法的数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br></pre></td></tr></table></figure><p>获取训练样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">iris</span><br></pre></td></tr></table></figure><pre><code>{&apos;DESCR&apos;: &apos;Iris Plants Database\n====================\n\nNotes\n-----\nData Set Characteristics:\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20  0.76     0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThis is a copy of UCI ML iris datasets.\nhttp://archive.ics.uci.edu/ml/datasets/Iris\n\nThe famous Iris database, first used by Sir R.A Fisher\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher\&apos;s paper is a classic in the field and\nis referenced frequently to this day.  (See Duda &amp; Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\nReferences\n----------\n   - Fisher,R.A. &quot;The use of multiple measurements in taxonomic problems&quot;\n     Annual Eugenics, 7, Part II, 179-188 (1936); also in &quot;Contributions to\n     Mathematical Statistics&quot; (John Wiley, NY, 1950).\n   - Duda,R.O., &amp; Hart,P.E. (1973) Pattern Classification and Scene Analysis.\n     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.\n   - Dasarathy, B.V. (1980) &quot;Nosing Around the Neighborhood: A New System\n     Structure and Classification Rule for Recognition in Partially Exposed\n     Environments&quot;.  IEEE Transactions on Pattern Analysis and Machine\n     Intelligence, Vol. PAMI-2, No. 1, 67-71.\n   - Gates, G.W. (1972) &quot;The Reduced Nearest Neighbor Rule&quot;.  IEEE Transactions\n     on Information Theory, May 1972, 431-433.\n   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&quot;s AUTOCLASS II\n     conceptual clustering system finds 3 classes in the data.\n   - Many, many more ...\n&apos;, &apos;data&apos;: array([[5.1, 3.5, 1.4, 0.2],        [4.9, 3. , 1.4, 0.2],        [4.7, 3.2, 1.3, 0.2],        [4.6, 3.1, 1.5, 0.2],        [5. , 3.6, 1.4, 0.2],        [5.4, 3.9, 1.7, 0.4],        [4.6, 3.4, 1.4, 0.3],        [5. , 3.4, 1.5, 0.2],        [4.4, 2.9, 1.4, 0.2],        [4.9, 3.1, 1.5, 0.1],        [5.4, 3.7, 1.5, 0.2],        [4.8, 3.4, 1.6, 0.2],        [4.8, 3. , 1.4, 0.1],        [4.3, 3. , 1.1, 0.1],        [5.8, 4. , 1.2, 0.2],        [5.7, 4.4, 1.5, 0.4],        [5.4, 3.9, 1.3, 0.4],        [5.1, 3.5, 1.4, 0.3],        [5.7, 3.8, 1.7, 0.3],        [5.1, 3.8, 1.5, 0.3],        [5.4, 3.4, 1.7, 0.2],        [5.1, 3.7, 1.5, 0.4],        [4.6, 3.6, 1. , 0.2],        [5.1, 3.3, 1.7, 0.5],        [4.8, 3.4, 1.9, 0.2],        [5. , 3. , 1.6, 0.2],        [5. , 3.4, 1.6, 0.4],        [5.2, 3.5, 1.5, 0.2],        [5.2, 3.4, 1.4, 0.2],        [4.7, 3.2, 1.6, 0.2],        [4.8, 3.1, 1.6, 0.2],        [5.4, 3.4, 1.5, 0.4],        [5.2, 4.1, 1.5, 0.1],        [5.5, 4.2, 1.4, 0.2],        [4.9, 3.1, 1.5, 0.1],        [5. , 3.2, 1.2, 0.2],        [5.5, 3.5, 1.3, 0.2],        [4.9, 3.1, 1.5, 0.1],        [4.4, 3. , 1.3, 0.2],        [5.1, 3.4, 1.5, 0.2],        [5. , 3.5, 1.3, 0.3],        [4.5, 2.3, 1.3, 0.3],        [4.4, 3.2, 1.3, 0.2],        [5. , 3.5, 1.6, 0.6],        [5.1, 3.8, 1.9, 0.4],        [4.8, 3. , 1.4, 0.3],        [5.1, 3.8, 1.6, 0.2],        [4.6, 3.2, 1.4, 0.2],        [5.3, 3.7, 1.5, 0.2],        [5. , 3.3, 1.4, 0.2],        [7. , 3.2, 4.7, 1.4],        [6.4, 3.2, 4.5, 1.5],        [6.9, 3.1, 4.9, 1.5],        [5.5, 2.3, 4. , 1.3],        [6.5, 2.8, 4.6, 1.5],        [5.7, 2.8, 4.5, 1.3],        [6.3, 3.3, 4.7, 1.6],        [4.9, 2.4, 3.3, 1. ],        [6.6, 2.9, 4.6, 1.3],        [5.2, 2.7, 3.9, 1.4],        [5. , 2. , 3.5, 1. ],        [5.9, 3. , 4.2, 1.5],        [6. , 2.2, 4. , 1. ],        [6.1, 2.9, 4.7, 1.4],        [5.6, 2.9, 3.6, 1.3],        [6.7, 3.1, 4.4, 1.4],        [5.6, 3. , 4.5, 1.5],        [5.8, 2.7, 4.1, 1. ],        [6.2, 2.2, 4.5, 1.5],        [5.6, 2.5, 3.9, 1.1],        [5.9, 3.2, 4.8, 1.8],        [6.1, 2.8, 4. , 1.3],        [6.3, 2.5, 4.9, 1.5],        [6.1, 2.8, 4.7, 1.2],        [6.4, 2.9, 4.3, 1.3],        [6.6, 3. , 4.4, 1.4],        [6.8, 2.8, 4.8, 1.4],        [6.7, 3. , 5. , 1.7],        [6. , 2.9, 4.5, 1.5],        [5.7, 2.6, 3.5, 1. ],        [5.5, 2.4, 3.8, 1.1],        [5.5, 2.4, 3.7, 1. ],        [5.8, 2.7, 3.9, 1.2],        [6. , 2.7, 5.1, 1.6],        [5.4, 3. , 4.5, 1.5],        [6. , 3.4, 4.5, 1.6],        [6.7, 3.1, 4.7, 1.5],        [6.3, 2.3, 4.4, 1.3],        [5.6, 3. , 4.1, 1.3],        [5.5, 2.5, 4. , 1.3],        [5.5, 2.6, 4.4, 1.2],        [6.1, 3. , 4.6, 1.4],        [5.8, 2.6, 4. , 1.2],        [5. , 2.3, 3.3, 1. ],        [5.6, 2.7, 4.2, 1.3],        [5.7, 3. , 4.2, 1.2],        [5.7, 2.9, 4.2, 1.3],        [6.2, 2.9, 4.3, 1.3],        [5.1, 2.5, 3. , 1.1],        [5.7, 2.8, 4.1, 1.3],        [6.3, 3.3, 6. , 2.5],        [5.8, 2.7, 5.1, 1.9],        [7.1, 3. , 5.9, 2.1],        [6.3, 2.9, 5.6, 1.8],        [6.5, 3. , 5.8, 2.2],        [7.6, 3. , 6.6, 2.1],        [4.9, 2.5, 4.5, 1.7],        [7.3, 2.9, 6.3, 1.8],        [6.7, 2.5, 5.8, 1.8],        [7.2, 3.6, 6.1, 2.5],        [6.5, 3.2, 5.1, 2. ],        [6.4, 2.7, 5.3, 1.9],        [6.8, 3. , 5.5, 2.1],        [5.7, 2.5, 5. , 2. ],        [5.8, 2.8, 5.1, 2.4],        [6.4, 3.2, 5.3, 2.3],        [6.5, 3. , 5.5, 1.8],        [7.7, 3.8, 6.7, 2.2],        [7.7, 2.6, 6.9, 2.3],        [6. , 2.2, 5. , 1.5],        [6.9, 3.2, 5.7, 2.3],        [5.6, 2.8, 4.9, 2. ],        [7.7, 2.8, 6.7, 2. ],        [6.3, 2.7, 4.9, 1.8],        [6.7, 3.3, 5.7, 2.1],        [7.2, 3.2, 6. , 1.8],        [6.2, 2.8, 4.8, 1.8],        [6.1, 3. , 4.9, 1.8],        [6.4, 2.8, 5.6, 2.1],        [7.2, 3. , 5.8, 1.6],        [7.4, 2.8, 6.1, 1.9],        [7.9, 3.8, 6.4, 2. ],        [6.4, 2.8, 5.6, 2.2],        [6.3, 2.8, 5.1, 1.5],        [6.1, 2.6, 5.6, 1.4],        [7.7, 3. , 6.1, 2.3],        [6.3, 3.4, 5.6, 2.4],        [6.4, 3.1, 5.5, 1.8],        [6. , 3. , 4.8, 1.8],        [6.9, 3.1, 5.4, 2.1],        [6.7, 3.1, 5.6, 2.4],        [6.9, 3.1, 5.1, 2.3],        [5.8, 2.7, 5.1, 1.9],        [6.8, 3.2, 5.9, 2.3],        [6.7, 3.3, 5.7, 2.5],        [6.7, 3. , 5.2, 2.3],        [6.3, 2.5, 5. , 1.9],        [6.5, 3. , 5.2, 2. ],        [6.2, 3.4, 5.4, 2.3],        [5.9, 3. , 5.1, 1.8]]), &apos;feature_names&apos;: [&apos;sepal length (cm)&apos;,  &apos;sepal width (cm)&apos;,  &apos;petal length (cm)&apos;,  &apos;petal width (cm)&apos;], &apos;target&apos;: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), &apos;target_names&apos;: array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=&apos;&lt;U10&apos;)}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = iris.data</span><br><span class="line">target = iris.target</span><br><span class="line">target_names = iris.target_names</span><br><span class="line">feature_names = iris.feature_names</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">features = DataFrame(data=data,columns = feature_names)</span><br><span class="line">features.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">0</span>].std()</span><br></pre></td></tr></table></figure><pre><code>0.828066127977863</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">2</span>].std()</span><br></pre></td></tr></table></figure><pre><code>1.7644204199522626</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">1</span>].std()</span><br></pre></td></tr></table></figure><pre><code>0.4335943113621737</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">3</span>].std()</span><br></pre></td></tr></table></figure><pre><code>0.7631607417008411</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># samples(训练集、测试集)</span></span><br><span class="line">X_train = features.iloc[:<span class="number">130</span>,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">y_train = target[:<span class="number">130</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集(验证训练模型的准确度)</span></span><br><span class="line">X_test = features.iloc[<span class="number">130</span>:,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">y_test = target[<span class="number">130</span>:]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display(X_train.shape,y_train.shape,X_test.shape,y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(130, 2)(130,)(20, 2)(20,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_names</span><br></pre></td></tr></table></figure><pre><code>array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=&apos;&lt;U10&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># （离散性的、标称型）目标值是不参与运算的，所以不是必须要转换成数字的格式</span></span><br><span class="line">target</span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><p>绘制图形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">samples = features.iloc[:,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示真实数据的分类情况</span></span><br><span class="line">plt.scatter(samples.iloc[:,<span class="number">0</span>],samples.iloc[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-2-feaf3557f814&gt; in &lt;module&gt;()      1 import matplotlib.pyplot as plt      2 get_ipython().run_line_magic(&apos;matplotlib&apos;, &apos;inline&apos;)----&gt; 3 samples = features.iloc[:,2:4]      4       5 # 展示真实数据的分类情况NameError: name &apos;features&apos; is not defined</code></pre><p>定义KNN分类器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>第一步，训练数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knnclf.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=5, p=2,           weights=&apos;uniform&apos;)</code></pre><p>第二步预测数据：，所预测的数据，自己创造，就是上面所显示图片的背景点  </p><p>生成预测数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模型准确度的评估</span></span><br><span class="line"><span class="comment"># 1. 测试样本及应该是随机的</span></span><br><span class="line"><span class="comment"># 2. 测试样本集数量不能太小</span></span><br><span class="line">y_ = knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_test</span><br></pre></td></tr></table></figure><pre><code>array([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_</span><br></pre></td></tr></table></figure><pre><code>array([2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有预测点（满屏幕的点）</span></span><br><span class="line">xmin,xmax = samples.iloc[:,<span class="number">0</span>].min(),samples.iloc[:,<span class="number">0</span>].max()</span><br><span class="line">ymin,ymax = samples.iloc[:,<span class="number">1</span>].min(),samples.iloc[:,<span class="number">1</span>].max()</span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">100</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br><span class="line"></span><br><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br></pre></td></tr></table></figure><p>对数据进行预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_ = knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><p>显示数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">cmap = ListedColormap([<span class="string">'#aa00ff'</span>,<span class="string">'#00aaff'</span>,<span class="string">'#ffaa00'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示预测数据的分类情况</span></span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_,cmap=cmap)</span><br><span class="line"><span class="comment"># 展示真实数据的分类情况</span></span><br><span class="line">plt.scatter(samples.iloc[:,<span class="number">0</span>],samples.iloc[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x189b2990&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841319285.png" alt="Untitled-1-201841319285"></p><h3 id="2）用于回归"><a href="#2）用于回归" class="headerlink" title="2）用于回归"></a>2）用于回归</h3><p>回归用于对趋势的预测</p><p>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br></pre></td></tr></table></figure><p>生成样本数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一组符合正弦分布的数据</span></span><br><span class="line">x = np.linspace(-np.pi,np.pi,<span class="number">40</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"><span class="comment"># 原始数据的分布规律</span></span><br><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x19be92b0&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192811.png" alt="Untitled-1-2018413192811"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noise = np.random.random(size=<span class="number">20</span>) - <span class="number">0.5</span></span><br><span class="line">noise</span><br></pre></td></tr></table></figure><pre><code>array([-0.01419036, -0.05222776,  0.4114977 , -0.48535771,  0.4725629 ,        0.49193969, -0.4352523 , -0.48704335,  0.39377464, -0.32509247,        0.09969959, -0.10353899,  0.35402717,  0.09005099, -0.32349592,       -0.41517568,  0.13719123,  0.40893228,  0.25830619,  0.00900481])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[::<span class="number">2</span>] += noise</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x18594890&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192816.png" alt="Untitled-1-2018413192816"></p><p>生成测试数据的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train = x.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y_train = y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">knn = KNeighborsRegressor(n_neighbors=<span class="number">7</span>)</span><br><span class="line">knn.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">X_test = np.linspace(-np.pi,np.pi,<span class="number">100</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y_ = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line">plt.plot(X_test,y_,color=<span class="string">'green'</span>)</span><br><span class="line">plt.scatter(X_train,y_train,color=<span class="string">'orange'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过拟合</span></span><br><span class="line"><span class="comment"># 欠拟合</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x19b872b0&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192821.png" alt="Untitled-1-2018413192821"></p><p>第一步：生成模型，并训练数据</p><p>第二步：使用模型，预测数据</p><p>绘图显示数据</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>人类动作识别<br>步行，上楼，下楼，坐着，站立和躺着  </p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413193022.jpg" alt="Untitled-1-2018413193022"><br>数据采集每个人在腰部穿着智能手机，进行了六个活动（步行，上楼，下楼，坐着，站立和躺着）。采用嵌入式加速度计和陀螺仪，以50Hz的恒定速度捕获3轴线性加速度和3轴角速度，来获取数据</p><p>导入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_train = np.load(<span class="string">'x_train.npy'</span>)</span><br><span class="line">y_train = np.load(<span class="string">'y_train.npy'</span>)</span><br><span class="line"></span><br><span class="line">X_test = np.load(<span class="string">'x_test.npy'</span>)</span><br><span class="line">y_test = np.load(<span class="string">'y_test.npy'</span>)</span><br><span class="line"></span><br><span class="line">display(X_train.shape,y_train.shape,X_test.shape,y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(7352, 561)(7352,)(2947, 561)(2947,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame(X_train).head(</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Series(y_train).unique()</span><br></pre></td></tr></table></figure><pre><code>array([5, 4, 6, 1, 3, 2], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label = &#123;<span class="number">1</span>:<span class="string">'WALKING'</span>, </span><br><span class="line">         <span class="number">2</span>:<span class="string">'WALKING UPSTAIRS'</span>, </span><br><span class="line">         <span class="number">3</span>:<span class="string">'WALKING DOWNSTAIRS'</span>,</span><br><span class="line">         <span class="number">4</span>:<span class="string">'SITTING'</span>, </span><br><span class="line">         <span class="number">5</span>:<span class="string">'STANDING'</span>, </span><br><span class="line">         <span class="number">6</span>:<span class="string">'LAYING'</span>&#125;</span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整算法参数只能对算法调优，不能决定算法的高度</span></span><br><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">9</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KNN在训练的时候，是不进行运算的（距离）</span></span><br><span class="line">knnclf.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=9, p=2,           weights=&apos;uniform&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KNN在进行预测的时候，才开始计算训练集和测试集中样本点之间的距离</span></span><br><span class="line">y_ = knnclf.predict(X_test[:<span class="number">1000</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类算法的评分就是这么算的</span></span><br><span class="line">(y_ == y_test[:<span class="number">1000</span>]).sum()/y_.size</span><br></pre></td></tr></table></figure><pre><code>0.922</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算分类算法的评分</span></span><br><span class="line">knnclf.score(X_test[:<span class="number">500</span>],y_test[:<span class="number">500</span>])</span><br></pre></td></tr></table></figure><pre><code>0.928</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">8</span>))</span><br><span class="line">colors = [<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>,<span class="string">'cyan'</span>,<span class="string">'purple'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i)</span><br><span class="line">    title = label[i]</span><br><span class="line">    Series(X_train[y_train==i][<span class="number">0</span>]).plot(color=colors[i<span class="number">-1</span>],title=title)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192827.png" alt="Untitled-1-2018413192827"></p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebSocket详细解析</title>
      <link href="/2018/04/10/websocket/"/>
      <url>/2018/04/10/websocket/</url>
      <content type="html"><![CDATA[<h3 id="你真的了解WebSocket吗？"><a href="#你真的了解WebSocket吗？" class="headerlink" title="你真的了解WebSocket吗？"></a>你真的了解WebSocket吗？</h3><p>  WebSocket协议是基于TCP的一种新的协议。WebSocket最初在HTML5规范中被引用为TCP连接，作为基于TCP的套接字API的占位符。它实现了浏览器与服务器全双工(full-duplex)通信。其本质是保持TCP连接，在浏览器和服务端通过Socket进行通信。</p><p> 本文将使用Python编写Socket服务端，一步一步分析请求过程！！！</p><h3 id="1-启动服务端"><a href="#1-启动服务端" class="headerlink" title="1.启动服务端"></a>1.启动服务端</h3><ul><li>启动服务器后，等待用户连接，然后进行收发数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&apos;127.0.0.1&apos;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"># 等待用户连接</span><br><span class="line">conn, address = sock.accept()</span><br></pre></td></tr></table></figure><h3 id="2-客户端连接"><a href="#2-客户端连接" class="headerlink" title="2.客户端连接"></a>2.客户端连接</h3><ul><li>当客户端向服务端发送连接请求时，不仅连接还会发送【握手】信息，并等待服务端响应，至此连接才创建成功！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var socket = new WebSocket(&quot;ws://127.0.0.1:8002/xxoo&quot;);</span><br><span class="line">    ...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-建立链接【握手】"><a href="#3-建立链接【握手】" class="headerlink" title="3.建立链接【握手】"></a>3.建立链接【握手】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&apos;127.0.0.1&apos;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"># 获取客户端socket对象</span><br><span class="line">conn, address = sock.accept()</span><br><span class="line"># 获取客户端的【握手】信息</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">conn.send(&apos;响应【握手】信息&apos;)</span><br></pre></td></tr></table></figure><p>请求和响应的【握手】信息需要遵循规则：</p><ul><li>从请求【握手】信息中提取 Sec-WebSocket-Key</li><li>利用magic_string 和 Sec-WebSocket-Key 进行hmac1加密，再进行base64加密</li><li>将加密结果响应给客户端<h4 id="注：magic-string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11"><a href="#注：magic-string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11" class="headerlink" title="注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11"></a>注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11</h4></li></ul><p>请求【握手】信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /chatsocket HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8002</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http://localhost:63342</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: mnwFxiOlctXFN/DeMt1Amg==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><p>提取Sec-WebSocket-Key值并加密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import base64</span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">def get_headers(data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将请求头格式化成字典</span><br><span class="line">    :param data:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    header_dict = &#123;&#125;</span><br><span class="line">    data = str(data, encoding=&apos;utf-8&apos;)</span><br><span class="line"> </span><br><span class="line">    for i in data.split(&apos;\r\n&apos;):</span><br><span class="line">        print(i)</span><br><span class="line">    header, body = data.split(&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">    header_list = header.split(&apos;\r\n&apos;)</span><br><span class="line">    for i in range(0, len(header_list)):</span><br><span class="line">        if i == 0:</span><br><span class="line">            if len(header_list[i].split(&apos; &apos;)) == 3:</span><br><span class="line">                header_dict[&apos;method&apos;], header_dict[&apos;url&apos;], header_dict[&apos;protocol&apos;] = header_list[i].split(&apos; &apos;)</span><br><span class="line">        else:</span><br><span class="line">            k, v = header_list[i].split(&apos;:&apos;, 1)</span><br><span class="line">            header_dict[k] = v.strip()</span><br><span class="line">    return header_dict</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&apos;127.0.0.1&apos;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"> </span><br><span class="line">conn, address = sock.accept()</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line">headers = get_headers(data) # 提取请求头信息</span><br><span class="line"># 对请求头中的sec-websocket-key进行加密</span><br><span class="line">response_tpl = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; \</span><br><span class="line">      &quot;Upgrade:websocket\r\n&quot; \</span><br><span class="line">      &quot;Connection: Upgrade\r\n&quot; \</span><br><span class="line">      &quot;Sec-WebSocket-Accept: %s\r\n&quot; \</span><br><span class="line">      &quot;WebSocket-Location: ws://%s%s\r\n\r\n&quot;</span><br><span class="line">magic_string = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;</span><br><span class="line">value = headers[&apos;Sec-WebSocket-Key&apos;] + magic_string</span><br><span class="line">ac = base64.b64encode(hashlib.sha1(value.encode(&apos;utf-8&apos;)).digest())</span><br><span class="line">response_str = response_tpl % (ac.decode(&apos;utf-8&apos;), headers[&apos;Host&apos;], headers[&apos;url&apos;])</span><br><span class="line"># 响应【握手】信息</span><br><span class="line">conn.send(bytes(response_str, encoding=&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure><h3 id="4-客户端和服务端收发数据"><a href="#4-客户端和服务端收发数据" class="headerlink" title="4.客户端和服务端收发数据"></a>4.客户端和服务端收发数据</h3><p>详细原理：<a href="https://yuansuixin.github.io/2018/04/09/websocket-data/" title="解包和封包原理">解包和封包原理</a></p><p>客户端和服务端传输数据时，需要对数据进行【封包】和【解包】。客户端的JavaScript类库已经封装【封包】和【解包】过程，但Socket服务端需要手动实现。</p><p>第一步：获取客户端发送的数据【解包】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   info = conn.recv(8096)</span><br><span class="line"></span><br><span class="line">    payload_len = info[1] &amp; 127</span><br><span class="line">    if payload_len == 126:</span><br><span class="line">        extend_payload_len = info[2:4]</span><br><span class="line">        mask = info[4:8]</span><br><span class="line">        decoded = info[8:]</span><br><span class="line">    elif payload_len == 127:</span><br><span class="line">        extend_payload_len = info[2:10]</span><br><span class="line">        mask = info[10:14]</span><br><span class="line">        decoded = info[14:]</span><br><span class="line">    else:</span><br><span class="line">        extend_payload_len = None</span><br><span class="line">        mask = info[2:6]</span><br><span class="line">        decoded = info[6:]</span><br><span class="line"></span><br><span class="line">    bytes_list = bytearray()</span><br><span class="line">    for i in range(len(decoded)):</span><br><span class="line">        chunk = decoded[i] ^ mask[i % 4]</span><br><span class="line">        bytes_list.append(chunk)</span><br><span class="line">    body = str(bytes_list, encoding=&apos;utf-8&apos;)</span><br><span class="line">    print(body)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p> 第二步：向客户端发送数据【封包】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def send_msg(conn, msg_bytes):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    WebSocket服务端向客户端发送消息</span><br><span class="line">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span><br><span class="line">    :param msg_bytes: 向客户端发送的字节</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import struct</span><br><span class="line"></span><br><span class="line">    token = b&quot;\x81&quot;</span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    if length &lt; 126:</span><br><span class="line">        token += struct.pack(&quot;B&quot;, length)</span><br><span class="line">    elif length &lt;= 0xFFFF:</span><br><span class="line">        token += struct.pack(&quot;!BH&quot;, 126, length)</span><br><span class="line">    else:</span><br><span class="line">        token += struct.pack(&quot;!BQ&quot;, 127, length)</span><br><span class="line"></span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><p><a href="https://github.com/yuansuixin/WebSocket" title="基于Python的简单示例" target="_blank" rel="noopener">基于Python的简单示例</a></p><p><a href="https://github.com/yuansuixin/WebSocket-Tornado-Chat" title="基于Tornado框架的Web聊天室" target="_blank" rel="noopener">基于Tornado框架的Web聊天室</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/04/10/jupyter/"/>
      <url>/2018/04/10/jupyter/</url>
      <content type="html"><![CDATA[<hr><p>title: jupyter-notebook 快捷方式<br>date: 2017-11-20 12:32:50<br>categories:</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><blockquote><p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。<br>Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。–百度百科</p></blockquote><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>Jupyter笔记本有两种不同的键盘输入模式，<strong>编辑模式</strong> 允许将代码或文本输入到单元格，并以绿色单元格边框表示。<strong>命令行模式</strong> 允许输入各种命令，并有具有蓝色左边框的灰色单元格边框表示。</p><p>从命令行模式进入编辑模式按<code>Enter</code>键，从编辑模式切换到命令行模式按<code>Esc</code>键。</p><p>下表将对快捷键做简单的说明：</p><h2 id="命令行模式快捷键（按Esc键开启）"><a href="#命令行模式快捷键（按Esc键开启）" class="headerlink" title="命令行模式快捷键（按Esc键开启）"></a>命令行模式快捷键（按Esc键开启）</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>F</td><td>寻找和替换</td><td></td></tr><tr><td>Ctrl-Shift-F</td><td>打开命令调色板</td><td></td></tr><tr><td>Ctrl-Shift-P</td><td>打开命令调色板</td><td></td></tr><tr><td>Enter</td><td>转入编辑模式</td><td></td></tr><tr><td>P</td><td>打开命令调色板</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下个单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在其下插入新单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Y</td><td>单元转入代码状态</td><td></td></tr><tr><td>M</td><td>单元转入 markdown 状态</td><td></td></tr><tr><td>R</td><td>单元转入 raw 状态</td><td></td></tr><tr><td>1</td><td>设定 1 级标题</td><td>仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态</td></tr><tr><td>2</td><td>设定 2 级标题</td><td></td></tr><tr><td>3</td><td>设定 3 级标题</td><td></td></tr><tr><td>4</td><td>设定 4 级标题</td><td></td></tr><tr><td>5</td><td>设定 5 级标题</td><td></td></tr><tr><td>6</td><td>设定 6 级标题</td><td></td></tr><tr><td>K</td><td>选中上方单元</td><td></td></tr><tr><td>Up</td><td>选中上方单元</td><td></td></tr><tr><td>Down</td><td>选中下方单元</td><td></td></tr><tr><td>J</td><td>选中下方单元</td><td></td></tr><tr><td>Shift-Down</td><td>扩展下面的选定单元格</td><td></td></tr><tr><td>Shift-J</td><td>扩展下面的选定单元格</td><td></td></tr><tr><td>Shift-K</td><td>连续选择上方单元</td><td></td></tr><tr><td>Shift-J</td><td>连续选择下方单元</td><td></td></tr><tr><td>A</td><td>在上方插入新单元</td><td></td></tr><tr><td>B</td><td>在下方插入新单元</td><td></td></tr><tr><td>X</td><td>剪切选中的单元</td><td></td></tr><tr><td>C</td><td>复制选中的单元</td><td></td></tr><tr><td>Shift-V</td><td>粘贴到上方单元</td><td></td></tr><tr><td>V</td><td>粘贴到下方单元</td><td></td></tr><tr><td>Z</td><td>恢复删除的最后一个单元</td><td></td></tr><tr><td>D,D</td><td>删除选中的单元</td><td>连续按两个 D 键</td></tr><tr><td>Shift-M</td><td>合并选中的单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>L</td><td>开关行号</td><td>编辑框的行号是可以开启和关闭的</td></tr><tr><td>O</td><td>转换输出</td><td></td></tr><tr><td>Shift-O</td><td>转换输出滚动</td><td></td></tr><tr><td>H</td><td>显示快捷键帮助</td><td></td></tr><tr><td>I,I</td><td>中断 NoteBook 内核</td><td></td></tr><tr><td>0,0</td><td>重启 NoteBook 内核</td><td></td></tr><tr><td>Esc</td><td>关闭页面</td><td></td></tr><tr><td>Q</td><td>关闭页面</td><td></td></tr><tr><td>Shift-L</td><td>切换所有单元格中的行号，并坚持设置</td><td></td></tr><tr><td>Shift-Space</td><td>向上滚动</td><td></td></tr><tr><td>Space</td><td>向下滚动</td></tr></tbody></table><h2 id="编辑模式快捷键（按Enter键启动）"><a href="#编辑模式快捷键（按Enter键启动）" class="headerlink" title="编辑模式快捷键（按Enter键启动）"></a>编辑模式快捷键（按Enter键启动）</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>快捷键</td><td>作用</td><td>说明</td></tr><tr><td>Tab</td><td>代码补全或缩进</td><td></td></tr><tr><td>Shift-Tab</td><td>提示</td><td>输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助</td></tr><tr><td>Ctrl-]</td><td>缩进向右缩进</td><td></td></tr><tr><td>Ctrl-[</td><td>解除缩进</td><td>向左缩进</td></tr><tr><td>Ctrl-A</td><td>全选</td><td></td></tr><tr><td>Ctrl-Z</td><td>撤销</td><td></td></tr><tr><td>Ctrl-D</td><td>删除整行</td><td></td></tr><tr><td>Ctrl-U</td><td>撤消选择</td><td></td></tr><tr><td>Insert</td><td>切换覆盖标志</td><td></td></tr><tr><td>Ctrl-Home</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-Up</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-End</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Down</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Left</td><td>跳到左边一个字首</td><td></td></tr><tr><td>Ctrl-Right</td><td>跳到右边一个字首</td><td></td></tr><tr><td>Ctrl-Backspace</td><td>删除前面一个字</td><td></td></tr><tr><td>Ctrl-Delete</td><td>删除后面一个字</td><td></td></tr><tr><td>Ctrl-Y</td><td>重做</td><td></td></tr><tr><td>Ctrl-Shift-Z</td><td>重做</td><td></td></tr><tr><td>Esc</td><td>切换到命令模式</td><td></td></tr><tr><td>Ctrl-M</td><td>切换到命令模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下一单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在下面插入一单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Ctrl-Shift–</td><td>分割单元</td><td>按光标所在行进行分割</td></tr><tr><td>Ctrl-Shift-Subtract</td><td>分割单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Up</td><td>光标上移或转入上一单元</td><td></td></tr><tr><td>Down</td><td>光标下移或转入下一单元</td><td></td></tr><tr><td>Ctrl-/</td><td>注释整行/撤销注释</td><td>仅代码状态有效</td></tr></tbody></table><h5 id="【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等"><a href="#【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等" class="headerlink" title="【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等"></a><strong>【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等</strong></h5>]]></content>
      
      
    </entry>
    
    <entry>
      <title>WebSocket传输数据服务端的封包解包原理</title>
      <link href="/2018/04/09/websocket-data/"/>
      <url>/2018/04/09/websocket-data/</url>
      <content type="html"><![CDATA[<h1 id="WebSocket传输数据服务端的封包解包原理"><a href="#WebSocket传输数据服务端的封包解包原理" class="headerlink" title="WebSocket传输数据服务端的封包解包原理"></a>WebSocket传输数据服务端的封包解包原理</h1><p>  客户端和服务端传输数据时，需要对数据进行【封包】和【解包】。客户端的JavaScript类库已经封装【封包】和【解包】过程，但Socket服务端需要手动实现。</p><blockquote><p>获取客户端发送的数据【解包】</p></blockquote><ul><li>获取到的客户端的数据不能直接拿到，需要通过位运算，里面的东西都有代指的，第几位代表什么，</li><li>规则<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201849223212.png" alt="Untitled-1-201849223212"><ul><li>以客户端发送的hello为例，服务端接收到<code>info=&quot;b&#39;\x88\x82\x08j\xe8\x00\x0b\x83&#39;&quot;</code></li><li>服务端拿到的都是字节，那么info[0]就是第一个字节，也就是八位</li><li>通过规则图可以知道，我们要计算出来opcode的值</li><li>我们就需要计算出来第一个字节的后四位的值，那么怎么才能拿到后四位的值呢，就是和1111进行与运算，也就是和15进行与计算<code>opcode=info[0] &amp; 15</code>,那么这个值最大为15</li><li>我们需要计算出图中的fin，向右移7位就可以得到，同理得到其他的值</li><li>opcode及之前的fin等这两个字节是用来判断发送的内容是否发送完毕，如果没发完继续收，等全部内容发完，再统一的解码</li><li>同样的道理我们要计算出payload_len,payload_len需要得到第二个字节的八位，那么和11111111进行与运算可以得到<code>payload_len=info[1]&amp;127</code>,那么这个值最大为127</li><li>payload_len 的长度决定了它（数据头）再往后会占多少<ul><li>小于126，数据头到payload_len就结束了</li><li>等于126，数据头再往后延伸2个字节，头部总共占4个字节</li><li>大于126，数据头再往后延伸8个字节，头部总共占10个字节</li></ul></li><li>数据头部是数据部分，数据部分的前4个字节都是加密的masking key，我们需要解密才能拿到真正的数据</li></ul></li></ul><ul><li>代码部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">info = conn.recv(8096)</span><br><span class="line"></span><br><span class="line">payload_len = info[1] &amp; 127</span><br><span class="line">if payload_len == 126:</span><br><span class="line">    #数据头部延伸的长度</span><br><span class="line">    extend_payload_len = info[2:4]</span><br><span class="line">    #加密的4个字节</span><br><span class="line">    mask = info[4:8]</span><br><span class="line">    #数据</span><br><span class="line">    decoded = info[8:]</span><br><span class="line">elif payload_len == 127:</span><br><span class="line">    extend_payload_len = info[2:10]</span><br><span class="line">    mask = info[10:14]</span><br><span class="line">    decoded = info[14:]</span><br><span class="line">else:</span><br><span class="line">    extend_payload_len = None</span><br><span class="line">    mask = info[2:6]</span><br><span class="line">    decoded = info[6:]</span><br><span class="line"></span><br><span class="line">bytes_list = bytearray()</span><br><span class="line">for i in range(len(decoded)):</span><br><span class="line">    chunk = decoded[i] ^ mask[i % 4]</span><br><span class="line">    bytes_list.append(chunk)</span><br><span class="line">body = str(bytes_list, encoding=&apos;utf-8&apos;)</span><br><span class="line">print(body)</span><br></pre></td></tr></table></figure><ul><li>规则文档</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1\. (In fact, [section 5.1 of the spec](http://tools.ietf.org/html/rfc6455#section-5.1) says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We&apos;ll explain masking later. _Note: You have to mask messages even when using a secure socket._RSV1-3 can be ignored, they are for extensions.</span><br><span class="line"></span><br><span class="line">The opcode field defines how to interpret the payload data: 0x0 for continuation, `0x1` for text (which is always encoded in UTF-8), `0x2` for binary, and other so-called &quot;control codes&quot; that will be discussed later. In this version of WebSockets, `0x3` to `0x7` and `0xB` to `0xF` have no meaning.</span><br><span class="line"></span><br><span class="line">The FIN bit tells whether this is the last message in a series. If it&apos;s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later.</span><br><span class="line"></span><br><span class="line">**Decoding Payload Length**</span><br><span class="line"></span><br><span class="line">To read the payload data, you must know when to stop reading. That&apos;s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps:</span><br><span class="line"></span><br><span class="line">1.  Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it&apos;s 125 or less, then that&apos;s the length; you&apos;re **done**. If it&apos;s 126, go to step 2\. If it&apos;s 127, go to step 3.</span><br><span class="line">2.  Read the next 16 bits and interpret those as an unsigned integer. You&apos;re **done**.</span><br><span class="line">3.  Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You&apos;re **done**.</span><br><span class="line"></span><br><span class="line">**Reading and Unmasking the Data**</span><br><span class="line"></span><br><span class="line">If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let&apos;s call the data **ENCODED**, and the key **MASK**. To get **DECODED**, loop through the octets (bytes a.k.a. characters for text data) of **ENCODED** and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript):</span><br><span class="line"></span><br><span class="line">var DECODED = &quot;&quot;;</span><br><span class="line">for (var i = 0; i &lt; ENCODED.length; i++) &#123;</span><br><span class="line">    DECODED[i] = ENCODED[i] ^ MASK[i % 4];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Now you can figure out what **DECODED** means depending on your application.</span><br></pre></td></tr></table></figure><ul><li>解密<ul><li>使用masking key ，从后面一个一个的拿数据，然后一个一个的解</li><li>注意：如果有中文，直接解码为字节，然后全部的字节统一转化成字符串，否则使用一个一个解码放入字符中容易乱码</li></ul></li></ul><blockquote><p>向客户端发送数据【封包】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#msg_bytes这个是给用户返回的字节</span><br><span class="line">def send_msg(conn, msg_bytes):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    WebSocket服务端向客户端发送消息</span><br><span class="line">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span><br><span class="line">    :param msg_bytes: 向客户端发送的字节</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 封二进制包使用</span><br><span class="line">    import struct</span><br><span class="line"></span><br><span class="line">    token = b&quot;\x81&quot;</span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    #打包规则</span><br><span class="line">    if length &lt; 126:</span><br><span class="line">        token += struct.pack(&quot;B&quot;, length)</span><br><span class="line">    elif length &lt;= 0xFFFF:</span><br><span class="line">        token += struct.pack(&quot;!BH&quot;, 126, length)</span><br><span class="line">    else:</span><br><span class="line">        token += struct.pack(&quot;!BQ&quot;, 127, length)</span><br><span class="line"></span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><ul><li>位运算，右移动  &gt;&gt;<ul><li>10010001</li><li>右移4:00001001  前面补0</li><li>左移4：100100010000  后面补0</li></ul></li><li>异或运算，向异取1<ul><li>都是1： 0</li><li>0,1： 1</li><li>0,0:  0</li></ul></li><li>与运算<ul><li>一个字节八位，如果要后四位的值那么就设计一个值和原值进行与运算结果还是后四位</li><li>0 0 0 0 0 0 0 0 要取后四位的值，只需要和00001111进行与运算，前面的四位为0000忽略掉，即可得到后四位还是0000</li></ul></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Python零散的小知识点</title>
      <link href="/2018/03/30/tornado-session-py/"/>
      <url>/2018/03/30/tornado-session-py/</url>
      <content type="html"><![CDATA[<ul><li><p>注意：本节小知识点都是为tornado自定义session准备的！</p></li><li><p>多继承是先执行左边的，再依次向右，继承的一些知识点，太过基础了，这里我就不赘述了</p></li><li>super是按照顺序查找，也可以不让他按顺序查找，就是使用<code>类名.方法名（self）</code></li><li><p>对象调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = Foo()</span><br><span class="line">obj.f1()</span><br><span class="line">上面是对象自动将对象本身传递给方法，我们也可以手动的传递，就相当于</span><br><span class="line">obj = Foo()</span><br><span class="line">Foo.f1(obj)</span><br></pre></td></tr></table></figure></li><li><p>self是什么？self永远是调用这个方法的对象，</p></li></ul><ul><li><p>使用session[‘xx’]=’fdas’这种键值方式的语法，Python就会自动调用<code>__setitem（）__</code>魔法方法，也就是说并不是只有字典可以使用键值的方式调用，所有类都可以，只是加上这个对应的魔法方法即可</p></li><li><p>Python中的in操作符的时候会自动调用<code>__contains__()</code>魔法方法</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>使用Tornado自定义Session组件</title>
      <link href="/2018/03/29/tornado-session/"/>
      <url>/2018/03/29/tornado-session/</url>
      <content type="html"><![CDATA[<p>最近又看了看tornado框架，写了一个自定义的组件。一直没时间上传，今天终于可以和大家见面了，对了，大家在和本文亲密之前需要先预热一下哦~:stuck_out_tongue::stuck_out_tongue::stuck_out_tongue:</p><p><a href="https://yuansuixin.github.io/2018/03/30/tornado-session-py/" title="预热">预热</a></p><h2 id="Tornado的自定义session组件"><a href="#Tornado的自定义session组件" class="headerlink" title="Tornado的自定义session组件"></a>Tornado的自定义session组件</h2><h4 id="1-session会话技术"><a href="#1-session会话技术" class="headerlink" title="1. session会话技术"></a>1. session会话技术</h4><ul><li><p>既然咱们要说一说session，那么必然要知道session是什么，接下来让我们一同了解一下session吧！</p><ul><li>Session 是服务器保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</li><li><p>Cookie 是客户端保存用户信息的一个机制，用来记录用户的一些信息，也是实现Session的一个方式，存储在用户的浏览器中</p><p><a href="https://yuansuixin.github.io/2018/02/12/cookie-session/" title="cookie和session会话技术详细讲解">cookie和session会话技术详细讲解</a></p></li></ul></li></ul><h4 id="2-自定义session原理解析"><a href="#2-自定义session原理解析" class="headerlink" title="2. 自定义session原理解析"></a>2. 自定义session原理解析</h4><p>我们先来看看tornado的基础程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br><span class="line"></span><br><span class="line">settings = &#123;</span><br><span class="line">    &apos;template_path&apos;: &apos;views&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&apos;/index&apos;, MainHandler),</span><br><span class="line">], **settings)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><ul><li><p>我们会发现当请求来的时候，就会调用get()方法，那么大家想一下，这个get()方法的调用是不是需要MainHandler对象来调用，如果没有对象，MainHandler里面的get()根本就调用不了，</p></li><li><p>所以肯定是要先创建对象，要创建对象那么一定要执行<code>__init__()</code>方法，然而我们没有写<code>__init__()</code>方法，那怎么办呢，这时候我们准备的知识点就用到啦，需要到父类中去查找，也就是RequestHandler类的<code>__init__()</code>,</p></li><li>我们可以看到RequestHandler类的<code>__init__()</code>，也就是说，在调用这个get（）方法之前肯定要调用<code>__init__()</code>方法，也就是说只要在<code>__init__()</code>方法中写入的东西都是get（）或者post（）方法之前的。</li><li><p>我们可以发现在<code>__init__()</code>方法的最后调用了 <code>self.initialize(**kwargs)</code>然而，这个方法什么都没写，也就是给我们预留的添加自己的操作的方法，我们将从这里入手</p></li><li><p>通过继承的机制我们可以知道要向给handler添加自己的东西，有两种写法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">第一种：多继承</span><br><span class="line">class Foo(object):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.A = 123</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line">class MainHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        print(self.A)</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br><span class="line">第二种：常规写法</span><br><span class="line">class Foo(tornado.web.RequestHandler):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.A = 123</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line">class MainHandler(Foo):</span><br><span class="line">    def get(self):</span><br><span class="line">        print(self.A)</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>因为Python是支持多继承的，所以我们将以多继承的这种方式进行解析</p></blockquote><ul><li>我们模拟Django的session来说，登录账号之后，session就自动的帮我们写到了服务器上了，我们要开源这个组件就需要让用户感知起来非常的方便，所以，我们以后就想让用户这样写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session[&apos;xxx&apos;] = &apos;dfdafdasfd&apos;</span><br></pre></td></tr></table></figure><ul><li><p>所以我们需要做这些事情，而且我们需要【】这样取值，我们首先想到的类型就是字典，没错，字典是这样取值，但是我们提前的知识点可不是白学的呦，使用<code>__setitem__()</code>魔法方法就可以呦，为了后面的额步骤,我们选择可以使用类。</p><ol><li>生成随机字符串</li><li>写到用户cookie</li><li>后台存储</li></ol></li><li><p>大家应该还记得MainHandler里面有self.set_cookie()函数，我们需要使用这个函数将session_id 写入cookie中，然而Foo类中的self就是MainHandler对象，所以我们只需要将self传入Bar就可以了</p></li><li><p>将session写入数据库，我们先使用一个字典充当数据库</p></li></ul><h4 id="3-写自定义的session代码"><a href="#3-写自定义的session代码" class="headerlink" title="3. 写自定义的session代码"></a>3. 写自定义的session代码</h4><ul><li>我们按照我们分析的原理将代码写出来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">import time</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 存储session数据</span><br><span class="line">container=&#123;</span><br><span class="line">    &apos;asdf&apos;:&#123;&apos;k&apos;:&apos;v&apos;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar():</span><br><span class="line">    # self，谁调用这个函数，self就是谁</span><br><span class="line">    #这个self就是MainHandler对象，可以将这个self传递给Bar（）</span><br><span class="line">    def __init__(self,handler):</span><br><span class="line">        self.handler = handler</span><br><span class="line">        self.random_str = None</span><br><span class="line">        # 去用户请求信息中获取session_id ，如果没有就是新用户或者是没有登陆</span><br><span class="line">        client_random_str = self.handler.get_cookie(&apos;session_id&apos;)</span><br><span class="line">        if not client_random_str:</span><br><span class="line">            # 新用户</span><br><span class="line">            self.random_str = self.create_random_str()</span><br><span class="line">            # 添加到数据库中一个数据</span><br><span class="line">            container[self.random_str]=&#123;&#125;</span><br><span class="line">        else:</span><br><span class="line">            # 判断是否是合法的session</span><br><span class="line">            if client_random_str in container:</span><br><span class="line">                # 老用户</span><br><span class="line">                self.random_str = client_random_str</span><br><span class="line">            else:</span><br><span class="line">                # 非法用户</span><br><span class="line">                self.random_str = self.create_random_str()</span><br><span class="line">        # 设置更新时间]</span><br><span class="line">        ctime = time.time()</span><br><span class="line">        self.handler.set_cookie(&apos;session_id&apos;,self.random_str,expires=ctime+1800) # 超时时间</span><br><span class="line"></span><br><span class="line"> # 生成随机的字符串,md5摘要</span><br><span class="line">    def create_random_str(self):</span><br><span class="line">        v = str(time.time())</span><br><span class="line">        m = hashlib.md5()</span><br><span class="line">        m.update(bytes(v,encoding=&apos;utf-8&apos;))</span><br><span class="line">        return m.hexdigest()</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        container[self.random_str][key] = value</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        return container[self.random_str].get(key)</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        del container[self.random_str][key]</span><br><span class="line"></span><br><span class="line">    #清空</span><br><span class="line">    def clear(self):</span><br><span class="line">        del container[self.random_str]</span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.session = Bar(self)</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line"></span><br><span class="line">class HomeHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        print(&apos;home&apos;)</span><br><span class="line">        user = self.session[&apos;uuuu&apos;]</span><br><span class="line">        if not user:</span><br><span class="line">            self.redirect(&apos;https://www.baidu.com&apos;)</span><br><span class="line">        else:</span><br><span class="line">            self.write(user)</span><br><span class="line"></span><br><span class="line">class LoginHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.session[&apos;uuuu&apos;] = &apos;root&apos;</span><br><span class="line">        self.redirect(&apos;/home&apos;)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&apos;/login&apos;, LoginHandler),</span><br><span class="line">    (r&apos;/home&apos;, HomeHandler),</span><br><span class="line">],)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><h4 id="4-存储session"><a href="#4-存储session" class="headerlink" title="4. 存储session"></a>4. 存储session</h4><ul><li>我们将session放到了一个字典里，只是放到了内存里，然而我们不想放内存里怎么办呢？为了提高用户的需求的灵活性，我们可以将存储使用类实现，使其可以放入缓存，内存，数据库等你想放的地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">import time</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">class Cache(object):</span><br><span class="line">    def __int__(self):</span><br><span class="line">        self.container = &#123;&#125;</span><br><span class="line">    def __contains__(self, item):</span><br><span class="line">        return  item in self.container</span><br><span class="line">    def open(self):</span><br><span class="line">        pass</span><br><span class="line">    def initial(self,random_str):</span><br><span class="line">        self.container[random_str] = &#123;&#125;</span><br><span class="line">    def close(self):</span><br><span class="line">        pass</span><br><span class="line">    def get(self,random_str,key):</span><br><span class="line">        self.container[random_str].get(key)</span><br><span class="line">    def set(self,random_str,key,value):</span><br><span class="line">        self.container[random_str][key] = value</span><br><span class="line">    def delete(self,random_str,key):</span><br><span class="line">        del self.container[random_str][key]</span><br><span class="line">    def clear(self,random_str,):</span><br><span class="line">        del self.container[random_str]</span><br><span class="line"></span><br><span class="line">class Memcache(object):</span><br><span class="line">    def __int__(self):</span><br><span class="line">        self.container = &#123;&#125;</span><br><span class="line">    # 适用性更广考虑才加上的open（）和close（）函数，更严谨</span><br><span class="line">    def open(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        pass</span><br><span class="line">    def get(self):</span><br><span class="line">        pass</span><br><span class="line">    def set(self):</span><br><span class="line">        pass</span><br><span class="line">    def delete(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"># 是为了方便更换，想放入什么里面直接更改这个引用就可以</span><br><span class="line">P = Cache</span><br><span class="line"></span><br><span class="line">class Session():</span><br><span class="line">    # self，谁调用这个函数，self就是谁</span><br><span class="line">    #这个self就是MainHandler对象，可以将这个self传递给Bar（）</span><br><span class="line">    def __init__(self,handler):</span><br><span class="line">        self.handler = handler</span><br><span class="line">        self.random_str = None</span><br><span class="line">        self.ppp = P()</span><br><span class="line">        self.ppp.open()</span><br><span class="line"></span><br><span class="line">        # 去用户请求信息中获取session_id ，如果没有就是新用户或者是没有登陆</span><br><span class="line">        client_random_str = self.handler.get_cookie(&apos;session_id&apos;)</span><br><span class="line">        if not client_random_str:</span><br><span class="line">            # 新用户</span><br><span class="line">            self.random_str = self.create_random_str()</span><br><span class="line">            # 添加到数据库中一个数据</span><br><span class="line">            self.ppp.initial(self.random_str)</span><br><span class="line">        else:</span><br><span class="line">            # 判断是否是合法的session</span><br><span class="line">            if client_random_str in self.ppp:</span><br><span class="line">                # 老用户</span><br><span class="line">                self.random_str = client_random_str</span><br><span class="line">            else:</span><br><span class="line">                # 非法用户</span><br><span class="line">                self.random_str = self.create_random_str()</span><br><span class="line">                # 添加一个数据</span><br><span class="line">                self.ppp.initial(self.random_str)</span><br><span class="line">        # 设置更新时间</span><br><span class="line">        ctime = time.time()</span><br><span class="line">        self.handler.set_cookie(&apos;session_id&apos;,self.random_str,expires=ctime+1800) # 超时时间</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> # 生成随机的字符串,md5摘要</span><br><span class="line">    def create_random_str(self):</span><br><span class="line">        v = str(time.time())</span><br><span class="line">        m = hashlib.md5()</span><br><span class="line">        m.update(bytes(v,encoding=&apos;utf-8&apos;))</span><br><span class="line">        return m.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        self.ppp.set(self.random_str,key,value)</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        v = self.ppp.get(self.random_str,key)</span><br><span class="line">        self.ppp.close()</span><br><span class="line">        return v</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        self.ppp.delete(self.random_str,key)</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line">    #清空</span><br><span class="line">    def clear(self):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        self.ppp.clear(self.random_str,)</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.session = Session(self)</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HomeHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        print(&apos;home&apos;)</span><br><span class="line">        user = self.session[&apos;uuuu&apos;]</span><br><span class="line">        if not user:</span><br><span class="line">            self.redirect(&apos;https://www.baidu.com&apos;)</span><br><span class="line">        else:</span><br><span class="line">            self.write(user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LoginHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.session[&apos;uuuu&apos;] = &apos;root&apos;</span><br><span class="line">        self.redirect(&apos;/home&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&apos;/login&apos;, LoginHandler),</span><br><span class="line">    (r&apos;/home&apos;, HomeHandler),</span><br><span class="line">],)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><ul><li>这样我们的自定义session会话就完成啦，快快使用一下吧！:yum:</li></ul><blockquote><p>有什么不正确的地方欢迎指点哟！:kissing_heart:<br>邮箱：<a href="mailto:cyss428@163.com" target="_blank" rel="noopener">cyss428@163.com</a></p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>github可以添加表情啦~</title>
      <link href="/2018/03/22/github/"/>
      <url>/2018/03/22/github/</url>
      <content type="html"><![CDATA[<h3 id="提升github的逼格"><a href="#提升github的逼格" class="headerlink" title="提升github的逼格"></a>提升github的逼格</h3><h5 id="github上可以添加表情啦，"><a href="#github上可以添加表情啦，" class="headerlink" title="github上可以添加表情啦，"></a>github上可以添加表情啦，</h5><ul><li><p>在github上插入表情的使用方法：</p><ul><li>使用方法为前后冒号包围表情代号的句法。<figure class="highlight plain"><figcaption><span>会显示成对应的表情，所以你在提交代码的时候可以这样写提交信息：`</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git commit –m ‘commit some changes :blush:’</span><br><span class="line">\</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表情列表</p></li></ul><p><a href="https://github.com/yuansuixin/emoji-list" target="_blank" rel="noopener">表情大全</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>数据分析----pandas数据处理</title>
      <link href="/2018/02/13/pandas-data/"/>
      <url>/2018/02/13/pandas-data/</url>
      <content type="html"><![CDATA[<h2 id="1、删除重复元素"><a href="#1、删除重复元素" class="headerlink" title="1、删除重复元素[]"></a>1、删除重复元素[]</h2><p>使用duplicated()函数检测重复的行，返回元素为布尔类型的Series对象，每个元素对应一行，如果该行不是第一次出现，则元素为True</p><ul><li><p>使用drop_duplicates()函数删除重复的行</p></li><li><p>使用duplicate()函数查看重复的行</p></li></ul><p>如果使用<code>pd.concat([df1,df2],axis = 1)</code>生成新的DataFrame，新的df中columns相同，使用duplicate()和drop_duplicates()都会出问题</p><ol><li>映射<br>映射的含义：创建一个映射关系列表，把values元素和一个特定的标签或者字符串绑定</li></ol><p>包含三种操作：</p><ul><li>replace()函数：替换元素</li><li>最重要：map()函数：新建一列</li><li>rename()函数：替换索引</li></ul><h3 id="1-replace-函数：替换元素"><a href="#1-replace-函数：替换元素" class="headerlink" title="1) replace()函数：替换元素"></a>1) replace()函数：替换元素</h3><p>使用replace()函数，对values进行替换操作</p><p>Series替换操作</p><ul><li>单值替换<ul><li>普通替换</li><li>字典替换</li></ul></li><li>多值替换<ul><li>列表替换</li><li>字典替换（推荐）</li></ul></li></ul><p>Series参数说明：</p><ul><li>method：对指定的值使用相邻的值填充</li><li>limit：设定填充次数</li></ul><p>DataFrame替换操作</p><ul><li>单值替换<ul><li>普通替换</li><li>按列指定单值替换{列标签：替换值}</li></ul></li><li>多值替换<ul><li>列表替换</li><li>单字典替换（推荐）</li></ul></li></ul><p><strong>注意</strong>：DataFrame中，无法使用method和limit参数</p><h3 id="2-map-函数：新建一列"><a href="#2-map-函数：新建一列" class="headerlink" title="2) map()函数：新建一列"></a>2) map()函数：新建一列</h3><ul><li>map()可以映射新一列数据</li><li>map()中可以使用lambd表达式</li><li>map()中可以使用方法，可以是自定义的方法<br><strong>注意:</strong> </li><li>map()中不能使用sum之类的函数，for循环</li><li>map(字典) 字典的键要足以匹配所有的数据，否则出现NaN<h3 id="3-transform-和map-类似"><a href="#3-transform-和map-类似" class="headerlink" title="3)transform()和map()类似"></a>3)transform()和map()类似</h3></li><li>transform()参数只能是函数，不能是字典<h3 id="4-rename-函数：替换索引"><a href="#4-rename-函数：替换索引" class="headerlink" title="4) rename()函数：替换索引"></a>4) rename()函数：替换索引</h3>仍然是新建一个字典<br>使用rename()函数替换行索引</li><li>mapper替换所有索引</li><li>index 替换行索引</li><li>columns 替换列索引</li><li>level 指定多维索引的维度</li></ul><h2 id="3-使用聚合操作对数据异常值检测和过滤"><a href="#3-使用聚合操作对数据异常值检测和过滤" class="headerlink" title="3. 使用聚合操作对数据异常值检测和过滤"></a>3. 使用聚合操作对数据异常值检测和过滤</h2><ul><li><p>使用describe()函数查看每一列的描述性统计量</p></li><li><p>使用std()函数可以求得DataFrame对象每一列的标准差，默认是求列</p></li><li><p>根据每一列或行的标准差，对DataFrame元素进行过滤。</p></li><li><p>借助any()或all()函数, 测试是否有True，有一个或以上返回True，反之返回False</p></li><li><p>对每一列应用筛选条件,去除标准差太大的数据</p></li><li><p>删除特定索引<code>df.drop(labels,inplace = True)</code></p></li></ul><h2 id="4-排序"><a href="#4-排序" class="headerlink" title="4. 排序"></a>4. 排序</h2><p>使用.take()函数排序</p><ul><li>take()函数接受一个索引列表，用数字表示</li><li>eg:df.take([1,3,4,2,5])<br>可以借助np.random.permutation()函数随机排序</li></ul><p>随机抽样<br>当DataFrame规模足够大时，直接使用np.random.randint()函数，就配合take()函数实现随机抽样</p><h3 id="5-数据分类处理【重点】"><a href="#5-数据分类处理【重点】" class="headerlink" title="5. 数据分类处理【重点】"></a>5. 数据分类处理【重点】</h3><p>数据聚合是数据处理的最后一步，通常是要使每一个数组生成一个单一的数值。</p><p>数据分类处理：</p><ul><li>分组：先把数据分为几组<br>用函数处理：为不同组的数据应用不同的函数以转换数据</li><li><p>合并：把不同组得到的结果合并起来<br>数据分类处理的核心：</p><ul><li>groupby()函数</li><li>groups属性查看分组情况</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(&#123;&apos;item&apos;:[&apos;苹果&apos;,&apos;香蕉&apos;,&apos;橘子&apos;,&apos;香蕉&apos;,&apos;橘子&apos;,&apos;苹果&apos;], &apos;price&apos;:[4,3,3,2.5,4,2], &apos;color&apos;:[&apos;red&apos;,&apos;yellow&apos;,&apos;yellow&apos;,&apos;green&apos;,&apos;green&apos;,&apos;green&apos;], &apos;weight&apos;:[12,20,50,30,20,44]&#125;)</span><br></pre></td></tr></table></figure><p>根据item分组,查看结果<br>获取weight的总和<br>把总和跟df进行merge合并<br>使用列表进行多列分组，得到的结果是多层级索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">假设菜市场张大妈在卖菜，有以下属性：</span><br><span class="line">菜品(item)：萝卜，白菜，辣椒，冬瓜</span><br><span class="line">颜色(color)：白，青，红</span><br><span class="line">重量(weight)</span><br><span class="line">价格(price)</span><br><span class="line"></span><br><span class="line">以属性为列索引，创建一个DataFrame对象df</span><br><span class="line">data = &#123;</span><br><span class="line">    &apos;菜品&apos;:[&apos;萝卜&apos;,&apos;萝卜&apos;,&apos;白菜&apos;,&apos;辣椒&apos;,&apos;白菜&apos;,&apos;辣椒&apos;,&apos;萝卜&apos;,&apos;冬瓜&apos;],</span><br><span class="line">    &apos;color&apos;:[&apos;white&apos;,&apos;red&apos;,&apos;white&apos;,&apos;red&apos;,&apos;green&apos;,&apos;green&apos;,&apos;green&apos;,&apos;green&apos;],</span><br><span class="line">    &apos;price&apos;:[2,1.5,1,4,3,5,8,2.3],</span><br><span class="line">    &apos;weight&apos;:[100,50,30,50,36,80,75,40],</span><br><span class="line">&#125;</span><br><span class="line">df = DataFrame(data=data)</span><br><span class="line">对df进行聚合操作，求出颜色为白色的价格总和</span><br><span class="line">df.groupby(&apos;color&apos;)[&apos;price&apos;].sum().loc[&apos;white&apos;]</span><br><span class="line">对df进行聚合操作，求出萝卜的所有重量(包括白萝卜，胡萝卜，青萝卜）以及平均价格</span><br><span class="line">total_weight = DataFrame(df.groupby(&apos;菜品&apos;)[&apos;weight&apos;].sum())</span><br><span class="line">mean_price = DataFrame(df.groupby(&apos;菜品&apos;)[&apos;price&apos;].mean())</span><br><span class="line">使用merge合并总重量及平均价格</span><br><span class="line">table1 = pd.merge(df,mean_price,left_on=&apos;菜品&apos;,right_index=True,suffixes=[&apos;&apos;,&apos;_mean&apos;])</span><br><span class="line">pd.merge(table1,total_weight,left_on=&apos;菜品&apos;,right_index=True,suffixes=[&apos;&apos;,&apos;_sum&apos;]).rename(columns=&#123;&apos;weight_sum&apos;:&apos;toal&apos;&#125;)</span><br></pre></td></tr></table></figure><h2 id="6-0-高级数据聚合"><a href="#6-0-高级数据聚合" class="headerlink" title="6.0 高级数据聚合"></a>6.0 高级数据聚合</h2><p>使用groupby分组后，也可以使用transform和apply提供自定义函数实现更多的运算</p><ul><li>df.groupby(‘item’)[‘price’].sum() &lt;==&gt; df.groupby(‘item’)[‘price’].apply(sum)</li><li>transform和apply都会进行运算，在transform或者apply中传入函数名即可</li><li>transform和apply也可以传入一个lambda表达式<br><strong>注意</strong></li><li>transform 会自动匹配列索引返回值，不去重</li><li>apply 会根据分组情况返回值，去重</li></ul><p><a href="https://github.com/yuansuixin/learning_data" title="数据处理" target="_blank" rel="noopener">数据处理IPython下载</a></p><p><a href="https://github.com/yuansuixin/Apple-Stock-DataAnalysis" title="Apple公司相关数据分析" target="_blank" rel="noopener">Apple公司相关数据分析</a></p><p><a href="https://github.com/yuansuixin/USA-Election-DataAnalysis" title="美国竞选数据分析" target="_blank" rel="noopener">美国竞选数据分析</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>会话技术cookie和session的区别和联系</title>
      <link href="/2018/02/12/cookie-session/"/>
      <url>/2018/02/12/cookie-session/</url>
      <content type="html"><![CDATA[<h1 id="COOKIE-和-SESSION-有什么区别和联系"><a href="#COOKIE-和-SESSION-有什么区别和联系" class="headerlink" title="COOKIE 和 SESSION 有什么区别和联系"></a>COOKIE 和 SESSION 有什么区别和联系</h1><ul><li><p>存储位置</p><ul><li>cookie 保存在客户端中</li><li>session 保存在服务器端</li></ul></li><li><p>Session 是服务器保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</p></li><li>Cookie 是客户端保存用户信息的一个机制，用来记录用户的一些信息，也是实现Session的一个方式，用于存储session_id ,存储在用户的浏览器中</li></ul><h2 id="不要混淆-cookie-和-session-实现"><a href="#不要混淆-cookie-和-session-实现" class="headerlink" title="不要混淆 cookie 和 session 实现"></a>不要混淆 cookie 和 session 实现</h2><ul><li>本身 session 是一个抽象的概念，将user agent 和server 之前一对一的交互，抽象为’会话‘，进而衍生出’会话状态‘，也就是session的概念</li><li>而 cookie 是一个实际存在的东西，http 协议中定义在header中的字段，可以认为是 session 的后端无状态实现</li><li>现在的 session ，是为了绕开 cookie 的各种限制，通常借助与cookie本身和后端存储实现的，一种更高级的状态实现</li></ul><ul><li>session、cookie、token会话技术</li></ul><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201833011500.png" alt="会话"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jupyter（IPython）相关知识点</title>
      <link href="/2018/02/03/ipython/"/>
      <url>/2018/02/03/ipython/</url>
      <content type="html"><![CDATA[<h2 id="一、启动程序"><a href="#一、启动程序" class="headerlink" title="一、启动程序"></a>一、启动程序</h2><p>执行以下命令：</p><blockquote><p>jupyter notebook</p></blockquote><p>[NotebookApp] Serving notebooks from local directory: /home/nanfengpo</p><p>[NotebookApp] 0 active kernels </p><p>[NotebookApp] The IPython Notebook is running at: <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p><p>[NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</p><p>注意以下几点：</p><ul><li>打开地址为当前bash的目录，默认的根目录</li><li>浏览器地址为<a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></li><li>通过control -C终止jupyter程序</li></ul><p>几个基本操作：</p><ul><li>双击D：删除当前cell</li><li>单击M：转为markdown文档</li><li>markdown文档下运行变为预览模式</li></ul><h2 id="二、IPython的帮助文档"><a href="#二、IPython的帮助文档" class="headerlink" title="二、IPython的帮助文档"></a>二、IPython的帮助文档</h2><h4 id="1-使用help（）"><a href="#1-使用help（）" class="headerlink" title="1.使用help（）"></a>1.使用help（）</h4><p>通过以下命令来获得帮助文档：</p><blockquote><p>help(len)</p></blockquote><p>Help on built-in function len in module builtins:</p><p>len(obj, /)<br>    Return the number of items in a container.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(len)</span><br></pre></td></tr></table></figure></p><h4 id="2-使用？"><a href="#2-使用？" class="headerlink" title="2.使用？"></a>2.使用？</h4><blockquote><p>len？</p></blockquote><p>还可以应用到自定义的变量和自定义的函数上来返回帮助文档</p><p>此外，使用两个??可以把函数的源代码显示出来</p><h4 id="3-tab自动补全"><a href="#3-tab自动补全" class="headerlink" title="3.tab自动补全"></a>3.tab自动补全</h4><h2 id="三、IPython魔法命令"><a href="#三、IPython魔法命令" class="headerlink" title="三、IPython魔法命令"></a>三、IPython魔法命令</h2><h4 id="1-运行外部的Python文件"><a href="#1-运行外部的Python文件" class="headerlink" title="1. 运行外部的Python文件"></a>1. 运行外部的Python文件</h4><p>使用下面命令运行外部python文件（默认是当前目录，最好加上绝对路径）</p><blockquote><p>%run *.py</p></blockquote><p>例如在当前目录下有一个myscript.py文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    &quot;&quot;&quot;square a number&quot;&quot;&quot;</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line">for N in range(1, 4):</span><br><span class="line">    print(N, &quot;squared is&quot;, square(N))</span><br></pre></td></tr></table></figure></p><p>我们可以通过下面命令执行它：</p><blockquote><p>%run myscript.py</p></blockquote><p>尤其要注意的是，当我们使用魔法命令执行了一个外部文件时，该文件的函数就能在当前会话中使用</p><blockquote><p>square(5)</p></blockquote><h4 id="2-运行计时"><a href="#2-运行计时" class="headerlink" title="2.运行计时"></a>2.运行计时</h4><p>用下面命令计算statement的运行时间：</p><blockquote><p>%time statement</p></blockquote><p>用下面命令计算statement的平均运行时间：   </p><blockquote><p>%timeit statement</p></blockquote><p>timeit会多次运行statement，最后得到一个更为精准的预期运行时间</p><p>可以使用两个百分号来测试多行代码的平均运行时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">statement1</span><br><span class="line">statement2</span><br><span class="line">statement3</span><br></pre></td></tr></table></figure></p><p>记住：</p><ul><li>%time一般用于耗时长的代码段</li><li>%timeit一般用于耗时短的代码段</li></ul><h4 id="3-查看当前会话中的所有变量和函数"><a href="#3-查看当前会话中的所有变量和函数" class="headerlink" title="3. 查看当前会话中的所有变量和函数"></a>3. 查看当前会话中的所有变量和函数</h4><p>快速查看当前会话的所有变量与函数名称：</p><blockquote><p>%who</p></blockquote><p>查看当前会话的所有变量与函数名称的详细信息：</p><blockquote><p>%whos</p></blockquote><p>返回一个字符串列表，里面元素是当前会话的所有变量与函数名称：</p><blockquote><p>%who_ls</p></blockquote><h4 id="4-执行Linux指令"><a href="#4-执行Linux指令" class="headerlink" title="4.执行Linux指令"></a>4.执行Linux指令</h4><p>在Linux指令之前加上  <font size="5" color="green">!</font>，即可在ipython当中执行Linux指令。<br>注意，会将标准输出以字符串形式返回</p><h4 id="5-更多的魔法命令"><a href="#5-更多的魔法命令" class="headerlink" title="5. 更多的魔法命令"></a>5. 更多的魔法命令</h4><p>列出所有魔法命令</p><blockquote><p>lsmagic</p></blockquote><h2 id="四、IPython输入输出历史"><a href="#四、IPython输入输出历史" class="headerlink" title="四、IPython输入输出历史"></a>四、IPython输入输出历史</h2><h4 id="1-使用in、out调用输入输出历史"><a href="#1-使用in、out调用输入输出历史" class="headerlink" title="1. 使用in、out调用输入输出历史"></a>1. 使用in、out调用输入输出历史</h4><p>In返回一个字符串列表，里面是所有输入命令的字符串<br>Out返回一个含有输出的命令的序号及其输出组成的字典<br>两者皆可以通过索引获取元素</p><h4 id="2-使用下划线表示输出"><a href="#2-使用下划线表示输出" class="headerlink" title="2. 使用下划线表示输出"></a>2. 使用下划线表示输出</h4><p>“_”表示上一个输出<br>“_2”表示Out[2]</p><h2 id="五、jupyter-notebook的快捷键"><a href="#五、jupyter-notebook的快捷键" class="headerlink" title="五、jupyter-notebook的快捷键"></a>五、jupyter-notebook的快捷键</h2><p><a href="https://yuansuixin.github.io/archives/2018/04/" title="快捷键">jupyter-notebook快捷键</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>机器学习----朴素贝叶斯模型</title>
      <link href="/2018/01/17/bayes/"/>
      <url>/2018/01/17/bayes/</url>
      <content type="html"><![CDATA[<h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><h2 id="【关键词】"><a href="#【关键词】" class="headerlink" title="【关键词】"></a>【关键词】</h2><ul><li>朴素：独立性假设</li><li>贝叶斯公式</li></ul><p>优点：</p><ul><li>朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率；</li><li>对小规模的数据表现很好；</li><li>能处理多分类任务，适合增量式训练；</li><li>对缺失数据不太敏感，算法也比较简单，常用于文本分类</li></ul><p>缺点：</p><ul><li>只能用于分类问题</li><li>需要计算先验概率；</li><li>分类决策存在错误率；</li><li>对输入数据的表达形式很敏感</li></ul><h2 id="一、朴素贝叶斯原理"><a href="#一、朴素贝叶斯原理" class="headerlink" title="一、朴素贝叶斯原理"></a>一、朴素贝叶斯原理</h2><p>朴素贝叶斯算法是一个典型的统计学习方法，主要理论基础就是一个贝叶斯公式，贝叶斯公式的基本定义如下：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201025.jpg" alt="Untitled-1-1"></p><p>这个公式虽然看上去简单，但它却能总结历史，预知未来：</p><ul><li>公式的右边是总结历史</li><li>公式的左边是预知未来</li></ul><p>如果把Y看成类别，X看成特征，P(Yk|X)就是在已知特征X的情况下求Yk类别的概率，而对P(Yk|X)的计算又全部转化到类别Yk的特征分布上来。</p><p>举个例子，大学的时候，某男生经常去图书室晚自习，发现他喜欢的那个女生也常去那个自习室，心中窃喜，于是每天买点好吃点在那个自习室蹲点等她来，可是人家女生不一定每天都来，眼看天气渐渐炎热，图书馆又不开空调，如果那个女生没有去自修室，该男生也就不去，每次男生鼓足勇气说：“嘿，你明天还来不？”,“啊，不知道，看情况”。</p><p>然后该男生每天就把她去自习室与否以及一些其他情况做一下记录，用Y表示该女生是否去自习室，即Y={去，不去}，X是跟去自修室有关联的一系列条件，比如当天上了哪门主课，蹲点统计了一段时间后，该男生打算今天不再蹲点，而是先预测一下她会不会去，现在已经知道了今天上了常微分方法这么主课，于是计算P(Y=去|常微分方程)与P(Y=不去|常微分方程)，看哪个概率大，如果P(Y=去|常微分方程) &gt;P(Y=不去|常微分方程)，那这个男生不管多热都屁颠屁颠去自习室了，否则不就去自习室受罪了。P(Y=去|常微分方程)的计算可以转为计算以前她去的情况下，那天主课是常微分的概率P(常微分方程|Y=去)，注意公式右边的分母对每个类别（去/不去）都是一样的，所以计算的时候忽略掉分母，这样虽然得到的概率值已经不再是0~1之间，但是通过比较大小还是能选择类别。</p><p>后来他发现还有一些其他条件可以挖，比如当天星期几、当天的天气，以及上一次与她在自修室的气氛，统计了一段时间后，该男子一计算，发现不好算了，因为总结历史的公式：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201032.jpg" alt="Untitled-1-2"></p><p>这里n=3，x(1)表示主课，x(2)表示天气，x(3)表示星期几，x(4)表示气氛，Y仍然是{去，不去}，现在主课有8门，天气有晴、雨、阴三种、气氛有A+,A,B+,B，C五种，那么总共需要估计的参数有8×3×7×5×2=1680个，每天只能收集到一条数据，那么等凑齐1680条数据，大学都毕业了，男生大呼不妙，于是做了一个独立性假设，假设这些影响她去自习室的原因是独立互不相关的，于是：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201037.jpg" alt="Untitled-1-3"></p><p>有了这个独立假设后，需要估计的参数就变为，(8+3+7+5)×2 = 46个了，而且每天收集的一条数据，可以提供4个参数，这样该男生就预测越来越准了。</p><p>朴素的概念：独立性假设，假设各个特征之间是独立不相关的。</p><h3 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h3><p>讲了上面的小故事，我们来朴素贝叶斯分类器的表示形式：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201045.jpg" alt="Untitled-1-4"></p><p>当特征为为x时，计算所有类别的条件概率，选取条件概率最大的类别作为待分类的类别。由于上公式的分母对每个类别都是一样的，因此计算时可以不考虑分母，即</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201049.jpg" alt="Untitled-1-5"></p><p>朴素贝叶斯的朴素体现在其对各个条件的独立性假设上，加上独立假设后，大大减少了参数假设空间。</p><h3 id="在文本分类上的应用"><a href="#在文本分类上的应用" class="headerlink" title="在文本分类上的应用"></a>在文本分类上的应用</h3><p>文本分类的应用很多，比如垃圾邮件和垃圾短信的过滤就是一个2分类问题，新闻分类、文本情感分析等都可以看成是文本分类问题，分类问题由两步组成：训练和预测，要建立一个分类模型，至少需要有一个训练数据集。贝叶斯模型可以很自然地应用到文本分类上：现在有一篇文档d（Document），判断它属于哪个类别ck，只需要计算文档d属于哪一个类别的概率最大：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201059.jpg" alt="Untitled-1-6"></p><p>在分类问题中，我们并不是把所有的特征都用上，对一篇文档d，我们只用其中的部分特征词项t1,t2,…,tnd（nd表示d中的总词条数目），因为很多词项对分类是没有价值的，比如一些停用词“的,是,在”在每个类别中都会出现，这个词项还会模糊分类的决策面，关于特征词的选取，我的这篇文章有介绍。用特征词项表示文档后，计算文档d的类别转化为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841720114.jpg" alt="Untitled-1-7"></p><p>注意P(Ck|d)只是正比于后面那部分公式，完整的计算还有一个分母，但我们前面讨论了，对每个类别而已分母都是一样的，于是在我们只需要计算分子就能够进行分类了。实际的计算过程中，多个概率值P(tj|ck)的连乘很容易下溢出为0，因此转化为对数计算，连乘就变成了累加：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201116.jpg" alt="Untitled-1-8"></p><p>我们只需要从训练数据集中，计算每一个类别的出现概率P(ck)和每一个类别中各个特征词项的概率P(tj|ck)，而这些概率值的计算都采用最大似然估计，说到底<em>就是统计每个词在各个类别中出现的次数和各个类别的文档的数目</em>：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201136.jpg" alt="Untitled-1-9"><br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201142.jpg" alt="Untitled-1-10"></p><h2 id="二、3种贝叶斯模型"><a href="#二、3种贝叶斯模型" class="headerlink" title="二、3种贝叶斯模型"></a>二、3种贝叶斯模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.9</span>*<span class="number">2</span>/(<span class="number">365</span>*<span class="number">20</span>))/(<span class="number">3</span>/<span class="number">7</span>)*<span class="number">10000</span></span><br></pre></td></tr></table></figure><pre><code>5.75342465753424</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">7</span>/<span class="number">10</span>)*(<span class="number">1</span>/<span class="number">2</span>)/(<span class="number">8</span>/<span class="number">20</span>)</span><br></pre></td></tr></table></figure><pre><code>0.8749999999999999</code></pre><h3 id="1、高斯分布朴素贝叶斯"><a href="#1、高斯分布朴素贝叶斯" class="headerlink" title="1、高斯分布朴素贝叶斯"></a>1、高斯分布朴素贝叶斯</h3><p>高斯分布就是正态分布</p><p>【用途】用于一般分类问题</p><p>使用自带的鸢尾花数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">muNB = GaussianNB()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris = load_iris()</span><br><span class="line">data = iris.data</span><br><span class="line">target = iris.target</span><br><span class="line">samples = data[:,:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">muNB.fit(samples,target)</span><br><span class="line"></span><br><span class="line">xmin,xmax = samples[:,<span class="number">0</span>].min(),samples[:,<span class="number">0</span>].max()</span><br><span class="line">ymin,ymax = samples[:,<span class="number">1</span>].min(),samples[:,<span class="number">1</span>].max()</span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">300</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br><span class="line"></span><br><span class="line">y_ = muNB.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">colormap = ListedColormap([<span class="string">'#00aaff'</span>,<span class="string">'#aa00ff'</span>,<span class="string">'#ffaa00'</span>])</span><br><span class="line"></span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target,cmap=colormap)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201210.png" alt="Untitled-1-19"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line">logistic = LogisticRegression()</span><br><span class="line">tree = DecisionTreeClassifier()</span><br><span class="line"></span><br><span class="line">knn.fit(samples,target)</span><br><span class="line">logistic.fit(samples,target)</span><br><span class="line">tree.fit(samples,target)</span><br><span class="line"></span><br><span class="line">y1_ = knn.predict(X_test)</span><br><span class="line">y2_ = logistic.predict(X_test)</span><br><span class="line">y3_ = tree.predict(X_test)</span><br><span class="line"></span><br><span class="line">results = [y_,y1_,y2_,y3_]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">titles = [<span class="string">'MultiNB'</span>,<span class="string">'KNN'</span>,<span class="string">'Logistic'</span>,<span class="string">'DecisionTree'</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    axes = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>)</span><br><span class="line">    axes.set_title(titles[i])</span><br><span class="line">    y = results[i]</span><br><span class="line">    axes.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y)</span><br><span class="line">    axes.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target,cmap=colormap)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201216.png" alt="Untitled-1-21"></p><h3 id="2、多项式分布朴素贝叶斯"><a href="#2、多项式分布朴素贝叶斯" class="headerlink" title="2、多项式分布朴素贝叶斯"></a>2、多项式分布朴素贝叶斯</h3><p>多项式分布：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841720125.jpg" alt="Untitled-1-12"></p><p>【用途】适用于文本数据（特征表示的是次数，例如某个词语的出现次数）</p><h4 id="例：延续上面，使用鸢尾花数据"><a href="#例：延续上面，使用鸢尾花数据" class="headerlink" title="例：延续上面，使用鸢尾花数据"></a>例：延续上面，使用鸢尾花数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理文本分类</span></span><br><span class="line"></span><br><span class="line">data = pd.read_table(<span class="string">'../data/SMSSpamCollection'</span>,header=<span class="keyword">None</span>)</span><br><span class="line">samples = data[<span class="number">1</span>]</span><br><span class="line">target = data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于将文本内容转换成词频格式的类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">tf = TfidfVectorizer()</span><br><span class="line"><span class="comment"># tf对象也需要进行训练</span></span><br><span class="line"><span class="comment"># tf_samples = tf.fit_transform(samples)</span></span><br><span class="line"><span class="comment"># 上面的代码可以改写成</span></span><br><span class="line">tf.fit(samples)</span><br><span class="line"><span class="comment"># 新的数据仍需要使用训练过的tf对象进行转换</span></span><br><span class="line">tf_sampels = tf.transform(samples)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf_samples</span><br></pre></td></tr></table></figure><pre><code>&lt;5572x8713 sparse matrix of type &apos;&lt;class &apos;numpy.float64&apos;&gt;&apos;    with 74169 stored elements in Compressed Sparse Row format&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line">munb = MultinomialNB()</span><br><span class="line"></span><br><span class="line">munb.fit(tf_samples,target)</span><br></pre></td></tr></table></figure><pre><code>MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不能直接使用文本集进行训练</span></span><br><span class="line"><span class="comment"># munb.fit(samples,target)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X_train,X_test,y_train,y_test = train_test_split(tf_samples,target,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">munb.fit(X_train,y_train)</span><br><span class="line">y_ = munb.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">munb.score(X_test,y_test)</span><br></pre></td></tr></table></figure><pre><code>0.96412556053811</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="string">" £1000 or a 4* holiday (flights inc),TEL.9110098112"</span>,</span><br><span class="line"><span class="string">"You are a winner U have been specially selected 2 receive £1000 or a 4* holiday (flights inc)"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf_test = tf.transform(test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">munb.predict(tf_test)</span><br></pre></td></tr></table></figure><pre><code>array([&apos;spam&apos;, &apos;spam&apos;], dtype=&apos;&lt;U4&apos;)</code></pre><h3 id="3、伯努利分布朴素贝叶斯"><a href="#3、伯努利分布朴素贝叶斯" class="headerlink" title="3、伯努利分布朴素贝叶斯"></a>3、伯努利分布朴素贝叶斯</h3><p>伯努利分布：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201147.png" alt="Untitled-1-11"></p><p>【用途】适用于伯努利分布，也适用于文本数据（此时特征表示的是是否出现，例如某个词语的出现为1，不出现为0）</p><p>绝大多数情况下表现不如多项式分布，但有的时候伯努利分布表现得要比多项式分布要好，尤其是对于小数量级的文本数据</p><h4 id="例：继续使用鸢尾花数据集"><a href="#例：继续使用鸢尾花数据集" class="headerlink" title="例：继续使用鸢尾花数据集"></a>例：继续使用鸢尾花数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB</span><br><span class="line">iris = load_iris()</span><br><span class="line">data = iris.data</span><br><span class="line">target = iris.target</span><br><span class="line">samples = data[:,:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ber = BernoulliNB()</span><br><span class="line">ber.fit(samples,target)</span><br><span class="line"></span><br><span class="line">xmin,xmax = samples[:,<span class="number">0</span>].min(),samples[:,<span class="number">0</span>].max()</span><br><span class="line">ymin,ymax = samples[:,<span class="number">1</span>].min(),samples[:,<span class="number">1</span>].max()</span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">300</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br><span class="line"></span><br><span class="line">y_ = ber.predict(X_test)</span><br><span class="line"></span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target,cmap=colormap)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417201222.png" alt="Untitled-1-39"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理文本分类</span></span><br><span class="line">data = pd.read_table(<span class="string">'../data/SMSSpamCollection'</span>,header=<span class="keyword">None</span>)</span><br><span class="line">train = data[<span class="number">1</span>]</span><br><span class="line">target = data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">tf = TfidfVectorizer()</span><br><span class="line">tf_train = tf.fit_transform(train)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train,X_test,y_train,y_test = train_test_split(tf_train,target,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bernuli = BernoulliNB()</span><br><span class="line">bernuli.fit(X_train,y_train)</span><br><span class="line">y_ = bernuli.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bernuli.score(X_test,y_test)</span><br></pre></td></tr></table></figure><pre><code>0.9847533632286996</code></pre><h2 id="三、文本分类实战"><a href="#三、文本分类实战" class="headerlink" title="三、文本分类实战"></a>三、文本分类实战</h2><p>对短信进行二分类，数据为SMSSpamCollection</p><p>导包<br>导入sklearn.feature_extraction.text.TfidfVectorizer用于转换字符串<br>读取短信数据</p><h4 id="tf-fit-transform"><a href="#tf-fit-transform" class="headerlink" title="tf.fit_transform()"></a>tf.fit_transform()</h4><ul><li>参数必须是字符串的一维数组（比如列表或者Series）</li><li>返回的是一个稀疏矩阵类型的对象，行数为样本数，列数为所有出现的单词统计个数。</li></ul><p>这里输入data[1]是Series类型，返回的是一个5572x8713 sparse matrix<br>其中5572是data[1]</p><p>训练数据</p><p>预测数据，使用tf.transform([‘xx’])进行转换生成测试数据</p><h2 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h2><h4 id="对email进行二分类，两种邮件分别在ham和spam目录下"><a href="#对email进行二分类，两种邮件分别在ham和spam目录下" class="headerlink" title="对email进行二分类，两种邮件分别在ham和spam目录下"></a>对email进行二分类，两种邮件分别在ham和spam目录下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.read_csv(<span class="string">'../data/email/spam/1.txt'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_message</span><span class="params">(categoray)</span>:</span></span><br><span class="line">    samples = []</span><br><span class="line">    target = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line"><span class="comment">#         utf-8 gbk 加入errors可以避免错误</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'../data/email/%s/%d.txt'</span>%(categoray,i),<span class="string">'r'</span>,errors = <span class="string">'ignore'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            data = fp.read()</span><br><span class="line">            samples.append(data)</span><br><span class="line">            target.append(categoray)</span><br><span class="line">    <span class="keyword">return</span> (samples,target)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train1,target1 = load_message(<span class="string">'spam'</span>)</span><br><span class="line">train2,target2 = load_message(<span class="string">'ham'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train = train1 + train2</span><br><span class="line">target = target1 + target2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf = TfidfVectorizer()</span><br><span class="line">tf_train = tf.fit_transform(train)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train,X_test,y_train,y_test = train_test_split(tf_train,target,test_size=<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">munb = MultinomialNB()</span><br><span class="line">bernb = BernoulliNB()</span><br><span class="line"></span><br><span class="line">munb.fit(X_train,y_train)</span><br><span class="line">bernb.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"MultinomialNB score is %f"</span>%munb.score(X_test,y_test))</span><br><span class="line">print(<span class="string">"BernoulliNB score is %f"</span>%bernb.score(X_test,y_test))</span><br></pre></td></tr></table></figure><pre><code>MultinomialNB score is 0.933333BernoulliNB score is 0.933333</code></pre><p><a href="https://github.com/yuansuixin/ML-Bayes" title="源码下载" target="_blank" rel="noopener">源代码下载</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>基于Tornado的异步非阻塞自定义Web框架</title>
      <link href="/2018/01/13/tornado-asynchronous/"/>
      <url>/2018/01/13/tornado-asynchronous/</url>
      <content type="html"><![CDATA[<h1 id="自定义异步非阻塞Web框架"><a href="#自定义异步非阻塞Web框架" class="headerlink" title="自定义异步非阻塞Web框架"></a>自定义异步非阻塞Web框架</h1><h3 id="支持异步非阻塞Web框架–-Tornado，Nodejs"><a href="#支持异步非阻塞Web框架–-Tornado，Nodejs" class="headerlink" title="支持异步非阻塞Web框架– Tornado，Nodejs"></a>支持异步非阻塞Web框架– Tornado，Nodejs</h3><ul><li><p>异步IO模块：<br>  我们作为客户端向服务端发起“并发”请求，select监听socket是否已经有变化<br>  future= Future（）主要的</p><ol><li>挂起当前请求，线程可以处理其他请求</li><li>future设置值，当前挂起的请求返回</li></ol></li><li><p>IO请求不占CPU，计算型需要使用CPU</p></li></ul><ul><li>自定义web框架<ul><li>同步<ul><li>从Socket开始</li><li>使用IO多路复用，当不发请求的时候，其他的可以过来，只是监听有没有变化</li><li>步骤：<ul><li>请求头中获取url，将其处理为字典格式</li><li>去路由中匹配，获取指定的函数</li><li>执行函数，获取返回值</li><li>将返回值send回去</li></ul></li></ul></li><li>异步<ul><li>使用Future（）对象，只要是future对象，来一个请求，只要future的result里面还没有给值，就可以将该请求挂起，仍然可以执行其他的请求，当future对象设置了值的时候，表示该请求结束，断开连接</li><li>使用Future()对象，通过设置超时时间来判断请求是否断开，当请求到来时，不用管它，可以处理其他的请求，当连接的时间超过了预先设定的超时时间的时候，主动断开连接，结束请求，将socket移除</li></ul></li></ul></li></ul><p>说明：<a href="https://yuansuixin.github.io/" title="详细的WebSocket讲解地址">详细的WebSocket讲解地址</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.基本使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from snow import Snow</span><br><span class="line">from snow import HttpResponse</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&apos;OK&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">routes = [</span><br><span class="line">    (r&apos;/index/&apos;, index),</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">app = Snow(routes)</span><br><span class="line">app.run(port=8012)</span><br></pre></td></tr></table></figure><ol><li>异步非阻塞：超时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from snow import Snow</span><br><span class="line">from snow import HttpResponse</span><br><span class="line">from snow import TimeoutFuture</span><br><span class="line"> </span><br><span class="line">request_list = []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def async(request):</span><br><span class="line">    obj = TimeoutFuture(5)</span><br><span class="line">    yield obj</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def home(request):</span><br><span class="line">    return HttpResponse(&apos;home&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">routes = [</span><br><span class="line">    (r&apos;/home/&apos;, home),</span><br><span class="line">    (r&apos;/async/&apos;, async),</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">app = Snow(routes)</span><br><span class="line">app.run(port=8012)</span><br></pre></td></tr></table></figure><ol><li>异步非阻塞，等待<br>基于等待模式可以完成自定制操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from snow import Snow</span><br><span class="line">from snow import HttpResponse</span><br><span class="line">from snow import Future</span><br><span class="line"> </span><br><span class="line">request_list = []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def callback(request, future):</span><br><span class="line">    return HttpResponse(future.value)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def req(request):</span><br><span class="line">    obj = Future(callback=callback)</span><br><span class="line">    request_list.append(obj)</span><br><span class="line">    yield obj</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def stop(request):</span><br><span class="line">    obj = request_list[0]</span><br><span class="line">    del request_list[0]</span><br><span class="line">    obj.set_result(&apos;done&apos;)</span><br><span class="line">    return HttpResponse(&apos;stop&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">routes = [</span><br><span class="line">    (r&apos;/req/&apos;, req),</span><br><span class="line">    (r&apos;/stop/&apos;, stop),</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">app = Snow(routes)</span><br><span class="line">app.run(port=8012)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/yuansuixin/Tornado-Asynchronous-non-blocking" title="源码下载" target="_blank" rel="noopener">源码下载</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import re</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HttpResponse(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    封装响应信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, content=&apos;&apos;):</span><br><span class="line">        self.content = content</span><br><span class="line"></span><br><span class="line">        self.headers = &#123;&#125;</span><br><span class="line">        self.cookies = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def response(self):</span><br><span class="line">        return bytes(self.content, encoding=&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HttpNotFound(HttpResponse):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    404时的错误提示</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(HttpNotFound, self).__init__(&apos;404 Not Found&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HttpRequest(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户封装用户请求信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, conn):</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">        self.header_bytes = bytes()</span><br><span class="line">        self.header_dict = &#123;&#125;</span><br><span class="line">        self.body_bytes = bytes()</span><br><span class="line"></span><br><span class="line">        self.method = &quot;&quot;</span><br><span class="line">        self.url = &quot;&quot;</span><br><span class="line">        self.protocol = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        self.initialize()</span><br><span class="line">        self.initialize_headers()</span><br><span class="line"></span><br><span class="line">    def initialize(self):</span><br><span class="line"></span><br><span class="line">        header_flag = False</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                received = self.conn.recv(8096)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                received = None</span><br><span class="line">            if not received:</span><br><span class="line">                break</span><br><span class="line">            if header_flag:</span><br><span class="line">                self.body_bytes += received</span><br><span class="line">                continue</span><br><span class="line">            temp = received.split(b&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">            if len(temp) == 1:</span><br><span class="line">                self.header_bytes += temp</span><br><span class="line">            else:</span><br><span class="line">                h, b = temp</span><br><span class="line">                self.header_bytes += h</span><br><span class="line">                self.body_bytes += b</span><br><span class="line">                header_flag = True</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def header_str(self):</span><br><span class="line">        return str(self.header_bytes, encoding=&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">    def initialize_headers(self):</span><br><span class="line">        headers = self.header_str.split(&apos;\r\n&apos;)</span><br><span class="line">        first_line = headers[0].split(&apos; &apos;)</span><br><span class="line">        if len(first_line) == 3:</span><br><span class="line">            self.method, self.url, self.protocol = headers[0].split(&apos; &apos;)</span><br><span class="line">            for line in headers:</span><br><span class="line">                kv = line.split(&apos;:&apos;)</span><br><span class="line">                if len(kv) == 2:</span><br><span class="line">                    k, v = kv</span><br><span class="line">                    self.header_dict[k] = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Future(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    异步非阻塞模式时封装回调函数以及是否准备就绪</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, callback):</span><br><span class="line">        self.callback = callback</span><br><span class="line">        self._ready = False</span><br><span class="line">        self.value = None</span><br><span class="line"></span><br><span class="line">    def set_result(self, value=None):</span><br><span class="line">        self.value = value</span><br><span class="line">        self._ready = True</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def ready(self):</span><br><span class="line">        return self._ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TimeoutFuture(Future):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    异步非阻塞超时</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, timeout):</span><br><span class="line">        super(TimeoutFuture, self).__init__(callback=None)</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.start_time = time.time()</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def ready(self):</span><br><span class="line">        current_time = time.time()</span><br><span class="line">        if current_time &gt; self.start_time + self.timeout:</span><br><span class="line">            self._ready = True</span><br><span class="line">        return self._ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Snow(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    微型Web框架类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, routes):</span><br><span class="line">        self.routes = routes</span><br><span class="line">        self.inputs = set()</span><br><span class="line">        self.request = None</span><br><span class="line">        self.async_request_handler = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def run(self, host=&apos;localhost&apos;, port=9999):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        事件循环</span><br><span class="line">        :param host:</span><br><span class="line">        :param port:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        sock.bind((host, port,))</span><br><span class="line">        sock.setblocking(False)</span><br><span class="line">        sock.listen(128)</span><br><span class="line">        sock.setblocking(0)</span><br><span class="line">        self.inputs.add(sock)</span><br><span class="line">        try:</span><br><span class="line">            while True:</span><br><span class="line">                readable_list, writeable_list, error_list = select.select(self.inputs, [], self.inputs,0.005)</span><br><span class="line">                for conn in readable_list:</span><br><span class="line">                    if sock == conn:</span><br><span class="line">                        client, address = conn.accept()</span><br><span class="line">                        client.setblocking(False)</span><br><span class="line">                        self.inputs.add(client)</span><br><span class="line">                    else:</span><br><span class="line">                        gen = self.process(conn)</span><br><span class="line">                        if isinstance(gen, HttpResponse):</span><br><span class="line">                            conn.sendall(gen.response())</span><br><span class="line">                            self.inputs.remove(conn)</span><br><span class="line">                            conn.close()</span><br><span class="line">                        else:</span><br><span class="line">                            yielded = next(gen)</span><br><span class="line">                            self.async_request_handler[conn] = yielded</span><br><span class="line">                self.polling_callback()</span><br><span class="line"></span><br><span class="line">        except Exception as e:</span><br><span class="line">            pass</span><br><span class="line">        finally:</span><br><span class="line">            sock.close()</span><br><span class="line"></span><br><span class="line">    def polling_callback(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        遍历触发异步非阻塞的回调函数</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for conn in list(self.async_request_handler.keys()):</span><br><span class="line">            yielded = self.async_request_handler[conn]</span><br><span class="line">            if not yielded.ready:</span><br><span class="line">                continue</span><br><span class="line">            if yielded.callback:</span><br><span class="line">                ret = yielded.callback(self.request, yielded)</span><br><span class="line">                conn.sendall(ret.response())</span><br><span class="line">            self.inputs.remove(conn)</span><br><span class="line">            del self.async_request_handler[conn]</span><br><span class="line">            conn.close()</span><br><span class="line"></span><br><span class="line">    def process(self, conn):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        处理路由系统以及执行函数</span><br><span class="line">        :param conn:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.request = HttpRequest(conn)</span><br><span class="line">        func = None</span><br><span class="line">        for route in self.routes:</span><br><span class="line">            if re.match(route[0], self.request.url):</span><br><span class="line">                func = route[1]</span><br><span class="line">                break</span><br><span class="line">        if not func:</span><br><span class="line">            return HttpNotFound()</span><br><span class="line">        else:</span><br><span class="line">            return func(self.request)</span><br><span class="line"></span><br><span class="line">snow.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>hello~</title>
      <link href="/2018/01/02/hello/"/>
      <url>/2018/01/02/hello/</url>
      <content type="html"><![CDATA[<blockquote><p>因为很多原因，一直没能进行博客的更新，今天终于又和大家见面了。</p></blockquote><ul><li>nice to meet you !</li><li>欢迎来到我的博客，希望和大家一同进步，一同分享知识。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Django的Rest Framework框架源码分析</title>
      <link href="/2017/12/20/rest-framework/"/>
      <url>/2017/12/20/rest-framework/</url>
      <content type="html"><![CDATA[<h4 id="Django-RESTful-framework框架"><a href="#Django-RESTful-framework框架" class="headerlink" title="Django RESTful framework框架"></a>Django RESTful framework框架</h4><ul><li>使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class MyAuthentication(object):</span><br><span class="line">    def authenticate(self,request):</span><br><span class="line">        token = request._request.GET.get(&apos;token&apos;)</span><br><span class="line">        # 获取用户名和密码，去数据校验</span><br><span class="line">        if not token:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&apos;用户认证失败&apos;)</span><br><span class="line">        return (&quot;alex&quot;,None)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self,val):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class DogView(APIView):</span><br><span class="line">    authentication_classes = [MyAuthentication,]</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(request)</span><br><span class="line">        print(request.user)</span><br><span class="line">        self.dispatch</span><br><span class="line">        ret  = &#123;</span><br><span class="line">            &apos;code&apos;:1000,</span><br><span class="line">            &apos;msg&apos;:&apos;xxx&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        return HttpResponse(json.dumps(ret),status=201)</span><br><span class="line"></span><br><span class="line">    def post(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&apos;创建Dog&apos;)</span><br><span class="line"></span><br><span class="line">    def put(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&apos;更新Dog&apos;)</span><br><span class="line"></span><br><span class="line">    def delete(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&apos;删除Dog&apos;)</span><br></pre></td></tr></table></figure><ul><li>源码流程<ul><li>基于Django的CBV实现，我们先看请求的流程，先从url开始匹配，到views里，执行的是dispatch（）方法，那我们就从dispatch（）方法开始</li><li>先看当前类中有没有dispatch（）方法，如果没有就去父类中查找，restful中我们的views里继承的是APIView，其实APIView源码也是继承自Django的View的，在restful的views源码里我们可以看到dispatch（）方法，</li><li>在rest的views里面的dispatch（）方法中我们可以看到，对原生的request进行了加工，我们可以跟到initialize_request（）方法中具体的看一下</li><li>initialize_request（）中对request进行了封装，除了原生的request外，又加上了一些其他的东西，通过get_authenticators（）方法获取到auth对象的列表赋值给authenticators，get_authenticators（）是从authentication_classes中获取的auth对象，authentication_classes在api_settings中默认给出了一个列表</li><li>接着往下看，把加工好的request赋值给当前对象，然后执行了initial（）方法，我们去看一看，我们可以看到在initial（）方法里调用了perform_authentication（request），将加工好的request传进去，其实是认证是否登录</li><li>在perform_authentication（）我们可以看到直接调用的request的user，其实我们查看request源码可以知道，user方法使用了property装饰器，所以调用的时候不用写括号</li><li>然后调用request类的_authenticate（），循环了其实是BasicAuthentication对象的那个列表，该对象里一定有authenticate方法，通过调用这个方法，来认证是否登录</li></ul></li></ul><p>rest_framework/views.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def dispatch(self, request, *args, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    `.dispatch()` is pretty much the same as Django&apos;s regular dispatch,</span><br><span class="line">    but with extra hooks for startup, finalize, and exception handling.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    self.args = args</span><br><span class="line">    self.kwargs = kwargs</span><br><span class="line">    # 对原生的request进行加工</span><br><span class="line">    request = self.initialize_request(request, *args, **kwargs)</span><br><span class="line">    # 获取原生的request，request._request</span><br><span class="line">    # 获取认证类的对象 request.authenticators,对象列表</span><br><span class="line">    # 将加工过的request赋给当前对象，（原生的request， [BasicAuthentication对象，...]）</span><br><span class="line">    self.request = request</span><br><span class="line">    self.headers = self.default_response_headers  # deprecate?</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # 传入的是加工过的request</span><br><span class="line">        self.initial(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        # Get the appropriate handler method通过反射执行相应的函数</span><br><span class="line">        if request.method.lower() in self.http_method_names:</span><br><span class="line">            handler = getattr(self, request.method.lower(),</span><br><span class="line">                              self.http_method_not_allowed)</span><br><span class="line">        else:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line"></span><br><span class="line">        response = handler(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    except Exception as exc:</span><br><span class="line">        response = self.handle_exception(exc)</span><br><span class="line"></span><br><span class="line">    self.response = self.finalize_response(request, response, *args, **kwargs)</span><br><span class="line">    return self.response</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> # Dispatch methods</span><br><span class="line">    # 对request进行加工</span><br><span class="line">    def initialize_request(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the initial request object.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 取出原生的request的内容</span><br><span class="line">        parser_context = self.get_parser_context(request)</span><br><span class="line">        # 返回一个Request对象</span><br><span class="line">        return Request(</span><br><span class="line">            # 原生的request</span><br><span class="line">            request,</span><br><span class="line">            parsers=self.get_parsers(),</span><br><span class="line">            # 获取到auth对象列表</span><br><span class="line">            authenticators=self.get_authenticators(),</span><br><span class="line">            negotiator=self.get_content_negotiator(),</span><br><span class="line">            parser_context=parser_context</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">#####################################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     def initial(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Runs anything that needs to occur prior to calling the method handler.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.format_kwarg = self.get_format_suffix(**kwargs)</span><br><span class="line"></span><br><span class="line">        # Perform content negotiation and store the accepted info on the request</span><br><span class="line">        neg = self.perform_content_negotiation(request)</span><br><span class="line">        request.accepted_renderer, request.accepted_media_type = neg</span><br><span class="line"></span><br><span class="line">        # Determine the API version, if versioning is in use.</span><br><span class="line">        version, scheme = self.determine_version(request, *args, **kwargs)</span><br><span class="line">        request.version, request.versioning_scheme = version, scheme</span><br><span class="line"></span><br><span class="line">        # Ensure that the incoming request is permitted</span><br><span class="line">        # 认证</span><br><span class="line">        self.perform_authentication(request)</span><br><span class="line">        self.check_permissions(request)</span><br><span class="line">        self.check_throttles(request)</span><br><span class="line">#####################################################</span><br><span class="line">    </span><br><span class="line">    def get_authenticators(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Instantiates and returns the list of authenticators that this view can use.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 返回的是一个对象的列表，self都是从当前的对象找，找不到再去父类中找</span><br><span class="line">        return [auth() for auth in self.authentication_classes]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##################################################</span><br><span class="line"></span><br><span class="line">    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#############################################</span><br><span class="line"></span><br><span class="line">     def initial(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Runs anything that needs to occur prior to calling the method handler.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.format_kwarg = self.get_format_suffix(**kwargs)</span><br><span class="line"></span><br><span class="line">        # Perform content negotiation and store the accepted info on the request</span><br><span class="line">        neg = self.perform_content_negotiation(request)</span><br><span class="line">        request.accepted_renderer, request.accepted_media_type = neg</span><br><span class="line"></span><br><span class="line">        # Determine the API version, if versioning is in use.</span><br><span class="line">        version, scheme = self.determine_version(request, *args, **kwargs)</span><br><span class="line">        request.version, request.versioning_scheme = version, scheme</span><br><span class="line"></span><br><span class="line">        # Ensure that the incoming request is permitted</span><br><span class="line">        # 认证</span><br><span class="line">        self.perform_authentication(request)</span><br><span class="line">        self.check_permissions(request)</span><br><span class="line">        self.check_throttles(request)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#######################################################</span><br><span class="line">        def perform_authentication(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Perform authentication on the incoming request.</span><br><span class="line"></span><br><span class="line">        Note that if you override this and simply &apos;pass&apos;, then authentication</span><br><span class="line">        will instead be performed lazily, the first time either</span><br><span class="line">        `request.user` or `request.auth` is accessed.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 加工后的request</span><br><span class="line">        request.user</span><br></pre></td></tr></table></figure><p>request.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> def _authenticate(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Attempt to authenticate the request using each authentication instance</span><br><span class="line">        in turn.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        #循环这个列表[BasicAuthentication对象,]</span><br><span class="line">        for authenticator in self.authenticators:</span><br><span class="line">            try:</span><br><span class="line">                # 该对象里一定有authenticate方法</span><br><span class="line">                # 认证是否登录</span><br><span class="line">                user_auth_tuple = authenticator.authenticate(self)</span><br><span class="line">            except exceptions.APIException:</span><br><span class="line">                self._not_authenticated()</span><br><span class="line">                raise</span><br><span class="line"></span><br><span class="line">            if user_auth_tuple is not None:</span><br><span class="line">                self._authenticator = authenticator</span><br><span class="line">                # 如果登录的话，就会返回元组，否则抛出异常</span><br><span class="line">                self.user, self.auth = user_auth_tuple</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">        self._not_authenticated()</span><br><span class="line">#################################################</span><br><span class="line">    @property</span><br><span class="line">    def user(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the user associated with the current request, as authenticated</span><br><span class="line">        by the authentication classes provided to the request.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not hasattr(self, &apos;_user&apos;):</span><br><span class="line">            with wrap_attributeerrors():</span><br><span class="line">                self._authenticate()</span><br><span class="line">        return self._user</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>机器学习----支持向量机SVM</title>
      <link href="/2017/12/18/svm/"/>
      <url>/2017/12/18/svm/</url>
      <content type="html"><![CDATA[<h1 id="支持向量机SVM（Support-Vector-Machine）"><a href="#支持向量机SVM（Support-Vector-Machine）" class="headerlink" title="支持向量机SVM（Support Vector Machine）"></a>支持向量机SVM（Support Vector Machine）</h1><h2 id="【关键词】支持向量，最大几何间隔，拉格朗日乘子法"><a href="#【关键词】支持向量，最大几何间隔，拉格朗日乘子法" class="headerlink" title="【关键词】支持向量，最大几何间隔，拉格朗日乘子法"></a>【关键词】支持向量，最大几何间隔，拉格朗日乘子法</h2><h2 id="一、支持向量机的原理"><a href="#一、支持向量机的原理" class="headerlink" title="一、支持向量机的原理"></a>一、支持向量机的原理</h2><p>Support Vector Machine。支持向量机，其含义是通过支持向量运算的分类器。其中“机”的意思是机器，可以理解为分类器。<br>那么什么是支持向量呢？在求解的过程中，会发现只根据部分数据就可以确定分类器，这些数据称为支持向量。<br>见下图，在一个二维环境中，其中点R，S，G点和其它靠近中间黑线的点可以看作为支持向量，它们可以决定分类器，也就是黑线的具体参数。</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113910.png" alt="Untitled-1-1"></p><p>解决的问题：</p><ul><li>线性分类</li></ul><p>在训练数据中，每个数据都有n个的属性和一个二类类别标志，我们可以认为这些数据在一个n维空间里。我们的目标是找到一个n-1维的超平面（hyperplane），这个超平面可以将数据分成两部分，每部分数据都属于同一个类别。<br>其实这样的超平面有很多，我们要找到一个最佳的。因此，增加一个约束条件：这个超平面到每边最近数据点的距离是最大的。也成为最大间隔超平面（maximum-margin hyperplane）。这个分类器也成为最大间隔分类器（maximum-margin classifier）。<br>支持向量机是一个二类分类器。</p><ul><li>非线性分类</li></ul><p>SVM的一个优势是支持非线性分类。它结合使用拉格朗日乘子法和KKT条件，以及核函数可以产生非线性分类器。</p><p>SVM的目的是要找到一个线性分类的最佳超平面 f(x)=xw+b=0。求 w 和 b。</p><p>首先通过两个分类的最近点，找到f(x)的约束条件。</p><p>有了约束条件，就可以通过拉格朗日乘子法和KKT条件来求解，这时，问题变成了求拉格朗日乘子αi 和 b。</p><p>对于异常点的情况，加入松弛变量ξ来处理。</p><p>非线性分类的问题：映射到高维度、使用核函数。</p><h4 id="线性分类及其约束条件"><a href="#线性分类及其约束条件" class="headerlink" title="线性分类及其约束条件"></a>线性分类及其约束条件</h4><p>SVM的解决问题的思路是找到离超平面的最近点，通过其约束条件求出最优解。</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113925.PNG" alt="Untitled-1-3"></p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418114112.PNG" alt="Untitled-1-2018418114112"></p><h4 id="最大几何间隔（geometrical-margin）"><a href="#最大几何间隔（geometrical-margin）" class="headerlink" title="最大几何间隔（geometrical margin）"></a>最大几何间隔（geometrical margin）</h4><p><img src="https://img-blog.csdn.net/20180418114923736?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="5"></p><h4 id="求解问题w-b"><a href="#求解问题w-b" class="headerlink" title="求解问题w,b"></a>求解问题w,b</h4><p>我们使用拉格朗日乘子法(<a href="http://blog.csdn.net/on2way/article/details/47729419" target="_blank" rel="noopener">http://blog.csdn.net/on2way/article/details/47729419</a>)<br>来求w和b，一个重要原因是使用拉格朗日乘子法后,还可以解决非线性划分问题。<br>拉格朗日乘子法可以解决下面这个问题：</p><p><img src="https://img-blog.csdn.net/20180418114935831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>消除w之后变为：</p><p><img src="https://img-blog.csdn.net/20180418114945824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="7"></p><p>可见使用拉格朗日乘子法后，求w,b的问题变成了求拉格朗日乘子αi和b的问题。<br>到后面更有趣，变成了不求w了，因为αi可以直接使用到分类器中去，并且可以使用αi支持非线性的情况.</p><h2 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h2><h3 id="1、画出决策边界"><a href="#1、画出决策边界" class="headerlink" title="1、画出决策边界"></a>1、画出决策边界</h3><p>导包sklearn.svm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SVC是支持向量机的分类算法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>随机生成数据，并且进行训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">samples1 = np.random.randn(<span class="number">20</span>,<span class="number">2</span>) + [[<span class="number">-2</span>,<span class="number">3</span>]]</span><br><span class="line">samples2 = np.random.randn(<span class="number">20</span>,<span class="number">2</span>) + [[<span class="number">2</span>,<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">samples = np.concatenate((samples1,samples2))</span><br><span class="line">target = [<span class="number">0</span>]*<span class="number">20</span> + [<span class="number">1</span>]*<span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linear  线性可分的情况使用</span></span><br><span class="line"><span class="comment"># rbf     线性不可分</span></span><br><span class="line"><span class="comment"># poly    以上两种效果都不好，再使用，耗时非常长</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svc = SVC(kernel=<span class="string">'linear'</span>)</span><br><span class="line"></span><br><span class="line">svc.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=&apos;ovr&apos;, degree=3, gamma=&apos;auto&apos;, kernel=&apos;linear&apos;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><h5 id="超平面的公式"><a href="#超平面的公式" class="headerlink" title="超平面的公式"></a>超平面的公式</h5><p>f(x) = w*x + k</p><p>提取系数获取斜率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svc.coef_[<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>1.0699901013441295</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = -svc.coef_[<span class="number">0</span>,<span class="number">0</span>]/svc.coef_[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">w</span><br></pre></td></tr></table></figure><pre><code>3.153964300544549</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = svc.intercept_[<span class="number">0</span>]</span><br><span class="line">k</span><br></pre></td></tr></table></figure><pre><code>-0.10546966745706991</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xmin,xmax = samples[:,<span class="number">0</span>].min()/<span class="number">2</span>,samples[:,<span class="number">0</span>].max()/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">100</span>)</span><br><span class="line">y = w*x + k</span><br><span class="line"></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],s=<span class="number">50</span>,c=target)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113649.png" alt="Untitled-1-25"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">up_vector = svc.support_vectors_[<span class="number">0</span>]</span><br><span class="line">bottom_vector = svc.support_vectors_[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x,y)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],s=<span class="number">50</span>,c=target)</span><br><span class="line">plt.scatter(svc.support_vectors_[:,<span class="number">0</span>],svc.support_vectors_[:,<span class="number">1</span>],color=<span class="string">'red'</span>,s=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113659.png" alt="Untitled-1-27"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># y = w*x + k</span></span><br><span class="line">k1 = up_vector[<span class="number">1</span>] - w*up_vector[<span class="number">0</span>]</span><br><span class="line">k2 = bottom_vector[<span class="number">1</span>] - w*bottom_vector[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">y1 = w*x + k1</span><br><span class="line">y2 = w*x + k2</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],s=<span class="number">50</span>,c=target)</span><br><span class="line">plt.scatter(svc.support_vectors_[:,<span class="number">0</span>],svc.support_vectors_[:,<span class="number">1</span>],color=<span class="string">'red'</span>,s=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841811377.png" alt="Untitled-1-28"></p><p>线性方程的截距</p><p>f(x) = ax + b，期中b就是函数f(x)截距,即函数线与y轴的交点的值</p><ul><li>函数的截距可以使用svc.intercept_方法得到</li></ul><p>确定一个x轴的区间，取x_train中的最大值和最小值为边界，计算y值，y = 斜率*x + 截距</p><p>绘制出分割线</p><p>使用svc.support_vectors_找出支持向量，即离分割线最近的点集合，绘制出支持向量的所有点</p><p>绘制两条线，分别经过支持向量的第一个点和最后一个点，即查看分割线两边的通过支持向量的平行线</p><p>绘制图形</p><h3 id="2、使用多种核函数对iris数据集进行分类"><a href="#2、使用多种核函数对iris数据集进行分类" class="headerlink" title="2、使用多种核函数对iris数据集进行分类"></a>2、使用多种核函数对iris数据集进行分类</h3><p>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">data = iris.data</span><br><span class="line">target = iris.target</span><br><span class="line">samples = data[:,:<span class="number">2</span>]</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113716.png" alt="Untitled-1-38"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples.shape</span><br></pre></td></tr></table></figure><pre><code>(150, 2)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linear = SVC(kernel=<span class="string">'linear'</span>)</span><br><span class="line">rbf = SVC(kernel=<span class="string">'rbf'</span>)</span><br><span class="line">poly = SVC(kernel=<span class="string">'poly'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time linear.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 984 µsSVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=&apos;ovr&apos;, degree=3, gamma=&apos;auto&apos;, kernel=&apos;linear&apos;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time rbf.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 2 msSVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=&apos;ovr&apos;, degree=3, gamma=&apos;auto&apos;, kernel=&apos;rbf&apos;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time poly.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 15 msSVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,  decision_function_shape=&apos;ovr&apos;, degree=3, gamma=&apos;auto&apos;, kernel=&apos;poly&apos;,  max_iter=-1, probability=False, random_state=None, shrinking=True,  tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间：linear最省时，其次是rbf，最慢的是poly内核，甚用</span></span><br></pre></td></tr></table></figure><p>提取数据只提取两个特征，方便画图<br>创建支持向量机的模型：’linear’, ‘poly’(多项式), ‘rbf’(Radial Basis Function:基于半径函数),</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmin,xmax = samples[:,<span class="number">0</span>].min()<span class="number">-0.5</span>,samples[:,<span class="number">0</span>].max()+<span class="number">0.5</span></span><br><span class="line">ymin,ymax = samples[:,<span class="number">1</span>].min()<span class="number">-0.5</span>,samples[:,<span class="number">1</span>].max()+<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">300</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_test.shape</span><br></pre></td></tr></table></figure><pre><code>(90000, 2)</code></pre><p>训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预测时间比训练时间短，SVM先求出支持向量，然后再根据支持向量对比预测点的位置</span></span><br><span class="line">%time y1_ = linear.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 114 ms</code></pre><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time y2_ = rbf.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 207 ms</code></pre><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time y3_ = poly.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>Wall time: 117 ms</code></pre><p>​    </p><p>图片背景点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">colormap = ListedColormap([<span class="string">'#00aaff'</span>,<span class="string">'#aa00ff'</span>,<span class="string">'#ffaa00'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">results = [y1_,y2_,y3_]</span><br><span class="line">labels = [<span class="string">'linear'</span>,<span class="string">'rbf'</span>,<span class="string">'poly'</span>]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    axes = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>)</span><br><span class="line">    y_ = results[i]</span><br><span class="line">    axes.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_,cmap=colormap)</span><br><span class="line">    axes.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br><span class="line">    axes.set_title(labels[i])</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113726.png" alt="Untitled-1-54"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linear 类似于 Logistic回归</span></span><br><span class="line"><span class="comment"># rbf  类似于 GaussianNB</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">logistic = LogisticRegression()</span><br><span class="line">gaussion = GaussianNB()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit logistic.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>637 µs ± 40.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></pre><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit gaussion.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>577 µs ± 74.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></pre><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit linear.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>521 µs ± 5.31 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></pre><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit rbf.fit(samples,target)</span><br></pre></td></tr></table></figure><pre><code>740 µs ± 55.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></pre><p>​    </p><p>预测并绘制图形for循环绘制图形</p><h3 id="3、使用SVM多种核函数进行回归"><a href="#3、使用SVM多种核函数进行回归" class="headerlink" title="3、使用SVM多种核函数进行回归"></a>3、使用SVM多种核函数进行回归</h3><p>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-np.pi,np.pi,<span class="number">40</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113759.png" alt="Untitled-1-64"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noise = np.random.random(<span class="number">10</span>) - <span class="number">0.5</span></span><br><span class="line">noise</span><br></pre></td></tr></table></figure><pre><code>array([-0.47280512, -0.49158098, -0.15740622, -0.20815824,  0.05157893,       -0.15727586,  0.30148395, -0.15495128, -0.49880787,  0.00377052])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[::<span class="number">4</span>] += noise</span><br><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113816.png" alt="Untitled-1-66"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line">linear = SVR(kernel=<span class="string">'linear'</span>)</span><br><span class="line">rbf = SVR(kernel=<span class="string">'rbf'</span>)</span><br><span class="line">poly = SVR(kernel=<span class="string">'poly'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">linear.fit(x,y)</span><br><span class="line">rbf.fit(x,y)</span><br><span class="line">poly.fit(x,y)</span><br></pre></td></tr></table></figure><pre><code>SVR(C=1.0, cache_size=200, coef0=0.0, degree=3, epsilon=0.1, gamma=&apos;auto&apos;,  kernel=&apos;poly&apos;, max_iter=-1, shrinking=True, tol=0.001, verbose=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X_test = np.linspace(x.min(),x.max(),<span class="number">100</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y1_ = linear.predict(X_test)</span><br><span class="line">y2_ = rbf.predict(X_test)</span><br><span class="line">y3_ = poly.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.plot(X_test,y1_,label=<span class="string">'linear'</span>)</span><br><span class="line">plt.plot(X_test,y2_,label=<span class="string">'rbf'</span>)</span><br><span class="line">plt.plot(X_test,y3_,label=<span class="string">'poly'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018418113851.png" alt="Untitled-1-70"></p><p>自定义样本点rand，并且生成sin函数曲线</p><p>数据加噪</p><p>建立模型，训练数据，并预测数据，预测训练数据就行</p><p>绘制图形，观察三种支持向量机内核不同</p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h3 id="2、使用SVC对cars-txt进行分析"><a href="#2、使用SVC对cars-txt进行分析" class="headerlink" title="2、使用SVC对cars.txt进行分析"></a>2、使用SVC对cars.txt进行分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 获取数据集（样本集）</span></span><br><span class="line"><span class="comment"># 2 特征处理（特征工程理论指导）</span></span><br><span class="line"><span class="comment"># 3 数据清洗（异常值...）</span></span><br><span class="line"><span class="comment"># 4 模型选择（算法）</span></span><br><span class="line"><span class="comment"># 5 算法评价 (r2_score回归模型  score分类模型)</span></span><br><span class="line"><span class="comment"># 6 绘图展示（结果说明）</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars = pd.read_csv(<span class="string">'../data/cars.txt'</span>,header=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples = cars.iloc[:,:<span class="number">6</span>].copy()</span><br><span class="line">target = cars[<span class="number">6</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples[<span class="number">0</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;vhigh&apos;, &apos;high&apos;, &apos;med&apos;, &apos;low&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples[<span class="number">1</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;vhigh&apos;, &apos;high&apos;, &apos;med&apos;, &apos;low&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples[<span class="number">2</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5more&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples[<span class="number">3</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;2&apos;, &apos;4&apos;, &apos;more&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples[<span class="number">4</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;small&apos;, &apos;med&apos;, &apos;big&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples[<span class="number">5</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;low&apos;, &apos;med&apos;, &apos;high&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map_dic = &#123;</span><br><span class="line">    <span class="string">'vhigh'</span>:<span class="number">0</span>, <span class="string">'high'</span>:<span class="number">1</span>, <span class="string">'med'</span>:<span class="number">2</span>, <span class="string">'low'</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">'2'</span>:<span class="number">0</span>, <span class="string">'3'</span>:<span class="number">1</span>, <span class="string">'4'</span>:<span class="number">2</span>, <span class="string">'5more'</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">'more'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'small'</span>:<span class="number">1</span>, <span class="string">'big'</span>:<span class="number">3</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples.replace(map_dic,inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(samples,target,test_size=<span class="number">0.2</span>,random_state=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">linear = SVC(kernel=<span class="string">'linear'</span>)</span><br><span class="line">print(<span class="string">"svm liner score is %f"</span>%linear.fit(X_train,y_train).score(X_test,y_test))</span><br><span class="line"></span><br><span class="line">rbf = SVC(kernel=<span class="string">'rbf'</span>)</span><br><span class="line">print(<span class="string">"rbf liner score is %f"</span>%rbf.fit(X_train,y_train).score(X_test,y_test))</span><br><span class="line"></span><br><span class="line">poly = SVC(kernel=<span class="string">'poly'</span>)</span><br><span class="line">print(<span class="string">"poly liner score is %f"</span>%poly.fit(X_train,y_train).score(X_test,y_test))</span><br></pre></td></tr></table></figure><pre><code>svm liner score is 0.843931rbf liner score is 0.982659poly liner score is 0.950867</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">logistic = LogisticRegression()</span><br><span class="line">logistic.fit(X_train,y_train).score(X_test,y_test)</span><br></pre></td></tr></table></figure><pre><code>0.7832369942196532</code></pre><p><a href="https://github.com/yuansuixin/ML-SVM" title="源码下载" target="_blank" rel="noopener">源码下载</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的注解（Annotation)详细解析</title>
      <link href="/2017/12/15/annotation/"/>
      <url>/2017/12/15/annotation/</url>
      <content type="html"><![CDATA[<h6 id="Annotation工作方式："><a href="#Annotation工作方式：" class="headerlink" title="Annotation工作方式："></a>Annotation工作方式：</h6><p>从java5.0以来，提供了一个真实的annotation功能：允许开发者定义、使用自己的额annotation类型，此功能由一个定义annotation类型的语法和一个描述annotation声明的语法，读取annotation的API，一个使用annotation修饰的Class文件，一个annotation处理工具apt组成。</p><p>annotation<strong>并不会直接影响代码语义</strong>，但是它能够工作的方式被看做类似程序的工具或者类库，他会反过来对正在运行的程序语义有所影响。annotation可以从源文件，class文件或者以在运行时反射的多种方式被读取。</p><p>注解可以用在方法，类，变量等上面，注解的使用范围很广。</p><p><strong>Override注解表示子类要重写（override）父类方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OverrideTest &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;This is OverrideTest&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">OverrideTest overrideTest = new OverrideTest();</span><br><span class="line">System.out.println(overrideTest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is OverrideTest</span><br></pre></td></tr></table></figure><p><strong>Deprecate注解表示方法是不建议被使用的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DeprecatedTest &#123;</span><br><span class="line">@Deprecated</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">System.out.println(&quot;do something &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">DeprecatedTest deprecatedTest= new DeprecatedTest();</span><br><span class="line">//不建议被使用的</span><br><span class="line">deprecatedTest.doSomething();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Date d= new Date();</span><br><span class="line">//System.out.println(d.toLocaleString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SuppressWarnings注解表示抑制警告。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningsTest &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)//不检查</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map=new TreeMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;hello&quot;, new Date());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningsTest &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;,&quot;deprecation&quot;&#125;)//不检查，不推荐使用的</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map=new TreeMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;hello&quot;, new Date());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(date.toLocaleString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解跟着值的时候可以使用大括号，也可以省略。@SuppressWarnings({“unchecked”,”deprecation”})</strong></p><p>以上就是注解的使用方式，我们也可以自己定义注解，下面来介绍一下自定义注解。</p><p>当注解中的属性名为value时，在对其赋值时可以不指定属性的名称而直接写上属性值即可，除了value以外的其他值都需要使用name=value这种赋值方式，即明确指定给谁赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public @interface AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">//定义属性</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@AnnotationTest(value=&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">public class AnnoationUsage &#123;</span><br><span class="line"></span><br><span class="line">@AnnotationTest(value=&quot;world&quot;)</span><br><span class="line">public void method() &#123;</span><br><span class="line">System.out.println(&quot;usage of annoation&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AnnoationUsage annoationUsage = new AnnoationUsage();</span><br><span class="line">annoationUsage.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的值可以默认的具体赋值，使用@interface自行定义Annotation形态时，实际上是自动继承了java.lang.annotation.Annotation接口由编译程序自动为您完成其他产生的细节，<strong>在定义Annotation形态时，不能继承其他的Annotation形态或是接口。</strong></p><p>当我们使用@interface关键字定义一个注解时，该注解隐含地继承了java.lang.annotation.Annotation接口；如果我们定义了一个接口，并且让该接口继承自Annotation，那么我们所定义的接口依然还是接口而不是注解；Annotation本身是接口而不是注解。可以与Enum类比。</p><p>定义annotation类型时也可以使用包来管理类别，方式同于类的导入功能</p><h6 id="告知编译器如何处理-Retention"><a href="#告知编译器如何处理-Retention" class="headerlink" title="告知编译器如何处理@Retention"></a>告知编译器如何处理@Retention</h6><p>使用java.lang.annotation.Retention，在定义时要指定java.lang.annotation.RetentionPolicy的枚举值之一</p><p>java.lang.annotation.Retention形态可以在你定义Annotation时，指示编译程序该如何对待您的自定义的Annotation。预设上编译程序会将Annotation信息留在.class档案中，但不被虚拟机读取，而仅用于编译程序或工具程序运行时提供信息。</p><p>Retention和RetentionPolicy总是成对出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line"></span><br><span class="line">SOURCE,//编译程序处理完annotation信息后就完成任务</span><br><span class="line">CLASS,//编译程序将annotation储存于Class档中，默认就是这个</span><br><span class="line">RUNTIME//编译程序将annotation储存于Class文档中，可以由VM读入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为SOURSE的例子是<br>@SuppressWarnings仅在编译时期告知编译程序来抑制警告，所以不必将这个信息储存于class文档<br>为RUNTIME的时机，可以像是你使用java设计一个程序代码分析工具，你必须让vm能读出Annotation信息，以便在分析程序时使用，<strong>搭配反射机制就可以达到这个目的</strong></p><p>定义annotation时必须设定RetentionPolicy为RUNTIME，也就是可以在vm中读取Annotation信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">//自定义一个注解</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String hello() default &quot;zhangsan&quot;;</span><br><span class="line">String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation(hello=&quot;beijing&quot;,world=&quot;shanghai&quot;)</span><br><span class="line">public class MyTest &#123;</span><br><span class="line"></span><br><span class="line">//一个方法可以由多个注解修饰</span><br><span class="line">@MyAnnotation(hello=&quot;tianjin&quot;,world=&quot;shangdi&quot;)</span><br><span class="line">@Deprecated</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void output() &#123;</span><br><span class="line">System.out.println(&quot;output method&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyReflaction &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)throws Exception &#123;</span><br><span class="line"></span><br><span class="line">MyTest myTest = new MyTest();</span><br><span class="line"></span><br><span class="line">Class&lt;MyTest&gt; class1= MyTest.class;</span><br><span class="line"></span><br><span class="line">Method method =class1.getMethod(&quot;output&quot;, new Class[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//判断是否存在这样也一个Annotation</span><br><span class="line">if(method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">method.invoke(myTest, new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//得到一个Annotation，返回这个Annotation的一个实例</span><br><span class="line">MyAnnotation myAnnotation =method.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">//获得这个Annotation的属性值</span><br><span class="line">String hello=myAnnotation.hello();</span><br><span class="line">String world=myAnnotation.world();</span><br><span class="line"></span><br><span class="line">System.out.println(hello+&quot; ,&quot;+world);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果完全是由RetentionPolicy决定的，只有RUNTIME的可以读取到</span><br><span class="line">Annotation[] annotations=method.getAnnotations();</span><br><span class="line"></span><br><span class="line">//必须RetentionPolicy为RUNTIME才可以读取到</span><br><span class="line">for(Annotation annotation: annotations) &#123;</span><br><span class="line">System.out.println(annotation.annotationType().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output method</span><br><span class="line">tianjin ,shangdi</span><br><span class="line">MyAnnotation</span><br><span class="line">java.lang.Deprecated</span><br></pre></td></tr></table></figure><p>这个例子主要练习了几个和反射、注解有关的方法。只要理解了反射机制就很容易理解了，我再注释中都已经详细的介绍了，这里就不过多的描述了。</p><h6 id="限定annotation使用对象-Target"><a href="#限定annotation使用对象-Target" class="headerlink" title="限定annotation使用对象@Target"></a>限定annotation使用对象@Target</h6><p>使用java.lang.annotation.Target可以定义其使用之时机，在定义时要指定java.lang.annotation.ElementType的枚举值之一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line"></span><br><span class="line">TYPE,//适用Class,interface ,enum</span><br><span class="line">FIELD,//适用文件</span><br><span class="line">METHOD,//适用于方法</span><br><span class="line">PARAMETER,//适用method上之parameter</span><br><span class="line">CONSTRUCTOR,//适用constructor</span><br><span class="line">LOCAL_VARIABLE,//适用局部变量</span><br><span class="line">ANNOTATION_TYPE,//适用annotation形态</span><br><span class="line">PACKAGE//适用package</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="要求为API文件-Documented"><a href="#要求为API文件-Documented" class="headerlink" title="要求为API文件@Documented"></a>要求为API文件@Documented</h6><p>想要在使用者制作javaDoc文件的同时，也一并将Annotation的信息加入至API文档中使用。</p><h6 id="子类是否继承父类-Inherited"><a href="#子类是否继承父类-Inherited" class="headerlink" title="子类是否继承父类@Inherited"></a>子类是否继承父类@Inherited</h6><p>预设上父类中的annotation并不会被继承至子类中，可以在定义Annotation形态时加上java.lang.annotation.Inherited形态的Annotation。</p><p>注解在实际中的应用，注解主要应用在单元测试中，我来简单的说一下。</p><p>Junit有两个经典的版本，Junit3和Junit4。</p><p>Junit3继承TestCase,方法必须以test开头。keep the bar green to keep the code clean.这些底层都是通过反射机制实现的。</p><p>Junit3是基于反射的，Junit4是基于反射和注解的</p><p>JUnit4的执行的一般流程：</p><ol><li>首先获得待测试类所对应的Class对象。</li><li>然后通过该Class对象获得当前类中所有public方法所对应的Method数组。</li><li>遍历该Method数组，取得每一个Method对象</li><li>调用每个Method对象的isAnnotationPresent(Test.class)方法，判断该方法是否被Test注解所修饰。</li><li>如果该方法返回true，那么调用method.invoke()方法去执行该方法，否则不执行。</li></ol><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Restful API设计规范</title>
      <link href="/2017/11/19/rest-frame-work/"/>
      <url>/2017/11/19/rest-frame-work/</url>
      <content type="html"><![CDATA[<h2 id="restful规范（建议）"><a href="#restful规范（建议）" class="headerlink" title="restful规范（建议）"></a>restful规范（建议）</h2><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><ul><li><p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”</p></li><li><p>REST从资源的角度类审视整个网络，它将分布在网络中某个节点的资源通过URL进行标识，客户端应用通过URL来获取资源的表征，获得这些表征致使这些应用转变状态</p></li><li><p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”</p></li><li><p>所有的数据，不过是通过网络获取的还是操作（增删改查）的数据，都是资源，将一切数据视为资源是REST区别与其他架构风格的最本质属性</p></li><li><p>对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即：面向资源架构（ROA：Resource Oriented Architecture）</p></li></ul><h4 id="1、-接口开发"><a href="#1、-接口开发" class="headerlink" title="1、 接口开发"></a>1、 接口开发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def get_order(request):</span><br><span class="line">    return HttpResponse(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def add_order(request):</span><br><span class="line">    return HttpResponse(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def update_order(request):</span><br><span class="line">    return HttpResponse(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def del_order(request):</span><br><span class="line">    return HttpResponse(&apos;&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^get_order/&apos;, views.get_order),</span><br><span class="line">url(r&apos;^add_order/&apos;, views.add_order),</span><br><span class="line">url(r&apos;^del_order/&apos;, views.del_order),</span><br><span class="line">url(r&apos;^update_order/&apos;, views.update_order),</span><br></pre></td></tr></table></figure><h4 id="2-restful规范（建议）"><a href="#2-restful规范（建议）" class="headerlink" title="2. restful规范（建议）"></a>2. restful规范（建议）</h4><pre><code>1. 根据method不同做不同的操作</code></pre><p>基于FBV<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def order(request):</span><br><span class="line">    if request.method==&apos;GET&apos;:</span><br><span class="line">        return HttpResponse(&apos;获取订单&apos;)</span><br><span class="line">    elif request.method==&quot;POST&quot;:</span><br><span class="line">        return HttpResponse(&apos;创建订单&apos;)</span><br><span class="line">    elif request.method==&quot;PUT&quot;:</span><br><span class="line">            return HttpResponse(&apos;更新订单&apos;)</span><br><span class="line">    elif request.method==&quot;DELETE&quot;:</span><br><span class="line">            return HttpResponse(&apos;删除订单&apos;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^order/&apos;, views.order),</span><br></pre></td></tr></table></figure><p>基于CBV<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^dog/&apos;, views.DogView.as_view()),</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class OrderView(View):</span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line"></span><br><span class="line">        ret  = &#123;</span><br><span class="line">            &apos;code&apos;:1000,</span><br><span class="line">            &apos;msg&apos;:&apos;xxx&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return HttpResponse(json.dumps(ret),status=201)</span><br><span class="line"></span><br><span class="line">    def post(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&apos;创建订单&apos;)</span><br><span class="line"></span><br><span class="line">    def put(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&apos;更新订单&apos;)</span><br><span class="line"></span><br><span class="line">    def delete(self,request,*args,**kwargs):</span><br><span class="line">        return HttpResponse(&apos;删除订单&apos;)</span><br></pre></td></tr></table></figure><h4 id="3-RESTful-API设计规范"><a href="#3-RESTful-API设计规范" class="headerlink" title="3. RESTful API设计规范"></a>3. RESTful API设计规范</h4><ul><li>API与用户的通信协议，总是使用HTTPs协议。</li><li>域名 <ul><li><a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a>                         尽量将API部署在专用域名（会存在跨域问题）</li><li><a href="https://example.org/api/" target="_blank" rel="noopener">https://example.org/api/</a>                        API很简单</li></ul></li><li>版本<ul><li>URL，如：<a href="https://api.example.com/v1/" target="_blank" rel="noopener">https://api.example.com/v1/</a></li><li>请求头                                                  跨域时，引发发送多次请求</li></ul></li><li>路径，视网络上任何东西都是资源，均使用名词表示（可复数）<ul><li><a href="https://api.example.com/v1/zoos" target="_blank" rel="noopener">https://api.example.com/v1/zoos</a></li><li><a href="https://api.example.com/v1/animals" target="_blank" rel="noopener">https://api.example.com/v1/animals</a></li><li><a href="https://api.example.com/v1/employees" target="_blank" rel="noopener">https://api.example.com/v1/employees</a></li></ul></li><li>method<ul><li>GET      ：从服务器取出资源（一项或多项）</li><li>POST    ：在服务器新建一个资源</li><li>PUT      ：在服务器更新资源（客户端提供改变后的完整资源）</li><li>PATCH  ：在服务器更新资源（客户端提供改变的属性）</li><li>DELETE ：从服务器删除资源</li></ul></li><li>过滤，通过在url上传参的形式传递搜索条件<ul><li><a href="https://api.example.com/v1/zoos?limit=10：指定返回记录的数量" target="_blank" rel="noopener">https://api.example.com/v1/zoos?limit=10：指定返回记录的数量</a></li><li><a href="https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置" target="_blank" rel="noopener">https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置</a></li><li><a href="https://api.example.com/v1/zoos?page=2&amp;per_page=100：指定第几页，以及每页的记录数" target="_blank" rel="noopener">https://api.example.com/v1/zoos?page=2&amp;per_page=100：指定第几页，以及每页的记录数</a></li><li><a href="https://api.example.com/v1/zoos?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序" target="_blank" rel="noopener">https://api.example.com/v1/zoos?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序</a></li><li><a href="https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件" target="_blank" rel="noopener">https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件</a></li></ul></li><li>状态码和code结合使用<ul><li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。<ul><li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li></ul></li><li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li><li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li><li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li><li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li><li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li><li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li><li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li><li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li><li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li><li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li></ul></li></ul><ul><li><p>错误处理，状态码是4xx时，应返回错误信息，error当做key。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: &quot;Invalid API key&quot;</span><br></pre></td></tr></table></figure></li><li><p>返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象</li><li>PUT /collection/resource：返回完整的资源对象</li><li>PATCH /collection/resource：返回完整的资源对象</li><li>DELETE /collection/resource：返回一个空文档</li></ul></li><li><p>Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，推荐使用CBV方式</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式---代理模式（Proxy）（动态代理）</title>
      <link href="/2017/11/05/proxy2/"/>
      <url>/2017/11/05/proxy2/</url>
      <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p> Java动态代理类位于java.lang.reflect包下，一般主要 涉及到以下两个类： </p><p> (1)<strong>Interface InvocationHandler接口</strong>：该接口中仅定义了 一个方法 </p><ul><li><p>public object invoke(Object obj,Method method, Object[] args) </p></li><li><p>在实际使用时，第一个参数obj一般是指代理类，代理实例的方法被调用 第二个参数method是被代理的方法，如上例中的request()，第三个参数args 为该方法的参数数组。 这个抽象方法在代理类中动态实现。</p></li></ul><p>这个接口是由一个代理实例的调用处理器来实现的。</p><p>每一个代理实例都会有一个与之关联的调用处理器。当我们调用一个代理实例的某一个方法的时候，这个方法调用就会被编码并且被派发到与之关联的他的调用处理器的invoke方法上，被调用。</p><p>invoke方法会处理代理实例上的一个方法调用，并且将真正的调用结果返回回来。当一个调用处理器关联到这个处理器的某个代理实例，我们调用这个代理实例上的某个方法的时候，这个方法就会转移到与这个实例所关联的那个调用处理器的invoke方法，由它帮我们完成调用。</p><p>(2)<strong>Proxy</strong>：该类即为动态代理类，作用类似于上例中的</p><p>Proxy提供了一些静态方法用于创建动态代理类和实例，他也是由这些方法所创建的动态代理类的一个父类。</p><p>ProxySubject，其中主要包含以下内容</p><ul><li><p>protected Proxy(InvocationHandler h)：构造函数， 用于给内部的h赋值。</p></li><li><p>static Class getProxyClass (ClassLoader loader, Class[] interfaces)：获得一个代理类，其中loader是 类装载器，interfaces是真实类所拥有的全部接口的数组 。</p></li><li><p>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)： <strong>返回代理类的一个实例</strong>，返回后的代理类可以当作被代理 类使用(可使用被代理类的在Subject接口中声明过的方法 )</p></li><li><p>所谓Dynamic Proxy是这样一种class： 它是在<strong>运行时生成</strong>的class，<strong>在生成它时你 必须提供一组interface给它，然后该class 就宣称它实现了这些 interface</strong>。你当然可 以把该class的实例当作这些interface中的 任何一个来用(多态)。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作 实质性的工作，在生成它的实例时你必须 提供一个handler，由它接管实际的工作</p></li><li><p>在使用动态代理类时，我们必须实现 InvocationHandler接口 </p></li></ul><h6 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">System.out.println(&quot;from real subject&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该代理类的内部属性是Object类型，实际使用的时候通过该类的构造方法传递进来一个对象</span><br><span class="line"> * 此外，该类还实现了invoke方法，该方法中的method.invoke其实就是调用被代理对象的将要</span><br><span class="line"> * 执行的方法，方法参数是sub，表示该方法从属于sub，通过动态代理类，我们可以在执行真实对象的方法前后</span><br><span class="line"> * 加入自己的一些额外方法。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DynamicSubject implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">//真实对象的引用，因为是动态代理，他可以代理任意一个对象，所以就要定义为Object类型。如果是RealSubject就很受限制了。</span><br><span class="line">private Object sub;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public  DynamicSubject(Object object) &#123;</span><br><span class="line">   this.sub=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;before calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">//使用的是反射，进行的调用</span><br><span class="line">method.invoke(sub, args);</span><br><span class="line"></span><br><span class="line">System.out.println(args==null);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">//这个例子没有返回值，直接返回空就可以</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">RealSubject realSubject = new RealSubject();</span><br><span class="line"></span><br><span class="line">//多态</span><br><span class="line">//代理谁就传谁</span><br><span class="line">InvocationHandler handler = new DynamicSubject(realSubject);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=handler.getClass();</span><br><span class="line"></span><br><span class="line">     //下面的代码一次性生成代理</span><br><span class="line">//第一个参数为类装载器，通过Class类可以获得，我们现在要动态的生成类了，这个类是由哪个类装载器装载的呢</span><br><span class="line">//代理类返回的是一个Object类型的，需要转换类型</span><br><span class="line">//运行的时候生成一个class，然后生成class类的一个对象</span><br><span class="line">Subject subject=(Subject)Proxy.newProxyInstance(classType.getClassLoader(),</span><br><span class="line">realSubject.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">subject.request();</span><br><span class="line"></span><br><span class="line">System.out.println(subject.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before calling:public abstract void com.suixin.pattern.dynamicsubject.Subject.request()</span><br><span class="line">from real subject</span><br><span class="line">null</span><br><span class="line">after calling:public abstract void com.suixin.pattern.dynamicsubject.Subject.request()</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br></pre></td></tr></table></figure><p><strong>只要使用动态代理类，有一个动态代理类就会有一个InvocationHandler，他们总是相互关联的。</strong>代理类并不会真正的完成方法的调用，而都是由与之关联的InvocationHandler的invoke方法真正完成目标方法的调用。</p><p>下面通过这个例子，我来给大家详细的介绍一下执行的流程和注意事项，详细步骤解读：</p><ol><li><p>首先进行实例化，实例化已经知道的我们需要用到的类，也就是说实例化RealSubject和DynamicSubject，这里用到了多态的知识点，这里我给大家补充一下， <strong>多态：所谓多态，就是父类型的引用可以指向子类型的对象，或者接口类型的引用可以指向实现该接口的类的实例。关于接口与实现接口的类之间的强制类型转换方式与父类和子类之间的强制类型转换方式完全一样。</strong></p><pre><code> RealSubject realSubject = new RealSubject();//多态//因为这里是动态代理，代理的对象不能指定为一个，所以代理谁就传谁InvocationHandler handler = new DynamicSubject(realSubject);</code></pre></li><li><p>获得调用处理器的Class对象，这里使用的是getClass（）方法。获得这个Class对象是为了生成代理的时候使用。</p></li></ol><p>3.一次性生成代理实例，这里的生成实例，既不是真实对象的实例也不是代理对象DynamicSubject的实例，而是java在运行的时候生成的一个Class类，然后生成这个Class类的一个对象。</p><pre><code>Subject subject=(Subject)Proxy.newProxyInstance(classType.getClassLoader(),realSubject.getClass().getInterfaces(), handler);</code></pre><p>第一个参数为类加载器，通过Class类可以获得，我们现在要动态的生成类了，这个类是由哪个类装载器装载的呢，因为我们要动态的生成一个代理角色的类，而代理角色类的方法都是由调用处理器来实现的，所以这个类加载器就是调用处理器也就是代理角色的类加载器，classType.getClassLoader()。这个类的实例宣称实现了真实角色实现的所有的接口，也就是realSubject.getClass().getInterfaces()这些接口，所以生成出来的那个对象我们可以将其转换成Subject类型，（不要装换为对应的具体的实现类类型，因为并不知道他对应了那些实现类），装换之后正常的调用方法就可以了。</p><p><strong>生成动态代理类，而与之关联的调用处理器就是DynamicSubject</strong></p><p>4.调用方法的时候，就会转而由InvocationHandler的invoke方法来执行，并且将参数也分别传递过去。就会执行invoke（）方法，执行完之后再回到Client继续执行下面的代码。这就实现了动态代理，over。</p><hr><p>通过这种方式，被代理的对象 (RealSubject)可以在运行时动态改变，需 要控制的接口(Subject接口)可以在运行时 改变，控制的方式(DynamicSubject类) 也可以动态改变，从而实现了非常灵活的 动态代理关系</p><ul><li>动态代理是指客户通过代理类来调用其它 对象的方法</li><li><p>动态代理使用场合:</p><p> 调试 </p><p> 远程方法调用(RMI)</p></li></ul><p><img src="http://img.blog.csdn.net/20171113172042542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>实现动态代理的步骤：</p><ol><li>创建一个实现接口InvocationHandler的 类，它必须实现invoke方法</li><li>创建被代理的类以及接口</li><li>通过Proxy的静态方法 newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个代理 </li><li>通过代理调用方法</li></ol><p>我想大家对于代理模式已经有了一个了解了，但是我们为了更好的掌握它，还是得再巩固一下，我们练习一下带有参数传递的动态代理模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class VectorProxy implements InvocationHandler&#123;</span><br><span class="line">private Object proxyObj;</span><br><span class="line"></span><br><span class="line">public VectorProxy(Object object) &#123;</span><br><span class="line">this.proxyObj=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Object factory(Object object) &#123;</span><br><span class="line">Class&lt;?&gt; classType=object.getClass();</span><br><span class="line"></span><br><span class="line">return Proxy.newProxyInstance(classType.getClassLoader(), </span><br><span class="line">classType.getInterfaces(), new VectorProxy(object));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;before calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">if(null!=args) &#123;</span><br><span class="line">for(Object object:args) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object=method.invoke(proxyObj, args);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after calling :&quot;+method);</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//vList是运行时动态生成的类的实例</span><br><span class="line">List vList=(List) factory(new Vector());</span><br><span class="line"></span><br><span class="line">//我们把这个动态生成的实例的名字打印出来</span><br><span class="line">System.out.println(vList.getClass().getName());</span><br><span class="line"></span><br><span class="line">vList.add(&quot;new&quot;);</span><br><span class="line">vList.add(&quot;York&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(vList);</span><br><span class="line"></span><br><span class="line">vList.remove(0);</span><br><span class="line">System.out.println(vList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">before calling:public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">new</span><br><span class="line">after calling :public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">before calling:public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">York</span><br><span class="line">after calling :public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line"></span><br><span class="line">before calling:public java.lang.String java.lang.Object.toString()</span><br><span class="line">after calling :public java.lang.String java.lang.Object.toString()</span><br><span class="line">[new, York]</span><br><span class="line">before calling:public abstract java.lang.Object java.util.List.remove(int)</span><br><span class="line">0</span><br><span class="line">after calling :public abstract java.lang.Object java.util.List.remove(int)</span><br><span class="line">before calling:public java.lang.String java.lang.Object.toString()</span><br><span class="line">after calling :public java.lang.String java.lang.Object.toString()</span><br><span class="line">[York]</span><br></pre></td></tr></table></figure><p>我们一起来分析一下这个程序，其实原理都是一样的。我把所有的内容写到了一个类里面。</p><ol><li>首先从入口开始说起吧，定义了List，vList是运行时动态生成的类的实例。也就是factory方法的返回值。factory方法有一个参数object代表着传入的要代理的对象。factory返回的值是Object，但是newProxyInstance生成的类是实现了传入的参数所实现的所有的方法，new Vector（）实现了List的接口，那么动态代理也肯定实现了这个接口，可以通过强制类型转换为List类型。</li><li>然后调用add方法，传入一个“new”进去，当你调用生成代理对象的任何一个方法，都会立刻转由invoke方法执行。将参数传给invoke方法，我们遍历参数的数组args就会打印出来。继续执行invoke方法，执行完之后，再回来执行add（“york”）;再重复上面的执行过程。</li><li>我们打印出来vList看看是什么，其实和上面的过程是一样的，打印vList相当于调用了vList.toString();方法，过程和上面调用方法的步骤一致，只是没有传参数而已。<br>4.调用remove方法也是同样的道理，我就不再重复了。</li></ol><p>动态代理是能够用一个动态代理类，代理多个真实对象，那么我们举例来看一下，这里我就不详细的介绍了。</p><p>公共的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Foo &#123;</span><br><span class="line">void doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个真实的角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FoolImp1 implements Foo&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doAction() &#123;</span><br><span class="line">System.out.println(&quot;in FooImpl doAction&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个真实角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class FooImpl2 implements Foo &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doAction() &#123;</span><br><span class="line">System.out.println(&quot;in FooImp2 doAction&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class CommonInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">private Object object;</span><br><span class="line"> public CommonInvocationHandler(Object object) &#123;</span><br><span class="line">this.object=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public CommonInvocationHandler() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> public void setObject(Object object) &#123;</span><br><span class="line">this.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代理角色</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">return method.invoke(object, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.logging.Handler;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">CommonInvocationHandler cHandler=new CommonInvocationHandler();</span><br><span class="line"></span><br><span class="line">Foo foo=null;</span><br><span class="line"></span><br><span class="line">cHandler.setObject(new FoolImp1());</span><br><span class="line"></span><br><span class="line">foo=(Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(), </span><br><span class="line">new Class[] &#123;Foo.class&#125;, cHandler);</span><br><span class="line"></span><br><span class="line">foo.doAction();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;==================================================&quot;);</span><br><span class="line"></span><br><span class="line">cHandler.setObject(new FooImpl2());</span><br><span class="line"></span><br><span class="line">foo=(Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">new Class[] &#123;Foo.class&#125;, cHandler);</span><br><span class="line"></span><br><span class="line">foo.doAction();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in FooImpl doAction</span><br><span class="line">==================================================</span><br><span class="line">in FooImp2 doAction</span><br></pre></td></tr></table></figure><p>这个例子中FoolImp1、FoolImp2是两个真实的角色，用一个代理Proxy代理他们两个，通过在运行时期生成动态代理实例来代理，完成真实角色要实现的方法，其实，方法都是在invoke方法中得到真实调用的，代理实例不会真正的真实角色的方法，最终还是由真实角色里实现的。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式----代理模式（Proxy）（静态代理模式）</title>
      <link href="/2017/10/22/proxy/"/>
      <url>/2017/10/22/proxy/</url>
      <content type="html"><![CDATA[<h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>代理模式分为静态代理和动态代理，有代理对象叫做静态代理，没有代理对象叫做动态代理</p><p>代理模式的作用是：为其他对象提供一个代理以控制对这个对象的访问。<br>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>代理模式一般涉及到的角色：</p><ul><li>抽象角色：声明真实对象和代理对象的<strong>共同接口</strong></li><li>代理对象：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时代理对象可以在执行真实对象操作时，附加其他操作，相当于对真实对象进行封装</li><li>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理模式比较抽象，我们利用代码例子来理解。</p><h6 id="抽象角色"><a href="#抽象角色" class="headerlink" title="抽象角色"></a>抽象角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色</span><br><span class="line">public abstract class Subject &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;form real subject&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ProxySubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">private RealSubject realsubject; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void proRequest() &#123;</span><br><span class="line">System.out.println(&quot;pro request&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">this.proRequest();</span><br><span class="line"></span><br><span class="line">if(realsubject==null) &#123;</span><br><span class="line">realsubject = new RealSubject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">realsubject.request();</span><br><span class="line"></span><br><span class="line">this.postRequest();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void postRequest() &#123;</span><br><span class="line">System.out.println(&quot;post quest&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ProxySubject proxySubject = new ProxySubject();</span><br><span class="line">proxySubject.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pro request</span><br><span class="line">form real subject</span><br><span class="line">post quest</span><br></pre></td></tr></table></figure><ul><li>由以上代码可以看出，客户实际需要调用的是 RealSubject类的request()方法，现在用ProxySubject 来代理 RealSubject类，同样达到目的，同时还封装了 其他方法(preRequest(),postRequest())，可以处理一 些其他问题。 </li><li>另外，<strong>如果要按照上述的方法使用代理模式，那么真实角 色必须是事先已经存在的，并将其作为代理对象的内部属性。</strong>但是实际使用时，一个真实角色必须对应一个代理 角色，如果大量使用会导致类的急剧膨胀；此外，如果事 先并不知道真实角色，该如何使用代理呢？这个问题可以 通过Java的动态代理类来解决</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>数据分析-----pandas,数据加载，透视表和交叉表</title>
      <link href="/2017/10/15/pandas/"/>
      <url>/2017/10/15/pandas/</url>
      <content type="html"><![CDATA[<h1 id="数据分析知识点"><a href="#数据分析知识点" class="headerlink" title="数据分析知识点"></a>数据分析知识点</h1><ul><li>数据加载</li><li>透视表和交叉表</li><li>pandas中的绘图函数</li><li>数据加载</li></ul><h2 id="pandas中的绘图函数"><a href="#pandas中的绘图函数" class="headerlink" title="pandas中的绘图函数"></a>pandas中的绘图函数</h2><p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线形图</p><h2 id="线形图"><a href="#线形图" class="headerlink" title="线形图"></a>线形图</h2><p>简单的Series图表示例,plot()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">2010</span>,<span class="number">2018</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>array([2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Series(index = np.arange(<span class="number">2010</span>,<span class="number">2018</span>,<span class="number">1</span>),data = [<span class="number">100</span>,<span class="number">110</span>,<span class="number">90</span>,<span class="number">300</span>,<span class="number">700</span>,<span class="number">2000</span>,<span class="number">5000</span>,<span class="number">10000</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.plot()</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162512105?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(-np.pi,np.pi,<span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x) + <span class="number">2</span>*np.cos(x)</span><br><span class="line">s1 = Series(index=x,data=y)</span><br><span class="line">s1.plot(kind=<span class="string">'line'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162616104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>简单的DataFrame图表示例,plot()</p><ul><li>图例的位置可能会随着数据的不同而不同</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">columns = [<span class="string">'dancer'</span>,<span class="string">'lucy'</span>,<span class="string">'mery'</span>]</span><br><span class="line">index = [<span class="string">'first'</span>,<span class="string">'second'</span>,<span class="string">'third'</span>,<span class="string">'fouth'</span>]</span><br><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">150</span>,size=(<span class="number">4</span>,<span class="number">3</span>))</span><br><span class="line">df = DataFrame(data=data,index=index,columns=columns)</span><br><span class="line">df.plot()</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162656413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">score = pd.read_excel(<span class="string">'score.xls'</span>)</span><br><span class="line"><span class="comment"># 版面的绘制</span></span><br><span class="line">score.plot()</span><br><span class="line"><span class="comment"># 图片保存</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162715890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>Series柱状图示例,kind = ‘bar’/‘barh’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Series(index=[<span class="string">'dancer'</span>,<span class="string">'mery'</span>,<span class="string">'lucy'</span>],data=[<span class="number">100</span>,<span class="number">98</span>,<span class="number">60</span>])</span><br><span class="line">s.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162738014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>DataFrame柱状图示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,size=(<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line">index = list(<span class="string">'ABCDE'</span>)</span><br><span class="line">columns = [<span class="string">'python'</span>,<span class="string">'java'</span>,<span class="string">'php'</span>]</span><br><span class="line">df = DataFrame(data=data,index=index,columns=columns)</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162757152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.plot(kind=<span class="string">'barh'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162815107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.plot(kind=<span class="string">'barh'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162834581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>读取文件tips.csv，查看每天的聚会人数情况<br>每天各种聚会规模的比例  </p><p>求和并df.sum()，注意灵活使用axis</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tips = pd.read_csv(<span class="string">'tips.csv'</span>)</span><br><span class="line">tips</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把一列变成索引</span></span><br><span class="line">data = tips.set_index(<span class="string">'day'</span>)</span><br><span class="line"><span class="comment"># 把索引变成列</span></span><br><span class="line"><span class="comment"># tips.reset_index()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162858589?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每一行的和</span></span><br><span class="line">index_sum = data.sum(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每天每种聚会人数所占比例</span></span><br><span class="line">result = data.div(index_sum,axis=<span class="number">0</span>)</span><br><span class="line">result.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162926626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>rondom生成随机数百分比直方图，调用hist方法</p><ul><li>柱高表示数据的频数，柱宽表示各组数据的组距</li><li>参数bins可以设置直方图方柱的个数上限，越大柱宽越小，数据分组越细致</li><li>设置normed参数为True，可以把频数转换为概率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = Series(data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>])</span><br><span class="line"><span class="comment"># 直方图会受到bins（数据分区的个数）影响很大</span></span><br><span class="line"><span class="comment"># 设置normed参数为True，直方图表示的是每一个数出现的概率</span></span><br><span class="line">s.plot(kind=<span class="string">'hist'</span>,bins=<span class="number">3</span>,normed=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 为了避免歧义，直方图会跟核密度估计函数一起使用</span></span><br><span class="line">s.plot(kind=<span class="string">'kde'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415162948510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415163007100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>kde图：核密度估计，用于弥补直方图由于参数bins设置的不合理导致的精度缺失问题</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>绘制一个由两个不同的标准正态分布组成的的双峰分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成两个一维数组，符合正太分布，期望值分别为0和20</span></span><br><span class="line">x1 = Series(np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">3</span>,size=<span class="number">100</span>))</span><br><span class="line">x2 = Series(np.random.normal(loc=<span class="number">20</span>,scale=<span class="number">5</span>,size=<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 级联两个Series对象并重置索引</span></span><br><span class="line">s = pd.concat((x1,x2),ignore_index=<span class="keyword">True</span>)</span><br><span class="line">s</span><br></pre></td></tr></table></figure><pre><code>0       3.2498731      -2.5894942      -2.2472923      -2.1273964       0.5211595      -6.0841716       1.6863597      -2.5650048      -0.6473329       4.16178810     -2.92424111     -1.93811812      1.25932413      0.94138514     -4.31689215      0.08534816     -2.21387317     -0.80942318     -2.91722019     -2.67285620     -2.06679921      1.86561622     -1.85250323      3.60444224     -1.41106325      0.16538626     -1.33743527      3.75438728     -6.19920029      3.019002         ...    170    22.595197171    23.492841172    22.738205173    14.255180174    22.229389175    19.190084176    22.902848177    14.744843178    18.963592179    29.699166180    14.663104181    26.470372182    24.512165183    27.617378184    12.798938185    18.160538186    18.083601187    22.163000188    17.011587189    22.897459190    26.887293191    15.718268192    21.277874193    18.267735194    18.242399195    27.474724196    34.169240197    22.959591198    21.693334199    21.558861Length: 200, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.plot(kind=<span class="string">'hist'</span>,normed=<span class="keyword">True</span>)</span><br><span class="line">s.plot(kind=<span class="string">'kde'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415163032405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="散布图"><a href="#散布图" class="headerlink" title="散布图"></a>散布图</h2><p>散布图<br>散布图是观察两个一维数据数列之间的关系的有效方法,DataFrame对象可用 </p><p>使用方法：<br>设置kind = ‘scatter’，给明标签columns</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.normal(size=(<span class="number">1000</span>,<span class="number">4</span>))</span><br><span class="line">columns = list(<span class="string">'ABCD'</span>)</span><br><span class="line">df = DataFrame(data=data,columns=columns)</span><br><span class="line">df.plot(x=<span class="string">'A'</span>,y=<span class="string">'B'</span>,kind=<span class="string">'scatter'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415163051051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>散布图矩阵，当有多个点时，两两点的关系  </p><p>使用函数：pd.plotting.scatter_matrix(),</p><ul><li>参数diagnol：设置对角线的图像类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.plotting.scatter_matrix(df,diagonal=<span class="string">'kde'</span>)</span><br></pre></td></tr></table></figure><pre><code>array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x15A2BDF0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x156A1AF0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x155F4EB0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x13D37570&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1562AED0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1562AE90&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16EAA690&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16EF41F0&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x16F17230&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16F2CF70&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16F51C70&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16F799F0&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x16F9F890&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16F22710&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x16FE28F0&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x170068F0&gt;]],      dtype=object)</code></pre><p><img src="http://img.blog.csdn.net/20180415163116532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><h3 id="pandas提供了一些用于将表格型数据读取为DataFrame对象的函数，期中read-csv和read-table这两个使用最多"><a href="#pandas提供了一些用于将表格型数据读取为DataFrame对象的函数，期中read-csv和read-table这两个使用最多" class="headerlink" title="pandas提供了一些用于将表格型数据读取为DataFrame对象的函数，期中read_csv和read_table这两个使用最多"></a>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数，期中read_csv和read_table这两个使用最多</h3><p>首先查看文本文件</p><ul><li><p>使用read_csv将其读入</p></li><li><p>使用read_table读取</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'data/type-.txt'</span>,sep=<span class="string">'-'</span>,header=<span class="keyword">None</span>)</span><br><span class="line">data.columns = [<span class="string">'汇源'</span>,<span class="string">'果汁'</span>,<span class="string">'鸟'</span>]</span><br><span class="line">data</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table = pd.read_table(<span class="string">'data/type_comma'</span>,sep=<span class="string">','</span>,header=<span class="keyword">None</span>)</span><br><span class="line">table</span><br></pre></td></tr></table></figure><p>使用read_excel()读取excel表格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table = pd.read_excel(<span class="string">'data/students.xlsx'</span>,sheet_name=<span class="number">1</span>)</span><br><span class="line">table</span><br></pre></td></tr></table></figure><p>写入excel文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.to_excel(<span class="string">'dancer.xlsx'</span>)</span><br></pre></td></tr></table></figure><p>读取sqlite文件</p><p>导包  import sqlite3 as sqlite3</p><ul><li><p>连接数据库<br>  sqlite3.connect(‘dbpath’)</p></li><li><p>读取table内容<br>  pd.read_sql(“SQL语句”, con)</p></li><li><p>写入数据库文件<br>  df对象.to_sql(‘dbpath’,connection)</p></li><li><p>操作数据库<br>  connection.execute(SQL语句)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">as</span> sqlite3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SQL server  MongoDB  Redis</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection = sqlite3.connect(<span class="string">'data/weather_2012.sqlite'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_sql(<span class="string">'select * from weather_2012'</span>,connection)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.to_sql(<span class="string">'dancer'</span>,connection)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_sql(<span class="string">'select * from dancer'</span>,connection)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drop table dancer</span></span><br><span class="line">connection.execute(<span class="string">'drop table dancer'</span>)&lt;sqlite3.Cursor at <span class="number">0x130953e0</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_sql(<span class="string">'select * from dancer'</span>,connection)</span><br></pre></td></tr></table></figure><pre><code>--------------------------------------------------------------------------</code></pre><p>设置行索引index_col</p><p>写入sql文件</p><p>使用read_csv读取url获取网络上的数据<br>url = ‘<a href="https://raw.githubusercontent.com/datasets/investor-flow-of-funds-us/master/data/weekly.csv&#39;" target="_blank" rel="noopener">https://raw.githubusercontent.com/datasets/investor-flow-of-funds-us/master/data/weekly.csv&#39;</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'https://raw.githubusercontent.com/datasets/investor-flow-of-funds-us/master/data/weekly.csv'</span></span><br><span class="line"></span><br><span class="line">pd.read_csv(url)</span><br></pre></td></tr></table></figure><h2 id="透视表和交叉表"><a href="#透视表和交叉表" class="headerlink" title="透视表和交叉表"></a>透视表和交叉表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df = DataFrame(&#123;'sex':['man','man','women','women','man','women','man','women','women'],</span></span><br><span class="line"><span class="comment">#                'age':[15,23,25,17,35,57,24,31,22],</span></span><br><span class="line"><span class="comment">#                'smoke':[True,False,False,True,True,False,False,True,False],</span></span><br><span class="line"><span class="comment">#                'height':[168,179,181,166,173,178,188,190,160]&#125;)</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'foo'</span>: [<span class="string">'one'</span>,<span class="string">'one'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'two'</span>,<span class="string">'two'</span>],</span><br><span class="line">                       <span class="string">'bar'</span>: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">                       <span class="string">'baz'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot_table(index=<span class="string">'smoke'</span>,columns=<span class="string">'sex'</span>,aggfunc=max)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot(index=<span class="string">'bar'</span>,columns=<span class="string">'foo'</span>,values=<span class="string">'baz'</span>)</span><br></pre></td></tr></table></figure><h3 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a>透视表</h3><p>各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中</p><p>行分组透视表 设置index参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot(index=<span class="string">'sex'</span>,columns=)</span><br></pre></td></tr></table></figure><p>列分组透视表 设置columns参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> pivot_table</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(&#123;<span class="string">'sex'</span>:[<span class="string">'man'</span>,<span class="string">'man'</span>,<span class="string">'women'</span>,<span class="string">'women'</span>,<span class="string">'man'</span>,<span class="string">'women'</span>,<span class="string">'man'</span>,<span class="string">'women'</span>,<span class="string">'women'</span>],</span><br><span class="line">               <span class="string">'age'</span>:[<span class="number">15</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">35</span>,<span class="number">57</span>,<span class="number">24</span>,<span class="number">31</span>,<span class="number">22</span>],</span><br><span class="line">               <span class="string">'smoke'</span>:[<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">False</span>],</span><br><span class="line">               <span class="string">'height'</span>:[<span class="number">168</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">166</span>,<span class="number">173</span>,<span class="number">178</span>,<span class="number">188</span>,<span class="number">190</span>,<span class="number">160</span>]&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivot_table(df,values=<span class="string">'age'</span>,index=[<span class="string">'sex'</span>],columns=[<span class="string">'smoke'</span>],aggfunc=<span class="string">'min'</span>)</span><br></pre></td></tr></table></figure><p>行列分组的透视表  同时设定index、columns参数</p><p>aggfunc：设置应用在每个区域的聚合函数，默认值为np.mean</p><p>fill_value：替换结果中的缺失值</p><h3 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a>交叉表</h3><p>是一种用于计算分组频率的特殊透视图,对数据进行汇总</p><p>pd.crosstab(index,colums)</p><ul><li>index:分组数据，交叉表的行索引</li><li>columns:交叉表的列索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="string">"foo"</span>, <span class="string">"foo"</span>, <span class="string">"foo"</span>, <span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"bar"</span>,<span class="string">"bar"</span>, <span class="string">"bar"</span>, <span class="string">"foo"</span>, <span class="string">"foo"</span>, <span class="string">"foo"</span>], dtype=object)</span><br><span class="line">b = np.array([<span class="string">"one"</span>, <span class="string">"one"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"one"</span>, <span class="string">"one"</span>,<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"one"</span>], dtype=object)</span><br><span class="line">c = np.array([<span class="string">"dull"</span>, <span class="string">"dull"</span>, <span class="string">"shiny"</span>, <span class="string">"dull"</span>, <span class="string">"dull"</span>, <span class="string">"shiny"</span>,<span class="string">"shiny"</span>, <span class="string">"dull"</span>, <span class="string">"shiny"</span>, <span class="string">"shiny"</span>, <span class="string">"shiny"</span>],dtype=object)</span><br><span class="line">pd.crosstab(a, [b, c], rownames=[<span class="string">'a'</span>], colnames=[<span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table = pd.read_csv(<span class="string">'stock2015-2016.csv'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 'AAPL', 'MSFT', 'GE', 'IBM', 'AA', 'DAL', 'UAL', 'PEP', 'KO'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table[<span class="string">'Ticker'</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;AAPL&apos;, &apos;MSFT&apos;, &apos;GE&apos;, &apos;IBM&apos;, &apos;AA&apos;, &apos;DAL&apos;, &apos;UAL&apos;, &apos;PEP&apos;, &apos;KO&apos;],      dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按照每天查看苹果股票的收盘价格</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adj_table = table.pivot(index=<span class="string">'Date'</span>,columns=<span class="string">'Ticker'</span>,values=<span class="string">'Adj Close'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">adj_table.plot()</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415164318157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adj_table[<span class="string">'AAPL'</span>].plot()</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180415164336700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adj_table.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.groupby([<span class="string">'Ticker'</span>,<span class="string">'Date'</span>])[<span class="string">'Adj Close'</span>].mean().unstack(level=<span class="number">0</span>).head()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/yuansuixin/learn-data-analysis" title="下载" target="_blank" rel="noopener">相关数据及源码下载</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Django的两种实现方式----CBV,FBV</title>
      <link href="/2017/09/17/cbv-fbv/"/>
      <url>/2017/09/17/cbv-fbv/</url>
      <content type="html"><![CDATA[<h2 id="CBV，FBV"><a href="#CBV，FBV" class="headerlink" title="CBV，FBV"></a>CBV，FBV</h2><ul><li><p>开发模式</p><ul><li>普通开发方式(前后端放在一起写)</li><li>前后端分离<ul><li>所有的交互都是ajax实现的</li><li>为前端提供URL（api/接口的开发）<br>注意：永远返回HttpResponse</li></ul></li><li><p>Django FBV  CBV</p><ul><li><p>FBV  function base  view</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def users(request):</span><br><span class="line">user_list = [&apos;alex&apos;,&apos;oldboy&apos;]</span><br><span class="line">return HttpResponse(json.dumps(user_list))</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^users/&apos;, views.users),</span><br></pre></td></tr></table></figure></li><li><p>CBV  class  base view</p><ul><li>只要是基于CBV的框架几乎都是使用反射实现的，也就是根据method不同，执行getattr获取到，然后执行相应的方法</li></ul></li></ul></li></ul></li></ul><p>视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class StudentsView(View):</span><br><span class="line">   </span><br><span class="line">   #继承自Django的view视图，在url里调用as_view()方法，这个固定搭配</span><br><span class="line">   #以不同的方式请求的时候，Django内部就会自动的选择调用不同的函数</span><br><span class="line">   </span><br><span class="line">   def get(self,request,*args,**kwargs):</span><br><span class="line">       return HttpResponse(&apos;GET&apos;)</span><br><span class="line">   def post(self,request,*args,**kwargs):</span><br><span class="line">       return HttpResponse(&apos;POST&apos;)</span><br><span class="line">   def put(self,request,*args,**kwargs):</span><br><span class="line">       return HttpResponse(&apos;PUT&apos;)</span><br><span class="line">   def delete(self,request,*args,**kwargs):</span><br><span class="line">       return HttpResponse(&apos;DELETE&apos;)</span><br></pre></td></tr></table></figure><p>路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^students/&apos;,views.StudentsView.as_view())</span><br></pre></td></tr></table></figure></p><ul><li>列表生成式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> class Foo:</span><br><span class="line"> pass</span><br><span class="line"> class Bar:</span><br><span class="line"> pass</span><br><span class="line"></span><br><span class="line"># 对象列表</span><br><span class="line">v = [item() for item in [Foo,Bar]]</span><br><span class="line"></span><br><span class="line"># 上面的对象列表就相当于下面代码的简写</span><br><span class="line">v = []</span><br><span class="line">for i in [Foo,Bar]:</span><br><span class="line">obj = i()</span><br><span class="line">v.append(obj)</span><br></pre></td></tr></table></figure><ul><li>面向对象<ul><li>封装<ul><li>类可以对同一类的方法进行封装</li><li>将数据封装到对象中</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line"></span><br><span class="line">class Request(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self,obj):</span><br><span class="line">        self.obj = obj</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def user(self):</span><br><span class="line">        return self.obj.authticate()</span><br><span class="line"></span><br><span class="line">class Auth(object):</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def authticate(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class APIView(object):</span><br><span class="line"></span><br><span class="line">    def dispatch(self):</span><br><span class="line">        self.f2()</span><br><span class="line"></span><br><span class="line">    def f2(self):</span><br><span class="line">        a = Auth(&apos;alex&apos;,18)</span><br><span class="line">        b = Auth(&apos;oldboy&apos;,18)</span><br><span class="line">        # b是一个Auth对象，将这个Auth对象封装到Request对象里</span><br><span class="line">        req = Request(b)</span><br><span class="line">        # 调用Request类的user方法，但是因为user方法使用了property装饰器，所以</span><br><span class="line">        # 调用的时候不需要加括号</span><br><span class="line">        # 电泳Request的user（）方法，req对象里的obj变量是一个Auth对象，调用req对象里的</span><br><span class="line">        # Auth对象中的authticate（）方法，返回该Auth对象的name属性，也就是oldboy</span><br><span class="line">        print(req.user)</span><br><span class="line"></span><br><span class="line">#对象通过点能够调用出来就说明这个对象里有什么，</span><br><span class="line">obj = APIView()</span><br><span class="line">obj.dispatch()</span><br></pre></td></tr></table></figure><h2 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h2><h3 id="0-FBV-CBV"><a href="#0-FBV-CBV" class="headerlink" title="0.FBV,CBV"></a>0.FBV,CBV</h3><ul><li>表现： CBV 基于反射实现根据请求方式不同，执行不同方法</li><li><p>原理:</p><ul><li><p>在URl里调用的永远是方法，</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^students/&apos;,views.StudentsView.as_view())</span><br></pre></td></tr></table></figure><ul><li>我们这里调用的是StudentsView类的父类View类的as_view()方法，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@classonlymethod</span><br></pre></td></tr></table></figure></li></ul><p>def as_view(cls, **initkwargs):<br>   “””<br>   Main entry point for a request-response process.<br>   “””<br>   for key in initkwargs:</p><pre><code>if key in cls.http_method_names:    raise TypeError(&quot;You tried to pass in the %s method name as a &quot;                    &quot;keyword argument to %s(). Don&apos;t do that.&quot;                    % (key, cls.__name__))if not hasattr(cls, key):    raise TypeError(&quot;%s() received an invalid keyword %r. as_view &quot;                    &quot;only accepts arguments that are already &quot;                    &quot;attributes of the class.&quot; % (cls.__name__, key))</code></pre><p>   def view(request, *args, **kwargs):<br>   #创建了一个当前对象</p><pre><code>self = cls(**initkwargs)if hasattr(self, &apos;get&apos;) and not hasattr(self, &apos;head&apos;):    self.head = self.getself.request = requestself.args = argsself.kwargs = kwargs# 调用了dispath方法return self.dispatch(request, *args, **kwargs)</code></pre><p>   view.view_class = cls<br>   view.view_initkwargs = initkwargs</p><h1 id="take-name-and-docstring-from-class"><a href="#take-name-and-docstring-from-class" class="headerlink" title="take name and docstring from class"></a>take name and docstring from class</h1><p>   update_wrapper(view, cls, updated=())</p><h1 id="and-possible-attributes-set-by-decorators"><a href="#and-possible-attributes-set-by-decorators" class="headerlink" title="and possible attributes set by decorators"></a>and possible attributes set by decorators</h1><h1 id="like-csrf-exempt-from-dispatch"><a href="#like-csrf-exempt-from-dispatch" class="headerlink" title="like csrf_exempt from dispatch"></a>like csrf_exempt from dispatch</h1><p>   update_wrapper(view, cls.dispatch, assigned=())</p><h1 id="返回view这个方法"><a href="#返回view这个方法" class="headerlink" title="返回view这个方法"></a>返回view这个方法</h1><p>   return view</p><pre><code>def dispatch(self, request, *args, **kwargs):</code></pre><h1 id="Try-to-dispatch-to-the-right-method-if-a-method-doesn’t-exist"><a href="#Try-to-dispatch-to-the-right-method-if-a-method-doesn’t-exist" class="headerlink" title="Try to dispatch to the right method; if a method doesn’t exist,"></a>Try to dispatch to the right method; if a method doesn’t exist,</h1><h1 id="defer-to-the-error-handler-Also-defer-to-the-error-handler-if-the"><a href="#defer-to-the-error-handler-Also-defer-to-the-error-handler-if-the" class="headerlink" title="defer to the error handler. Also defer to the error handler if the"></a>defer to the error handler. Also defer to the error handler if the</h1><h1 id="request-method-isn’t-on-the-approved-list"><a href="#request-method-isn’t-on-the-approved-list" class="headerlink" title="request method isn’t on the approved list."></a>request method isn’t on the approved list.</h1><p>   if request.method.lower() in self.http_method_names:</p><h1 id="获取到method的方式，调用相对应的方法"><a href="#获取到method的方式，调用相对应的方法" class="headerlink" title="获取到method的方式，调用相对应的方法"></a>获取到method的方式，调用相对应的方法</h1><pre><code>handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</code></pre><p>   else:</p><pre><code>handler = self.http_method_not_allowed</code></pre><p>   return handler(request, *args, **kwargs)</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    - CBV流程，就是url中调用该视图类的as_views()方法，这个是固定的写法，as_views()方法在父类View类也就是Django封装好的View类中，它返回一个函数，在这个函数中创建了一个对象，并且调用了该对象的dispatch（）方法，在dispath()方法中，使用getattr（）获取到method的方式，然后调用的视图类的相关的方法，进行执行，然后返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">多继承</span><br></pre></td></tr></table></figure></li></ul><p>class MyBaseView(object):<br>    def dispatch(self, request, *args, **kwargs):<br>        print(‘before’)</p><pre><code># super执行的是当前对象的继承关系# super里的self是StudentsView对象，super首先找MyBaseView里有没有dispatch方法# 如果没有就会去View类中找ret = super(StudentsView,self.dispatch(request,*args,**kwargs))print(&apos;after&apos;)return ret</code></pre><h1 id="多继承，首先执行左边的继承"><a href="#多继承，首先执行左边的继承" class="headerlink" title="多继承，首先执行左边的继承"></a>多继承，首先执行左边的继承</h1><h1 id="多各类公用，避免重复"><a href="#多各类公用，避免重复" class="headerlink" title="多各类公用，避免重复"></a>多各类公用，避免重复</h1><p>class StudentsView(MyBaseView,View):<br>    ‘’’<br>    继承自Django的view视图，在url里调用as_view()方法，这个固定搭配<br>    以不同的方式请求的时候，Django内部就会自动的选择调用不同的函数<br>    ‘’’<br>    def get(self,request,<em>args,**kwargs):<br>        print(‘get方法’)<br>        return HttpResponse(‘GET’)<br>    def post(self,request,</em>args,<strong>kwargs):<br>        return HttpResponse(‘POST’)<br>    def put(self,request,*args,</strong>kwargs):<br>        return HttpResponse(‘PUT’)<br>    def delete(self,request,*args,**kwargs):<br>        return HttpResponse(‘DELETE’)</p><p>class TeacherView(MyBaseView,View):<br>    ‘’’<br>    继承自Django的view视图，在url里调用as_view()方法，这个固定搭配<br>    以不同的方式请求的时候，Django内部就会自动的选择调用不同的函数<br>    ‘’’<br>    def get(self,request,<em>args,**kwargs):<br>        return HttpResponse(‘GET’)<br>    def post(self,request,</em>args,<strong>kwargs):<br>        return HttpResponse(‘POST’)<br>    def put(self,request,*args,</strong>kwargs):<br>        return HttpResponse(‘PUT’)<br>    def delete(self,request,*args,**kwargs):<br>        return HttpResponse(‘DELETE’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由</span><br></pre></td></tr></table></figure><p>urlpatterns = [<br>    url(r’^admin/‘, admin.site.urls),<br>    url(r’^users/‘, views.users),<br>    url(r’^students/‘,views.StudentsView.as_view()),<br>    url(r’^teachers/‘,views.TeacherView.as_view()),<br>]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 面试题</span><br><span class="line">    1.Django的中间件</span><br><span class="line">    - 最多写5个</span><br><span class="line">    - process_request</span><br><span class="line">    - process_view</span><br><span class="line">    - process_response</span><br><span class="line">    - process_exception</span><br><span class="line">    - process_render_template</span><br><span class="line"></span><br><span class="line">  2.使用中间件做过什么</span><br><span class="line">  - 权限</span><br><span class="line">  - 用户登录验证</span><br><span class="line">  - Django的csrf token是怎么实现的？（基于FBV模式）</span><br><span class="line">    &gt; 情况一</span><br><span class="line"></span><br><span class="line">      - csrf放到了process_view里面，一共做两件事</span><br><span class="line">          - 检测视图是否加了csrf_exempt装饰器</span><br><span class="line">          - 去请求体或cookie中获取token，校验</span><br><span class="line">      - django的views里decorators里的csrf有个装饰器，csrd_exempt，使用该装饰器表示该方法免除中间件认证</span><br><span class="line">      - 只要在settings里加了csrf就表示全站使用csrf，除非加上那个</span><br><span class="line"></span><br><span class="line">    &gt; 情况二</span><br><span class="line"></span><br><span class="line">      - 在settings里面没有写csrf认证，只需要加上装饰器csrf_protect就表示该函数需要csrf认证了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### CBV小知识点，csrf时需要使用</span><br><span class="line"></span><br><span class="line">&gt; 方法一</span><br><span class="line"></span><br><span class="line">- @method_decorator(csrf_exempt)</span><br><span class="line">- 在dispatch方法中（单独的方法无效）</span><br></pre></td></tr></table></figure><p>from django.views.decorators.csrf import csrf_exempt,csrf_protect<br>from django.utils.decorators import method_decorator<br>class TeacherView(View):<br>    @method_decorator(csrf_exempt)<br>    def dispatch(self, request, <em>args, **kwargs):<br>        ret = super(StudentsView,self.dispatch(request,</em>args,**kwargs))<br>        return ret</p><pre><code>def get(self,request,*args,**kwargs):    return HttpResponse(&apos;GET&apos;)def post(self,request,*args,**kwargs):    return HttpResponse(&apos;POST&apos;)def put(self,request,*args,**kwargs):    return HttpResponse(&apos;PUT&apos;)def delete(self,request,*args,**kwargs):    return HttpResponse(&apos;DELETE&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 方法二</span><br><span class="line"></span><br><span class="line">- 直接在类上加上装饰器</span><br></pre></td></tr></table></figure><p>from django.views.decorators.csrf import csrf_exempt,csrf_protect<br>from django.utils.decorators import method_decorator<br>@method_decorator(csrf_exempt,name=’dispatch’)<br>class TeacherView(View):<br>    def get(self,request,<em>args,**kwargs):<br>        return HttpResponse(‘GET’)<br>    def post(self,request,</em>args,<strong>kwargs):<br>        return HttpResponse(‘POST’)<br>    def put(self,request,*args,</strong>kwargs):<br>        return HttpResponse(‘PUT’)<br>    def delete(self,request,*args,**kwargs):<br>        return HttpResponse(‘DELETE’)<br><code>`</code></p><h4 id="CBV总结"><a href="#CBV总结" class="headerlink" title="CBV总结"></a>CBV总结</h4><ul><li>本质：基于反射来实现</li><li>流程：路由，view，dispatch（反射）</li><li><p>取消csrf认证（装饰器要加在dispatch方法上且method_decorator装饰）</p></li><li><p>扩展</p><ul><li>csrf<ul><li>基于中间件的process_view方法</li><li>装饰器给单独函数进行设置（认证或无需认证）</li></ul></li></ul></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式----装饰模式</title>
      <link href="/2017/09/07/wrapper/"/>
      <url>/2017/09/07/wrapper/</url>
      <content type="html"><![CDATA[<p>装饰模式又名包装（Wrapper）模式 </p><p>• 装饰模式以对客户端透明的方式扩展对象 的功能，是继承关系的一个替代方案 </p><p>• 装饰模式以对客户透明的方式动态的给一 个对象附加上更多的责任。换言之，客户 端并不会觉得对象在装饰前和装饰后有什么不同。</p><p>• 装饰模式可以在不创造更多子类的情况下， 将对象的功能加以扩展。</p><p>• 装饰模式把客户端的调用委派到被装饰类。 装饰模式的关键在于这种扩展完全是透明的。</p><p>• 装饰模式是在不必改变原类文件和使用继 承的情况下，动态的扩展一个对象的功能。 它是通过创建一个包装对象，也就是装饰 来包裹真实的对象。</p><p><strong>装饰模式的角色：</strong> </p><ul><li>抽象构件角色（Component）：给出一个抽 象接口，以规范准备接收附加责任的对象。 </li><li>具体构件角色（Concrete Component）： 定义一个将要接收附加责任的类。 </li><li>装饰角色（Decorator）：持有一个构件 （Component）对象的引用，并定义一个与 抽象构件接口一致的接口 </li><li>具体装饰角色（Concrete  Decorator）：负责给构件对象“贴上”附加的责任。</li></ul><p><strong>装饰模式的特点：</strong></p><ul><li>装饰对象和真实对象有相同的接口。这样客户端对象 就可以以和真实对象相同的方式和装饰对象交互。</li><li>装饰对象包含一个真实对象的引用（reference）</li><li>装饰对象接收所有来自客户端的请求。它把这些请求 转发给真实的对象。 </li><li><p>装饰对象可以在转发这些请求以前或以后增加一些附 加功能。这样就确保了在运行时，不用修改给定对象 的结构就可以在外部增加附加的功能。在面向对象的 设计中，通常是通过继承来实现对给定类的功能扩展。</p><p><strong>装饰模式</strong> </p></li><li>用来扩展特定对象的功能 </li><li>不需要子类 </li><li>动态 </li><li>运行时分配职责</li><li>防止由于子类而导致的复杂和混乱</li><li>更多的灵活性</li><li>对于一个给定的对象，同时可能有不同的装饰 对象，客户端可以通过它的需要选择合适的装 饰对象发送消息。</li></ul><p><strong>继承</strong></p><ul><li>用来扩展一类对象的功能 </li><li>需要子类 </li><li>静态 </li><li>编译时分派职责</li><li>导致很多子类产生 </li><li><p>缺乏灵活性</p><p>实现自己的装饰模式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象构件角色</span><br><span class="line">public interface  Component &#123;</span><br><span class="line">public void doSomthing() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//具体的构件角色</span><br><span class="line">public class ConcreteComponent implements Component&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;功能A&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//装饰角色</span><br><span class="line">public class Decorator implements Component&#123;</span><br><span class="line"></span><br><span class="line">//持有接口的引用</span><br><span class="line">private Component component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Decorator(Component component ) &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">this.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Decorator() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line"></span><br><span class="line">component.doSomthing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//具体的装饰角色</span><br><span class="line">public class ConcreteDecorator extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecorator(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line">super.doSomthing();</span><br><span class="line"></span><br><span class="line">this.doAnotherThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAnotherThing() &#123;</span><br><span class="line">System.out.println(&quot;功能B&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteDectator2 extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDectator2(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">super.doSomthing();</span><br><span class="line">this.doAnotherThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAnotherThing() &#123;</span><br><span class="line">System.out.println(&quot;功能C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">////节点流</span><br><span class="line">//Component component = new ConcreteComponent();</span><br><span class="line">//</span><br><span class="line">////过滤流</span><br><span class="line">//Component component2 = new ConcreteDecorator(component);</span><br><span class="line">//</span><br><span class="line">////过滤流</span><br><span class="line">//Component component3 = new ConcreteDectator2(component2);</span><br><span class="line">//</span><br><span class="line">//component2.doSomthing();</span><br><span class="line">//System.out.println(&quot;=======================&quot;);</span><br><span class="line">//component3.doSomthing();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Component component = new ConcreteDecorator(new ConcreteDectator2(new ConcreteComponent()));</span><br><span class="line">component.doSomthing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里我用了两种方式来测试，作用是一样的，只是与io流更相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能A</span><br><span class="line">功能C</span><br><span class="line">功能B</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>机器学习----K均值算法（K-means）聚类</title>
      <link href="/2017/08/18/k-means/"/>
      <url>/2017/08/18/k-means/</url>
      <content type="html"><![CDATA[<h1 id="K均值算法（K-means）聚类"><a href="#K均值算法（K-means）聚类" class="headerlink" title="K均值算法（K-means）聚类"></a>K均值算法（K-means）聚类</h1><h2 id="【关键词】K个种子，均值"><a href="#【关键词】K个种子，均值" class="headerlink" title="【关键词】K个种子，均值"></a>【关键词】K个种子，均值</h2><h2 id="一、K-means算法原理"><a href="#一、K-means算法原理" class="headerlink" title="一、K-means算法原理"></a>一、K-means算法原理</h2><h3 id="聚类的概念：一种无监督的学习，事先不知道类别，自动将相似的对象归到同一个簇中。"><a href="#聚类的概念：一种无监督的学习，事先不知道类别，自动将相似的对象归到同一个簇中。" class="headerlink" title="聚类的概念：一种无监督的学习，事先不知道类别，自动将相似的对象归到同一个簇中。"></a>聚类的概念：一种无监督的学习，事先不知道类别，自动将相似的对象归到同一个簇中。</h3><p>K-Means算法是一种聚类分析（cluster analysis）的算法，其主要是来计算数据聚集的算法，主要通过不断地取离种子点最近均值的算法。</p><p>K-Means算法主要解决的问题如下图所示。我们可以看到，在图的左边有一些点，我们用肉眼可以看出来有四个点群，但是我们怎么通过计算机程序找出这几个点群来呢？于是就出现了我们的K-Means算法<br><img src="https://img-blog.csdn.net/20180418171541953?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="1"><br>这个算法其实很简单，如下图所示：</p><p><img src="https://img-blog.csdn.net/20180418171552470?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="2"></p><p>从上图中，我们可以看到，A，B，C，D，E是五个在图中点。而灰色的点是我们的种子点，也就是我们用来找点群的点。有两个种子点，所以K=2。</p><p>然后，K-Means的算法如下：</p><ol><li>随机在图中取K（这里K=2）个种子点。</li><li>然后对图中的所有点求到这K个种子点的距离，假如点Pi离种子点Si最近，那么Pi属于Si点群。（上图中，我们可以看到A，B属于上面的种子点，C，D，E属于下面中部的种子点）</li><li>接下来，我们要移动种子点到属于他的“点群”的中心。（见图上的第三步）</li><li>然后重复第2）和第3）步，直到，种子点没有移动（我们可以看到图中的第四步上面的种子点聚合了A，B，C，下面的种子点聚合了D，E）。</li></ol><p>这个算法很简单，重点说一下“求点群中心的算法”：欧氏距离（Euclidean Distance）：差的平方和的平方根<br><img src="https://img-blog.csdn.net/20180418171601366?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="3"></p><h3 id="K-Means主要最重大的缺陷——都和初始值有关："><a href="#K-Means主要最重大的缺陷——都和初始值有关：" class="headerlink" title="K-Means主要最重大的缺陷——都和初始值有关："></a>K-Means主要最重大的缺陷——都和初始值有关：</h3><p>K是事先给定的，这个K值的选定是非常难以估计的。很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适。（ISODATA算法通过类的自动合并和分裂，得到较为合理的类型数目K）</p><p>K-Means算法需要用初始随机种子点来搞，这个随机种子点太重要，不同的随机种子点会有得到完全不同的结果。（K-Means++算法可以用来解决这个问题，其可以有效地选择初始点）</p><h3 id="总结：K-Means算法步骤："><a href="#总结：K-Means算法步骤：" class="headerlink" title="总结：K-Means算法步骤："></a>总结：K-Means算法步骤：</h3><ol><li>从数据中选择k个对象作为初始聚类中心;</li><li>计算每个聚类对象到聚类中心的距离来划分；</li><li>再次计算每个聚类中心</li><li>计算标准测度函数，直到达到最大迭代次数，则停止，否则，继续操作。</li><li>确定最优的聚类中心</li></ol><h3 id="K-Means算法应用"><a href="#K-Means算法应用" class="headerlink" title="K-Means算法应用"></a>K-Means算法应用</h3><p>看到这里，你会说，K-Means算法看来很简单，而且好像就是在玩坐标点，没什么真实用处。而且，这个算法缺陷很多，还不如人工呢。是的，前面的例子只是玩二维坐标点，的确没什么意思。但是你想一下下面的几个问题：</p><p>1）如果不是二维的，是多维的，如5维的，那么，就只能用计算机来计算了。</p><p>2）二维坐标点的X，Y 坐标，其实是一种向量，是一种数学抽象。现实世界中很多属性是可以抽象成向量的，比如，我们的年龄，我们的喜好，我们的商品，等等，能抽象成向量的目的就是可以让计算机知道某两个属性间的距离。如：我们认为，18岁的人离24岁的人的距离要比离12岁的距离要近，鞋子这个商品离衣服这个商品的距离要比电脑要近，等等。</p><h2 id="二、实战"><a href="#二、实战" class="headerlink" title="二、实战"></a>二、实战</h2><p>重要参数：</p><ul><li>n_clusters：聚类的个数</li></ul><p>重要属性：</p><ul><li>cluster_centers_ : [n_clusters, n_features]的数组，表示聚类中心点的坐标</li><li>labels_ : 每个样本点的标签</li></ul><h3 id="1、聚类实例"><a href="#1、聚类实例" class="headerlink" title="1、聚类实例"></a>1、聚类实例</h3><p>导包，使用make_blobs生成随机点cluster_std</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samples,target = make_blobs(n_samples=<span class="number">100</span>,n_features=<span class="number">2</span>,centers=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418171814697?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418171829698?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>建立模型,训练数据，并进行数据预测，使用相同数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">kmean = KMeans(n_clusters=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">kmean.fit(samples)</span><br></pre></td></tr></table></figure><pre><code>KMeans(algorithm=&apos;auto&apos;, copy_x=True, init=&apos;k-means++&apos;, max_iter=300,    n_clusters=2, n_init=10, n_jobs=1, precompute_distances=&apos;auto&apos;,    random_state=None, tol=0.0001, verbose=0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_ = kmean.predict(samples)</span><br></pre></td></tr></table></figure><p>绘制图形，显示聚类结果kmeans.cluster_centers</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=y_)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418171913128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centers = kmean.cluster_centers_</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=y_)</span><br><span class="line">plt.scatter(centers[:,<span class="number">0</span>],centers[:,<span class="number">1</span>],c=<span class="string">'red'</span>,s=<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418171925714?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 聚类 无监督学习</span></span><br><span class="line"><span class="comment"># 分类 有监督学习</span></span><br><span class="line"><span class="comment"># K-mean - KNN</span></span><br><span class="line"><span class="comment"># 欧式距离求距离</span></span><br></pre></td></tr></table></figure><h3 id="实战，三问中国足球几多愁？"><a href="#实战，三问中国足球几多愁？" class="headerlink" title="实战，三问中国足球几多愁？"></a>实战，三问中国足球几多愁？</h3><p>导包，3D图像需导包：</p><p>from mpl_toolkits.mplot3d import Axes3D</p><p>读取数据AsiaZoo.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">'../data/AsiaZoo.txt'</span>,header=<span class="keyword">None</span>)</span><br><span class="line">data.columns=[<span class="string">"国家"</span>,<span class="string">"2006世界杯"</span>,<span class="string">"2010世界杯"</span>,<span class="string">"2007亚洲杯"</span>]</span><br><span class="line">data</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples = data[[<span class="string">"2006世界杯"</span>,<span class="string">"2010世界杯"</span>,<span class="string">"2007亚洲杯"</span>]]</span><br><span class="line">samples</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># kmean.fit(samples)</span></span><br><span class="line"><span class="comment"># kmean.predict(samples)</span></span><br><span class="line">y_ = kmean.fit_predict(samples)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_</span><br></pre></td></tr></table></figure><pre><code>array([0, 1, 1, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 0])</code></pre><p>列名修改为：”国家”,”2006世界杯”,”2010世界杯”,”2007亚洲杯”</p><p>使用K-Means进行数据处理，对亚洲球队进行分组，分三组</p><p>for循环打印输出分组后的球队，每一组球队打印一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">countrys = data[<span class="string">'国家'</span>]</span><br><span class="line">countrys</span><br></pre></td></tr></table></figure><pre><code>0         中国1         日本2         韩国3         伊朗4         沙特5        伊拉克6        卡塔尔7        阿联酋8     乌兹别克斯坦9         泰国10        越南11        阿曼12        巴林13        朝鲜14        印尼Name: 国家, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    items = countrys[y_ == i]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        print(item,end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><pre><code>中国 伊拉克 卡塔尔 阿联酋 泰国 越南 阿曼 印尼 日本 韩国 伊朗 沙特 乌兹别克斯坦 巴林 朝鲜 </code></pre><p>​<br>绘制三维立体图形</p><ul><li>ax = plt.subplot(projection  = ‘3d’)  </li><li>ax.scatter3D()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = plt.subplot(projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line">ax.scatter3D(samples[<span class="string">'2006世界杯'</span>],samples[<span class="string">'2010世界杯'</span>],samples[<span class="string">'2007亚洲杯'</span>],alpha=<span class="number">1</span>,s=<span class="number">100</span>,marker=<span class="string">'h'</span>,c=y_)</span><br><span class="line">ax.set_xlabel(<span class="string">"2006-World-Cup"</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">"2010-World-Cup"</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">"2007-Asia-Cup"</span>)</span><br><span class="line"></span><br><span class="line">centers = kmean.cluster_centers_</span><br><span class="line"><span class="comment"># ax.scatter3D(centers[:,0],centers[:,1],centers[:,2],c='red',s=150,alpha=1)</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172040427?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>绘制聚类点</p><h3 id="2、聚类实践与常见错误"><a href="#2、聚类实践与常见错误" class="headerlink" title="2、聚类实践与常见错误"></a>2、聚类实践与常见错误</h3><p>导包，使用make_blobs创建样本点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples,target = make_blobs(n_samples=<span class="number">150</span>,n_features=<span class="number">2</span>,centers=<span class="number">3</span>,random_state=<span class="number">1</span>)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172053857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>第一种错误，k值不合适，make_blobs默认中心点三个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">4</span>)</span><br><span class="line">y_ = kmean.fit_predict(samples)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">axes1 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">axes1.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br><span class="line">axes1.set_title(<span class="string">'True'</span>)</span><br><span class="line"></span><br><span class="line">axes2 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">axes2.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=y_)</span><br><span class="line">axes2.set_title(<span class="string">'Predict'</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5,1,&apos;Predict&apos;)</code></pre><p><img src="https://img-blog.csdn.net/20180418172110665?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kmean.labels_</span></span><br></pre></td></tr></table></figure><pre><code>array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0,       0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1,       1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1,       1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1,       1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,       1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1])</code></pre><p>第二种错误,数据偏差<br>trans = [[0.6,-0.6],[-0.4,0.8]]<br>X2 = np.dot(X,trans)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples1,target1 = make_blobs(n_samples=<span class="number">150</span>,n_features=<span class="number">2</span>,centers=<span class="number">3</span>,random_state=<span class="number">5</span>)</span><br><span class="line">plt.scatter(samples1[:,<span class="number">0</span>],samples1[:,<span class="number">1</span>],c=target1)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/2018041817212823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">trans = [[<span class="number">0.6</span>,<span class="number">-0.6</span>],[<span class="number">-0.4</span>,<span class="number">0.8</span>]]</span><br><span class="line">samples = np.dot(samples1,trans)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172141121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">y_ = kmean.fit_predict(samples)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">axes1 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">axes1.scatter(samples1[:,<span class="number">0</span>],samples1[:,<span class="number">1</span>],c=y_)</span><br><span class="line">axes1.set_title(<span class="string">'Predict'</span>)</span><br><span class="line"></span><br><span class="line">axes2 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">axes2.scatter(samples1[:,<span class="number">0</span>],samples1[:,<span class="number">1</span>],c=target1)</span><br><span class="line">axes2.set_title(<span class="string">'True'</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5,1,&apos;True&apos;)</code></pre><p><img src="https://img-blog.csdn.net/20180418172157363?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>第三个错误:标准偏差不相同cluster_std</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples,target = make_blobs(n_samples=<span class="number">150</span>,n_features=<span class="number">2</span>,centers=<span class="number">3</span>,cluster_std=[<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172211289?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">y_ = kmean.fit_predict(samples)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">axes1 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">axes1.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br><span class="line">axes1.set_title(<span class="string">'True'</span>)</span><br><span class="line"></span><br><span class="line">axes2 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">axes2.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=y_)</span><br><span class="line">axes2.set_title(<span class="string">'Predict'</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5,1,&apos;Predict&apos;)</code></pre><p><img src="https://img-blog.csdn.net/20180418172225687?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>第四个错误：样本数量不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples,target = make_blobs(n_samples=<span class="number">1500</span>,n_features=<span class="number">2</span>,centers=<span class="number">3</span>,random_state=<span class="number">0</span>)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172242430?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">train1 = samples[target==<span class="number">0</span>][:<span class="number">10</span>]</span><br><span class="line">train2 = samples[target==<span class="number">1</span>][:<span class="number">150</span>]</span><br><span class="line">train3 = samples[target==<span class="number">2</span>][:<span class="number">500</span>]</span><br><span class="line"></span><br><span class="line">train = np.concatenate((train1,train2,train3))</span><br><span class="line">label = [<span class="number">0</span>]*<span class="number">10</span> + [<span class="number">1</span>]*<span class="number">150</span> + [<span class="number">2</span>]*<span class="number">500</span></span><br><span class="line"></span><br><span class="line">plt.scatter(train[:,<span class="number">0</span>],train[:,<span class="number">1</span>],c=label)</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180418172256879?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">y_ = kmean.fit_predict(train)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">axes1 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">axes1.scatter(train[:,<span class="number">0</span>],train[:,<span class="number">1</span>],c=label)</span><br><span class="line">axes1.set_title(<span class="string">'True'</span>)</span><br><span class="line"></span><br><span class="line">axes2 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">axes2.scatter(train[:,<span class="number">0</span>],train[:,<span class="number">1</span>],c=y_)</span><br><span class="line">axes2.set_title(<span class="string">'Predict'</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5,1,&apos;Predict&apos;)</code></pre><p><img src="https://img-blog.csdn.net/20180418172310711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><h3 id="1、分析ex7data2-mat文件"><a href="#1、分析ex7data2-mat文件" class="headerlink" title="1、分析ex7data2.mat文件"></a>1、分析ex7data2.mat文件</h3><p>找出最佳聚类数目，并画出聚类的中心点</p><p><code>from scipy.io import loadmatfrom sklearn.cluster import KMeansdata = loadmat(&#39;../data/ex7data2.mat&#39;)X = data[&#39;X&#39;]X.shape</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'../data/ex7data2.mat'</span>)[<span class="string">'X'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(data[:,<span class="number">0</span>],data[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172325436?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">3</span>)</span><br><span class="line">y_ = kmean.fit_predict(data)</span><br><span class="line"></span><br><span class="line">plt.scatter(data[:,<span class="number">0</span>],data[:,<span class="number">1</span>],c=y_)</span><br><span class="line">centers = kmean.cluster_centers_</span><br><span class="line">plt.scatter(centers[:,<span class="number">0</span>],centers[:,<span class="number">1</span>],c=<span class="string">'red'</span>,s=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172342694?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="2、图片压缩"><a href="#2、图片压缩" class="headerlink" title="2、图片压缩"></a>2、图片压缩</h3><p>使用聚类压缩图片</p><p><code>img = plt.imread(&#39;../data/bird_small.png&#39;)img_shape = img.shapeimg_shape</code></p><ul><li>核心思想：把图片颜色数据聚类分析成N个类别，用中心点颜色替换其他颜色</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">girl = plt.imread(<span class="string">'meizi.jpg'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = girl.reshape(<span class="number">-1</span>,<span class="number">3</span>)/<span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure><pre><code>array([[0.75294118, 0.77254902, 0.78431373],       [0.75686275, 0.77647059, 0.78823529],       [0.76078431, 0.78039216, 0.79215686],       ...,       [0.49411765, 0.45882353, 0.43921569],       [0.49411765, 0.45882353, 0.43921569],       [0.49019608, 0.45490196, 0.43529412]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kmean = KMeans(n_clusters=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">kmean.fit_predict(data)</span><br></pre></td></tr></table></figure><pre><code>array([1, 4, 4, ..., 3, 3, 3])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors = kmean.cluster_centers_</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colors</span><br></pre></td></tr></table></figure><pre><code>array([[0.97098806, 0.97478961, 0.97778226],       [0.74193731, 0.67788276, 0.65664508],       [0.28508069, 0.2517683 , 0.30811107],       [0.57589379, 0.50164084, 0.49412421],       [0.8664354 , 0.86114772, 0.86019593]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(colors[kmean.labels_].reshape(girl.shape))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180418172401892?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByYWlyaWU5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><a href="https://github.com/yuansuixin/ML-K-Means" title="下载源码" target="_blank" rel="noopener">下载源码</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射机制深入剖析（二）</title>
      <link href="/2017/06/02/reflection2/"/>
      <url>/2017/06/02/reflection2/</url>
      <content type="html"><![CDATA[<p>继续来谈谈反射机制</p><ol><li>要想使用反射，首先需要获得待处理类或对象所对应的Class对象。</li></ol><p><strong>2. 获取某个类或某个对象所对应的Class对象的常用的3种方式：</strong></p><ul><li><strong>使用Class类的静态方法forName，Class.forName(“java.lang.String”);</strong></li><li><strong>使用类的.class语法：String.class;</strong></li><li><strong>使用对象的getClass()方法： String s=”aa”;Class&lt;?&gt; class=s.getClass();</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class ReflactTester &#123;</span><br><span class="line"></span><br><span class="line">//该方法实现对Customer对象的拷贝操作</span><br><span class="line">public Object copy(Object object) throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; classType=object.getClass();</span><br><span class="line"></span><br><span class="line">//System.out.println(classType.getName());</span><br><span class="line"></span><br><span class="line">Constructor constructor = classType.getConstructor(new Class[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">Object object2= constructor.newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以上两行代码等价于下面一行</span><br><span class="line">//Object object2=classType.newInstance();</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//Constructor constructor3 = classType.getConstructor(new Class[] &#123;String.class,int.class&#125;);</span><br><span class="line">//</span><br><span class="line">//Object object3= constructor3.newInstance(new Object[] &#123;&quot;hello&quot;,4&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(object2);</span><br><span class="line">//System.out.println(object3);</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">ReflactTester tester= new ReflactTester();</span><br><span class="line">tester.copy(new Customer());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer&#123;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public Customer() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Customer (String name, int age) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(Long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer@15db9742</span><br></pre></td></tr></table></figure><p>3.若想通过类的不带参数的构造方法来生成对象，我们有两种方式：</p><ul><li><p>先获得 Class 对象，然后通过该 Class 对象的 newInstance()方法直接生成即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = String.class; </span><br><span class="line">Object obj = classType.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先获得 Class 对象，然后通过该对象获得对应的 Constructor 对象，再通过该 Constructor 对象的 newInstance()方法生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = Customer.class; </span><br><span class="line">Constructor cons = classType.getConstructor(new Class[]&#123;&#125;);</span><br><span class="line">Object obj = cons.newInstance(new Object[]&#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>4.若想通过类的带参数的构造方法生成对象，只能使用下面这一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = Customer.class; </span><br><span class="line">Constructor cons = classType.getConstructor(new Class[]&#123;String.class, int.class&#125;); </span><br><span class="line">Object obj = cons.newInstance(new Object[]&#123;“hello”, 3&#125;);</span><br></pre></td></tr></table></figure><hr><p>我们再来看一个例子,ReflectTester类有一个 copy(Object object)方法，这个方法能够创建 一个和参数object 同样类型的对象，然后把 object对象中的所有属性拷贝到新建的对象中， 并将它返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflactTester2 &#123;</span><br><span class="line"></span><br><span class="line">public Object copy(Object object )throws Exception &#123;</span><br><span class="line">    //获得对象的类型</span><br><span class="line">Class&lt;?&gt; classType = object.getClass();</span><br><span class="line">//System.out.println(&quot;Class:&quot;+classType.getName());</span><br><span class="line"></span><br><span class="line">//通过无参数的构造方法构造出来类并且实例化</span><br><span class="line">Object objectCopy=classType.getConstructor(new Class[] &#123;&#125;).newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//获得对象的所有成员变量</span><br><span class="line"></span><br><span class="line">Field[] fields= classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">for(Field field:fields) &#123;</span><br><span class="line">//获得属性的名称</span><br><span class="line">String name=field.getName();</span><br><span class="line"></span><br><span class="line">//变量名称首字母大写</span><br><span class="line">String firstLetter=name.substring(0,1).toUpperCase();</span><br><span class="line"></span><br><span class="line">//获取到get、set方法的名称</span><br><span class="line">String getMethodName=&quot;get&quot;+firstLetter+name.substring(1);</span><br><span class="line">String setMethodName=&quot;set&quot;+firstLetter+name.substring(1);</span><br><span class="line"></span><br><span class="line">//获取到get、set方法</span><br><span class="line">Method getMethod=classType.getMethod(getMethodName, new Class[] &#123;&#125;);</span><br><span class="line">Method setMethod=classType.getMethod(setMethodName, new Class[] &#123;field.getType()&#125;);</span><br><span class="line"></span><br><span class="line">//set方法没有参数</span><br><span class="line">Object value=getMethod.invoke(object, new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//将get到的属性值传入</span><br><span class="line">setMethod.invoke(objectCopy, new Object[] &#123;value&#125;);</span><br><span class="line">&#125;</span><br><span class="line">return objectCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Customer customer = new Customer(&quot;Tom&quot;,20);</span><br><span class="line">//注意是long类型的哟</span><br><span class="line">customer.setId(1L);</span><br><span class="line"></span><br><span class="line">ReflactTester tester = new ReflactTester();</span><br><span class="line"></span><br><span class="line">Customer customer2 = (Customer) tester.copy(customer);</span><br><span class="line"></span><br><span class="line">//System.out.println(customer2.getId()+&quot;,&quot;+customer2.getName()+&quot;,&quot;+customer2.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,Tom,20</span><br></pre></td></tr></table></figure><p>Class类是Reflection API 中的核心类，它有以下方法 :</p><ul><li><p>getName()：获得类的完整名字。</p></li><li><p>getFields()：获得类的public类型的属性。</p></li><li><p>getDeclaredFields()：获得类的所有属性。</p></li><li><p>getMethods()：获得类的<strong>public类型</strong>的方法。</p></li><li><p>getDeclaredMethods()：获得类的所有方法。</p><p>Method类的invoke(Object obj,Object args[])方法<strong>接 收的参数必须为对象</strong>，如果参数为基本类型数据，必须转 换为相应的包装类型的对象。<strong>invoke()方法的返回值总是 对象</strong>，如果实际被调用的方法的返回类型是基本类型数据 ，那么invoke()方法会把它转换为相应的包装类型的对象 ，再将其返回.</p></li></ul><p>下面我们来看看数组，java.lang.Array 类提供了动态创建和访 问数组元素的各种静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">public class ArrayTester1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">Object array = Array.newInstance(classType, 10);</span><br><span class="line"></span><br><span class="line">Array.set(array, 5, &quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">String str = (String)Array.get(array, 5);</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>hello</p><hr><p>创建 了一个 5 x 10 x 15 的整型数组，并把索 引位置为[3][5][10] 的元素的值为设37</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">public class ArrayTester2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int[] dims = new int[] &#123; 5, 10, 15 &#125;;</span><br><span class="line"></span><br><span class="line">Object array = Array.newInstance(Integer.TYPE, dims);</span><br><span class="line"></span><br><span class="line">System.out.println(array instanceof int[][][]);</span><br><span class="line"></span><br><span class="line">//二维数组</span><br><span class="line">Object arrayObj = Array.get(array, 3);</span><br><span class="line"></span><br><span class="line">//Class&lt;?&gt; classType=arrayObj.getClass().getComponentType();</span><br><span class="line">//System.out.println(classType);</span><br><span class="line"></span><br><span class="line">//一维数组</span><br><span class="line">arrayObj = Array.get(arrayObj, 5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array.setInt(arrayObj, 10, 37);</span><br><span class="line"></span><br><span class="line">int[][][] arrayCast = (int[][][]) array;</span><br><span class="line"></span><br><span class="line">System.out.println(arrayCast[3][5][10]);</span><br><span class="line"></span><br><span class="line">// System.out.println(Integer.TYPE);</span><br><span class="line">// System.out.println(Integer.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">37</span><br></pre></td></tr></table></figure><ol><li>Integer.TYPE 返回的是 int，而 Integer.class 返回的是 Integer 类所对应的 Class 对象。</li></ol><p>反射破坏了类的封装性，可以调用私有的方法，变量，接下来我们一起来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PivateTest &#123;</span><br><span class="line"></span><br><span class="line">private String sayHello(String name) &#123;</span><br><span class="line">return &quot;hello&quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Private &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">PivateTest private1 = new PivateTest();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=private1.getClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Method  method = classType.getDeclaredMethod(&quot;sayHello&quot;, new Class[] &#123;String.class&#125;);</span><br><span class="line"></span><br><span class="line">method.setAccessible(true);//压制java的访问权限的内部检查</span><br><span class="line"></span><br><span class="line">String string = (String)method.invoke(private1, new Object[] &#123;&quot;  zhangsan&quot;&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello  zhangsan</span><br></pre></td></tr></table></figure><p>用反射更改私有的成员变量的值，怎么实现呢，我们来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class Private2 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private String name=&quot;zhangsan&quot;;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">Private2 private2 = new Private2();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=Private.class;</span><br><span class="line"></span><br><span class="line">Field field=classType.getDeclaredField(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">//压制java对访问修饰符的检查</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//对于属性的操作，直接使用get或是set方法就可以了</span><br><span class="line">field.set(private2, &quot;lisi&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(private2.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisi</span><br></pre></td></tr></table></figure><p>众所周知Java有个Object class，是所有 Java classes的继承根源，其内声明了数 个应该在所有Java class中被改写的 methods：hashCode()、equals()、 clone()、toString()、getClass()等。其 中getClass()返回一个Class object。</p><ul><li>Class class十分特殊。它和一般classes一样继承自 Object，其实体用以表达Java程序运行时的classes和 interfaces，也用来表达enum、array、primitive Java types</li><li>（boolean, byte, char, short, int, long, float, double）以及关键词void。当一个class被加载，或当加 载器（class loader）的defineClass()被JVM调用， JVM 便自动产生一个Class object。如果您想借由“修 改Java标准库源码”来观察Class object的实际生成时 机（例如在Class的constructor内添加一个println()） ，不能够！因为Class并没有public constructor<br>只有java虚拟机可以创建一个Class</li></ul><ul><li>Class是Reflection起源。针对任何您想探 勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十 多个的Reflection APIs</li></ul><p><strong>为什么获得Method object时不需指定回返类型？</strong></p><ul><li>因为method overloading机制要求 signature必须唯一，而回返类型并非 signature的一个成份。换句话说，只要指定了method名称和参数列，就一定指出了 一个独一无二的method。（在方法重载的那个地方也是这样）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Class&lt;?&gt; classType = Child.class;</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Parent&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Child</span><br><span class="line">class Parent</span><br><span class="line">class java.lang.Object</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>什么时候能用到反射呢？</p><p>实际开发中一般是用不到反射的，除非自己去写框架肯定会用到反射，掌握了反射机制，对于以后学框架有利，理解更深入。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射机制深入剖析（一）</title>
      <link href="/2017/05/24/reflection1/"/>
      <url>/2017/05/24/reflection1/</url>
      <content type="html"><![CDATA[<p>我们来谈谈反射，这个知识点有些难度，不好理解，我介绍的详细一些，尽量细致，不对的地方往大家指正。</p><p>我们平时编的代码和接触到的都是在java编译环境中的，而在java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是<strong>肯定的</strong> 这种动态获取类的信息以及动态调用对象的方法的功能来自于java语言的反射机制。</p><p>java反射机制的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ul><p>编程语言分为动态语言和静态语言</p><p>动态语言：程序运行时，允许改变程序结构或变量类型。Perl,Python,Ruby是动态语言，而C++，java，C#不是动态语言。</p><p>而反射机制是java被视为动态语言的一个关键性质。这个机制允许程序在运行时透过Reflaction APIs取得任何一个已知名称的class的内部信息。包括其 modifiers（诸如public, static 等等）、superclass（ 例如Object）、实现之interfaces（例如Serializable） ，也包括fields和methods的所有信息，并可于运行时改 变fields内容或调用methods</p><p>尽管在这样的定义与分类下Java不是动态语言， 它却有着一个非常突出的动态相关机制： Reflection。这个字的意思是“反射、映象、倒 影”，用在Java身上指的是我们可以于运行时加 载、探知、使用编译期间完全未知的classes。换 句话说，Java程序可以加载一个运行时才得知名 称的class，获悉其完整构造（但不包括 methods定义），并生成其对象实体、或对其 fields设值、或唤起其methods。这种“看透 class”的能力（the ability of the program to examine itself）被称为introspection（内省、 内观、反省）。Reflection和introspection是常 被并提的两个术语。</p><p>在JDK中，主要由以下类来实现Java反射机制，这些类都 位于java.lang.reflect包中</p><ul><li>Class类：代表一个类。</li><li>Field 类：代表类的成员变量（成员变量也称为类的属性）。</li><li>Method类：代表类的方法。</li><li>Constructor 类：代表类的构造方法。</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li></ul><p>了解了这么多理论，大家也晕了吧，让我们来看看反射在程序中怎么使用的。。。</p><p>来介绍一下基本的作用<br><strong>java中，无论生成某各类的多少个对象，这些对象都会对应于同一个Class对象。这个Class对象是在没有生成任何类之前由jvm帮我们生成好的，在类被装载的时候Class对象就已经生成好了。这个Class对象生成好之后就会获悉我们当前类所有的成员变量以及所有的方法。</strong></p><p>首先要获得class类，这里不止一种方式，我会陆续介绍给大家。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DumpMehtod &#123;</span><br><span class="line"></span><br><span class="line">//这里我们主要是学习反射，对于异常的问题就直接抛出了</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得class类的第一种方式</span><br><span class="line">Class&lt;?&gt; class1 = Class.forName(&quot;java.lang.Object&quot;); </span><br><span class="line"></span><br><span class="line">Method[] methods = class1.getDeclaredMethods();</span><br><span class="line">//增强的for循环</span><br><span class="line">for(Method method: methods) &#123;</span><br><span class="line">System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果将获得Object类的所有方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void java.lang.Object.finalize() throws java.lang.Throwable</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public java.lang.String java.lang.Object.toString()</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">private static native void java.lang.Object.registerNatives()</span><br></pre></td></tr></table></figure><p>接下来再深入了解通过反射调用自己定义的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class InvokeTest &#123;</span><br><span class="line"></span><br><span class="line">public int  add(int a, int b) &#123;</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String echo(String string) &#123;</span><br><span class="line">return &quot;hello&quot;+string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">    </span><br><span class="line">    //平时的调用步骤</span><br><span class="line">    // InvokeTester test = new InvokeTester();</span><br><span class="line">// System.out.println(test.add(1, 2));</span><br><span class="line">// System.out.println(test.echo(&quot;tom&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获得class类的第二种方法，泛型中的？表示继承Object</span><br><span class="line">Class&lt;?&gt; classType = InvokeTest.class; </span><br><span class="line">//将类进行实例</span><br><span class="line">Object incokeTest=classType.newInstance();</span><br><span class="line">//获得类的方法，</span><br><span class="line">//使用class类调用getMethod（）方法</span><br><span class="line">//第一个参数是类的名称，第二个参数为方法的形式参数所对应的class对象构成的数组</span><br><span class="line">Method addMethod = classType.getMethod(&quot;add&quot;, new Class[] &#123;int.class,int.class&#125;);</span><br><span class="line">//调用方法的invoke（）方法，执行此方法，</span><br><span class="line">//第一个参数为此类的实例，第二个参数是为这个方法传递的参数组成的数组</span><br><span class="line">//自动装箱</span><br><span class="line">Object result=addMethod.invoke(incokeTest, new Object[]&#123;1,2&#125;);</span><br><span class="line">//返回的肯定是一个Integer类型，这里是自动拆箱</span><br><span class="line">System.out.println((Integer)result);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">Method echoMethod=classType.getMethod(&quot;echo&quot;, new Class[] &#123;String.class&#125;);</span><br><span class="line"></span><br><span class="line">Object result2=echoMethod.invoke(incokeTest, new Object[] &#123;&quot;  world&quot;&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println((String)result2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">--------------------------------------------------</span><br><span class="line">hello  world</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>机器学习----决策树（DecisionTree）</title>
      <link href="/2017/04/17/decisiontree/"/>
      <url>/2017/04/17/decisiontree/</url>
      <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="【关键词】树，信息增益"><a href="#【关键词】树，信息增益" class="headerlink" title="【关键词】树，信息增益"></a>【关键词】树，信息增益</h2><h3 id="决策树的优缺点"><a href="#决策树的优缺点" class="headerlink" title="决策树的优缺点"></a>决策树的优缺点</h3><p>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。既能用于分类，也能用于回归</p><p>缺点：可能会产生过度匹配问题</p><h2 id="一、决策树的原理"><a href="#一、决策树的原理" class="headerlink" title="一、决策树的原理"></a>一、决策树的原理</h2><h3 id="predict"><a href="#predict" class="headerlink" title="predict()"></a>predict()</h3><p>【二十个问题的游戏】</p><p>游戏的规则很简单：参与游戏的一方在脑海里想某个事物，其他参与者向他提问题，只允许提20个问题，问题的答案也只能用对或错回答。问问题的人通过推断分解，逐步缩小待猜测事物的范围。决策树的工作原理与20个问题类似，用户输人一系列数据 ，然后给出游戏的答案。</p><p>我们经常使用决策树处理分类问题。近来的调查表明决策树也是最经常使用的数据挖掘算法。它之所以如此流行，一个很重要的原因就是使用者基本上不用了解机器学习算法，也不用深究它是如何工作的。</p><p>如果以前没有接触过决策树，完全不用担心，它的概念非常简单。即使不知道它也可以通过简单的图形了解其工作原理。</p><p>决策树分类的思想类似于找对象。现想象一个女孩的母亲要给这个女孩介绍男朋友，于是有了下面的对话：</p><pre><code>女儿：多大年纪了？母亲：26。女儿：长的帅不帅？母亲：挺帅的。女儿：收入高不？母亲：不算很高，中等情况。女儿：是公务员不？母亲：是，在税务局上班呢。女儿：那好，我去见见。</code></pre><p>这个女孩的决策过程就是典型的分类树决策。相当于通过年龄、长相、收入和是否公务员对将男人分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么这个可以用下图表示女孩的决策逻辑:</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193434.PNG" alt="1"></p><p>上图完整表达了这个女孩决定是否见一个约会对象的策略，其中绿色节点表示判断条件，橙色节点表示决策结果，箭头表示在一个判断条件在不同情况下的决策路径，图中红色箭头表示了上面例子中女孩的决策过程。</p><p>这幅图基本可以算是一颗决策树，说它“基本可以算”是因为图中的判定条件没有量化，如收入高中低等等，还不能算是严格意义上的决策树，如果将所有条件量化，则就变成真正的决策树了。</p><p>有了上面直观的认识，我们可以正式定义决策树了：</p><p>决策树（decision tree）是一个树结构（可以是二叉树或非二叉树）。其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p><p>可以看到，决策树的决策过程非常直观，容易被人理解。目前决策树已经成功运用于医学、制造产业、天文学、分支生物学以及商业等诸多领域。</p><p>之前介绍的K-近邻算法可以完成很多分类任务，但是它最大的缺点就是无法给出数据的内在含义，决策树的主要优势就在于数据形式非常容易理解。</p><p>决策树算法能够读取数据集合，构建类似于上面的决策树。决策树很多任务都是为了数据中所蕴含的知识信息，因此决策树可以使用不熟悉的数据集合，并从中提取出一系列规则，机器学习算法最终将使用这些机器从数据集中创造的规则。专家系统中经常使用决策树，而且决策树给出结果往往可以匹敌在当前领域具有几十年工作经验的人类专家。</p><p>知道了决策树的定义以及其应用方法，下面介绍决策树的构造算法。</p><h2 id="二、决策树的构造"><a href="#二、决策树的构造" class="headerlink" title="二、决策树的构造"></a>二、决策树的构造</h2><h4 id="分类解决离散问题，回归解决连续问题"><a href="#分类解决离散问题，回归解决连续问题" class="headerlink" title="分类解决离散问题，回归解决连续问题"></a>分类解决离散问题，回归解决连续问题</h4><ul><li>决策树：信息论</li><li>逻辑斯底回归、贝叶斯：概率论</li></ul><p>不同于逻辑斯蒂回归和贝叶斯算法，决策树的构造过程不依赖领域知识，它使用属性选择度量来选择将元组最好地划分成不同的类的属性。所谓决策树的构造就是进行属性选择度量确定各个特征属性之间的拓扑结构。</p><p>构造决策树的关键步骤是分裂属性。所谓分裂属性就是在某个节点处按照某一特征属性的不同划分构造不同的分支，其目标是让各个分裂子集尽可能地“纯”。尽可能“纯”就是尽量让一个分裂子集中待分类项属于同一类别。分裂属性分为三种不同的情况：</p><pre><code>1、属性是离散值且不要求生成二叉决策树。此时用属性的每一个划分作为一个分支。2、属性是离散值且要求生成二叉决策树。此时使用属性划分的一个子集进行测试，按照“属于此子集”和“不属于此子集”分成两个分支。3、属性是连续值。此时确定一个值作为分裂点split_point，按照&gt;split_point和&lt;=split_point生成两个分支。</code></pre><p>构造决策树的关键性内容是进行属性选择度量，属性选择度量是一种选择分裂准则，它决定了拓扑结构及分裂点split_point的选择。</p><p>属性选择度量算法有很多，一般使用自顶向下递归分治法，并采用不回溯的贪心策略。这里介绍常用的ID3算法。</p><h4 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h4><p>划分数据集的大原则是：<em>将无序的数据变得更加有序。</em></p><p>我们可以使用多种方法划分数据集，但是每种方法都有各自的优缺点。组织杂乱无章数据的一种方法就是使用信息论度量信息，信息论是量化处理信息的分支科学。我们可以在划分数据之前使用信息论量化度量信息的内容。</p><p>在划分数据集之前之后信息发生的变化称为信息增益，知道如何计算信息增益，我们就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。</p><p>在可以评测哪种数据划分方式是最好的数据划分之前，我们必须学习如何计算信息增益。集合信息的度量方式称为香农熵或者简称为熵，这个名字来源于信息论之父克劳德•香农。</p><p>entropy</p><p>熵定义为信息的期望值，在明晰这个概念之前，我们必须知道信息的定义。如果待分类的事务可能划分在多个分类之中，则符号x的信息定义为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841719359.PNG" alt="Untitled-1-2"></p><p>其中p(x)是选择该分类的概率</p><p>为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过下面的公式得到：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193516.PNG" alt="Untitled-1-3"></p><p>其中n是分类的数目。</p><p>在决策树当中，设D为用类别对训练元组进行的划分，则D的熵（entropy）表示为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193526.gif" alt="Untitled-1-4"></p><p>其中pi表示第i个类别在整个训练元组中出现的概率，可以用属于此类别元素的数量除以训练元组元素总数量作为估计。熵的实际意义表示是D中元组的类标号所需要的平均信息量。</p><p>现在我们假设将训练元组D按属性A进行划分，则A对D划分的期望信息为：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193536.gif" alt="Untitled-1-5"></p><p>而信息增益即为两者的差值：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193541.gif" alt="Untitled-1-6"></p><p>ID3算法就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。下面我们继续用SNS社区中不真实账号检测的例子说明如何使用ID3算法构造决策树。为了简单起见，我们假设训练集合包含10个元素：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193547.png" alt="Untitled-1-7"></p><p>其中s、m和l分别表示小、中和大。</p><p>设L、F和H表示日志密度、好友密度、是否使用真实头像，下面计算各属性的信息增益。<br>![Untitled-1-8](<a href="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193555.gif" target="_blank" rel="noopener">http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193555.gif</a></p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841719362.gif" alt="Untitled-1-9"></p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193613.gif" alt="Untitled-1-10"></p><p>因此日志密度的信息增益是0.276。</p><p>用同样方法得到F和H的信息增益分别为0.553和0.033。</p><p>因为F具有最大的信息增益，所以第一次分裂选择F为分裂属性，分裂后的结果如下图表示：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417193631.png" alt="Untitled-1-11"></p><p>在上图的基础上，再递归使用这个方法计算子节点的分裂属性，最终就可以得到整个决策树。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>计算上图的信息熵，确定下一个分类的特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照分类的类别划分，计算信息熵</span></span><br><span class="line"><span class="comment"># no  3/10</span></span><br><span class="line"><span class="comment"># yes 7/10</span></span><br><span class="line">info_D = <span class="number">-0.3</span>*math.log2(<span class="number">0.3</span>) + (<span class="number">-0.7</span>*math.log2(<span class="number">0.7</span>))</span><br><span class="line">info_D</span><br></pre></td></tr></table></figure><pre><code>0.8812908992306927</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照L划分</span></span><br><span class="line"><span class="comment"># s 0.3 --&gt;  no yes no  | no 2/3  yes 1/3</span></span><br><span class="line"><span class="comment"># m 0.4 --&gt;  yes yes no yes  | no 1/4  yes/4</span></span><br><span class="line"><span class="comment"># l 0.3 --&gt;  yes yes yes  |  no 0  yes  1</span></span><br><span class="line"></span><br><span class="line">info_D_L = <span class="number">0.3</span>*(<span class="number">-2</span>/<span class="number">3</span>*math.log2(<span class="number">2</span>/<span class="number">3</span>) <span class="number">-1</span>/<span class="number">3</span>*math.log2(<span class="number">1</span>/<span class="number">3</span>)) + <span class="number">0.4</span>*(<span class="number">-1</span>/<span class="number">4</span>*math.log2(<span class="number">1</span>/<span class="number">4</span>) <span class="number">-3</span>/<span class="number">4</span>*math.log2(<span class="number">3</span>/<span class="number">4</span>))</span><br><span class="line"><span class="comment">#            0.3*(-0*math.log2(0) -1*math.log2(1))</span></span><br><span class="line">info_D_L</span><br></pre></td></tr></table></figure><pre><code>0.6</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_D - info_D_L</span><br></pre></td></tr></table></figure><pre><code>0.2812908992306927</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s 4/10  ---&gt; no no yes no  |no 3/4 yes 1/4</span></span><br><span class="line"><span class="comment"># m 4/10  ---&gt; yes yes yes yes  |no 0  yes 1</span></span><br><span class="line"><span class="comment"># l 2/10  ---&gt; yes yes  | no 0 yes 1</span></span><br><span class="line">info_D_F = <span class="number">0.4</span>*(<span class="number">-3</span>/<span class="number">4</span>*math.log2(<span class="number">3</span>/<span class="number">4</span>) <span class="number">-1</span>/<span class="number">4</span>*math.log2(<span class="number">1</span>/<span class="number">4</span>))</span><br><span class="line">info_D_F</span><br></pre></td></tr></table></figure><pre><code>0.32451124978365314</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_D - info_D_F</span><br></pre></td></tr></table></figure><pre><code>0.5567796494470396</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yes 0.5   ---&gt;  no yes no yes yes  |no 2/5 yes 3/5</span></span><br><span class="line"><span class="comment"># no 0.5    ---&gt;  yes yes yes yes no  | no 1/5  yes 4/5</span></span><br><span class="line">info_D_H = <span class="number">0.5</span>*(<span class="number">-2</span>/<span class="number">5</span>*math.log2(<span class="number">2</span>/<span class="number">5</span>) <span class="number">-3</span>/<span class="number">5</span>*math.log2(<span class="number">3</span>/<span class="number">5</span>)) + <span class="number">0.5</span>*(<span class="number">-1</span>/<span class="number">5</span>*math.log2(<span class="number">1</span>/<span class="number">5</span>) <span class="number">-4</span>/<span class="number">5</span>*math.log2(<span class="number">4</span>/<span class="number">5</span>))</span><br><span class="line">info_D_H</span><br></pre></td></tr></table></figure><pre><code>0.8464393446710154</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_D - info_D_H</span><br></pre></td></tr></table></figure><pre><code>0.034851554559677256</code></pre><h2 id="三、实战"><a href="#三、实战" class="headerlink" title="三、实战"></a>三、实战</h2><p>【注意】<br>参数max_depth越大，越容易过拟合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 决策树分类模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br></pre></td></tr></table></figure><h3 id="1、使用自带的iris数据集"><a href="#1、使用自带的iris数据集" class="headerlink" title="1、使用自带的iris数据集"></a>1、使用自带的iris数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.datasets <span class="keyword">as</span> datasets</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = iris.data</span><br><span class="line">target = iris.target</span><br><span class="line">samples = data[:,:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194040.png" alt="Untitled-1-2018417194040"></p><p>使用决策树算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">xmin,xmax = samples[:,<span class="number">0</span>].min()<span class="number">-0.5</span>,samples[:,<span class="number">0</span>].max()+<span class="number">0.5</span></span><br><span class="line">ymin,ymax = samples[:,<span class="number">1</span>].min()<span class="number">-0.5</span>,samples[:,<span class="number">1</span>].max()+<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">300</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br><span class="line"></span><br><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">colormatp = ListedColormap([<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># max_depth决策树深度，值越大越精确，但容易出现过拟合</span></span><br><span class="line">decision = DecisionTreeClassifier(max_depth=<span class="number">5</span>)</span><br><span class="line">decision.fit(samples,target)</span><br><span class="line">y_ = decision.predict(X_test)</span><br><span class="line"></span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target,cmap=colormatp)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194058.png" alt="Untitled-1-2018417194058"><br>使用KNN算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line">knn.fit(samples,target)</span><br><span class="line"></span><br><span class="line">y1_ = knn.predict(X_test)</span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y1_)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target,cmap=colormatp)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194116.png" alt="Untitled-1-2018417194116"></p><p>使用逻辑斯蒂回归算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">logistic = LogisticRegression()</span><br><span class="line">logistic.fit(samples,target)</span><br><span class="line">y2_ = logistic.predict(X_test)</span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y2_)</span><br><span class="line">plt.scatter(samples[:,<span class="number">0</span>],samples[:,<span class="number">1</span>],c=target,cmap=colormatp)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194140.png" alt="Untitled-1-2018417194140"></p><h3 id="2、使用回归预测一个椭圆"><a href="#2、使用回归预测一个椭圆" class="headerlink" title="2、使用回归预测一个椭圆"></a>2、使用回归预测一个椭圆</h3><p>使用RandomState生成固定随机数<br>创建-100到100之间的随机弧度<br>生成正弦值和余弦值<br>添加噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 固定随机数</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">radians = np.sort(np.random.random(<span class="number">200</span>))*<span class="number">200</span><span class="number">-100</span></span><br><span class="line"></span><br><span class="line">X = np.cos(radians)</span><br><span class="line">y = np.sin(radians)</span><br><span class="line"></span><br><span class="line">plt.scatter(X,y)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194156.png" alt="Untitled-1-2018417194156"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noise = np.random.random(<span class="number">50</span>) - <span class="number">0.5</span></span><br><span class="line">noise</span><br></pre></td></tr></table></figure><pre><code>array([ 0.45017612,  0.05665319,  0.41560635,  0.14156621, -0.10999229,       -0.01400933,  0.10431048,  0.04954792,  0.42618143,  0.41873344,       -0.10512439,  0.46326253, -0.32604433, -0.37367048, -0.36492084,        0.00566217, -0.47847519,  0.44797021,  0.32711547, -0.48498102,       -0.32380374, -0.16793643, -0.36900316,  0.30949069, -0.15526335,        0.44010748,  0.08201418,  0.37883198,  0.34473445,  0.40539232,       -0.04011973,  0.04634682,  0.29860359, -0.21428115, -0.00974648,        0.09911031, -0.48446672,  0.09348141, -0.06632365,  0.30736053,       -0.1847552 ,  0.39288871,  0.07785722, -0.3159898 ,  0.28792923,        0.11203118, -0.44609073, -0.07980632,  0.17906884,  0.41860178])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[::<span class="number">4</span>] += noise</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X,y)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194212.png" alt="Untitled-1-2018417194212"></p><p>撒盐操作，让圆上的20个点不规则的显示在圆的周围</p><p>创建不同深度的决策树<br>进行数据训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line">tree1 = DecisionTreeRegressor(max_depth=<span class="number">1</span>)</span><br><span class="line">tree2 = DecisionTreeRegressor(max_depth=<span class="number">5</span>)</span><br><span class="line">tree3 = DecisionTreeRegressor(max_depth=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">X_train = radians.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y_train = np.c_[X,y]</span><br><span class="line"></span><br><span class="line">tree1.fit(X_train,y_train)</span><br><span class="line">tree2.fit(X_train,y_train)</span><br><span class="line">tree3.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>DecisionTreeRegressor(criterion=&apos;mse&apos;, max_depth=50, max_features=None,           max_leaf_nodes=None, min_impurity_decrease=0.0,           min_impurity_split=None, min_samples_leaf=1,           min_samples_split=2, min_weight_fraction_leaf=0.0,           presort=False, random_state=None, splitter=&apos;best&apos;)</code></pre><p>创建-100到100的预测数据，间隔为0.01<br>对数据进行预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X_test = np.arange(<span class="number">-100</span>,<span class="number">100</span>,<span class="number">0.01</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">y1_ = tree1.predict(X_test)</span><br><span class="line">y2_ = tree2.predict(X_test)</span><br><span class="line">y3_ = tree3.predict(X_test)</span><br></pre></td></tr></table></figure><p>显示图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(y1_[:,<span class="number">0</span>],y1_[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194233.png" alt="Untitled-1-2018417194233"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(y2_[:,<span class="number">0</span>],y2_[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018417194247.png" alt="Untitled-1-2018417194247"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(y3_[:,<span class="number">0</span>],y3_[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841719434.png" alt="Untitled-1-201841719434"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = np.sort(<span class="number">200</span> * np.random.random(<span class="number">200</span>) - <span class="number">100</span>,axis = <span class="number">0</span>)</span><br><span class="line"><span class="comment">#根据角度生成正弦值和余弦值，这些值就是圆上面的点</span></span><br><span class="line">y = np.array([np.pi * np.sin(X).ravel(),np.pi * np.cos(X).ravel()]).transpose()</span><br></pre></td></tr></table></figure><h4 id="1、预测隐形眼镜的类型"><a href="#1、预测隐形眼镜的类型" class="headerlink" title="1、预测隐形眼镜的类型"></a>1、预测隐形眼镜的类型</h4><p>分析lenses.txt文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'../data/lenses.txt'</span>,sep=<span class="string">'\t'</span>,header=<span class="keyword">None</span>)</span><br><span class="line">train = data.iloc[:,:<span class="number">4</span>].copy()</span><br><span class="line">target = data[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;no lenses&apos;, &apos;soft&apos;, &apos;hard&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="number">0</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;young&apos;, &apos;pre&apos;, &apos;presbyopic&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="number">1</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;myope&apos;, &apos;hyper&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="number">3</span>].unique()</span><br></pre></td></tr></table></figure><pre><code>array([&apos;reduced&apos;, &apos;normal&apos;], dtype=object)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map_dic = &#123;</span><br><span class="line">    <span class="string">'young'</span>:<span class="number">0</span>, </span><br><span class="line">    <span class="string">'pre'</span>:<span class="number">1</span>, </span><br><span class="line">    <span class="string">'presbyopic'</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">'myope'</span>:<span class="number">0</span>, </span><br><span class="line">    <span class="string">'hyper'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'no'</span>:<span class="number">0</span>, </span><br><span class="line">    <span class="string">'yes'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'reduced'</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">'normal'</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train.replace(map_dic,inplace=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(train,target,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line">logistic = LogisticRegression()</span><br><span class="line">tree = DecisionTreeClassifier(max_depth=<span class="number">3</span>)</span><br><span class="line">gaussion = GaussianNB()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"knn score is %f"</span>%knn.fit(X_train,y_train).score(X_test,y_test))</span><br><span class="line">print(<span class="string">"logisitci score is %f"</span>%logistic.fit(X_train,y_train).score(X_test,y_test))</span><br><span class="line">print(<span class="string">"tree score is %f"</span>%tree.fit(X_train,y_train).score(X_test,y_test))</span><br><span class="line">print(<span class="string">"gaussion score is %f"</span>%gaussion.fit(X_train,y_train).score(X_test,y_test))</span><br></pre></td></tr></table></figure><pre><code>knn score is 1.000000logisitci score is 0.800000tree score is 1.000000gaussion score is 1.000000</code></pre><p><a href="https://github.com/yuansuixin/DecisionTree" title="源码下载" target="_blank" rel="noopener">源码下载</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>多线程和多进程的区别与联系</title>
      <link href="/2017/04/14/much-thread/"/>
      <url>/2017/04/14/much-thread/</url>
      <content type="html"><![CDATA[<p>我们按照多个不同的维度，来看看多线程和多进程的对比（注：因为是感性的比较，因此都是相对的，不是说一个好得不得了，另外一个差的无法忍受）。</p><table><thead><tr><th>对比维度</th><th style="text-align:left">多进程</th><th style="text-align:left">多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td style="text-align:left">数据共享复杂，需要用IPC；数据是分开的，同步简单</td><td style="text-align:left">因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td style="text-align:left">占用内存多，切换复杂，CPU利用率低</td><td style="text-align:left">占用内存少，切换简单，CPU利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td style="text-align:left">创建销毁、切换复杂，速度慢</td><td style="text-align:left">创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td style="text-align:left">编程简单，调试简单</td><td style="text-align:left">编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td style="text-align:left">进程间不会互相影响</td><td style="text-align:left">一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td style="text-align:left">适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td style="text-align:left">适应于多核分布式</td><td>进程占优</td></tr></tbody></table><h3 id="1）需要频繁创建销毁的优先用线程"><a href="#1）需要频繁创建销毁的优先用线程" class="headerlink" title="1）需要频繁创建销毁的优先用线程"></a>1）需要频繁创建销毁的优先用线程</h3><p>原因请看上面的对比。</p><p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p><h3 id="2）需要进行大量计算的优先使用线程"><a href="#2）需要进行大量计算的优先使用线程" class="headerlink" title="2）需要进行大量计算的优先使用线程"></a>2）需要进行大量计算的优先使用线程</h3><p>所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。</p><p>这种原则最常见的是图像处理、算法处理。</p><h3 id="3）强相关的处理用线程，弱相关的处理用进程"><a href="#3）强相关的处理用线程，弱相关的处理用进程" class="headerlink" title="3）强相关的处理用线程，弱相关的处理用进程"></a>3）强相关的处理用线程，弱相关的处理用进程</h3><p>什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。</p><p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p><p>当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。</p><h3 id="4）可能要扩展到多机分布的用进程，多核分布的用线程"><a href="#4）可能要扩展到多机分布的用进程，多核分布的用线程" class="headerlink" title="4）可能要扩展到多机分布的用进程，多核分布的用线程"></a>4）可能要扩展到多机分布的用进程，多核分布的用线程</h3><p>原因请看上面对比。</p><h3 id="5）都满足需求的情况下，用你最熟悉、最拿手的方式"><a href="#5）都满足需求的情况下，用你最熟悉、最拿手的方式" class="headerlink" title="5）都满足需求的情况下，用你最熟悉、最拿手的方式"></a>5）都满足需求的情况下，用你最熟悉、最拿手的方式</h3><p>至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。 </p><p><strong>需要提醒的是：虽然我给了这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。</strong></p><p><strong>消耗资源</strong>：</p><p>从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p><p>线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。</p><p><strong>通讯方式</strong>：</p><p>进程之间传递数据只能是通过通讯的方式，即费时又不方便。线程时间数据大部分共享（线程函数内部不共享），快捷方便。但是数据同步需要锁对于static变量尤其注意</p><p><strong>线程自身优势：</strong></p><p>提高应用程序响应；使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；</p><p>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的内部类详细解析</title>
      <link href="/2017/03/02/inner-class/"/>
      <url>/2017/03/02/inner-class/</url>
      <content type="html"><![CDATA[<p>来说一说内部类，内部类一共分为四种，分别是</p><ol><li>静态内部类</li><li>局部内部类</li><li>成员内部类</li><li>匿名内部类</li></ol><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>类的成员</p><ol><li>成员变量</li><li>成员方法</li><li>构造方法</li><li>代码块</li><li>静态代码块</li><li>内部类</li></ol><p>按照内部类声明方式</p><ol><li>静态内部类<ul><li>static</li><li>属于类：类比于静态变量 静态方法，没有外部类的引用（不需要对象）（直接使用外部类的this也就是意味着不能直接访问外部类的非静态属性</li></ul></li></ol><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li><strong>静态内部类可以直接访问外部类的静态成员变量，静态内部类不可以直接 访问外部类的非静态成员变量</strong></li><li>调用方式：</li></ol><ul><li><p>导包的时候倒到外部类名为止<br>外部类类名.内部类类名 内部类对象名=new 外部类类名.内部类类名（）；</p></li><li><p>导包的时候倒到内部类的类名为止</p><p>内部类类名 内部类的对象名 =new 内部类类名 （）；</p><ul><li>内部类的对象名.内部类方法名（）；</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClass &#123;</span><br><span class="line"> static  int a=12;</span><br><span class="line"> //静态内部类</span><br><span class="line">     public static class Moo&#123;</span><br><span class="line">     int b=13;</span><br><span class="line">     public void add()&#123;</span><br><span class="line">     int c=14;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">Moo m=new Moo();</span><br><span class="line">m.add();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import com.qf.oop.innerclass.StaticInnerClass;</span><br><span class="line">import com.qf.oop.innerclass.StaticInnerClass.Moo;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*StaticInnerClass.Moo m=new StaticInnerClass.Moo();</span><br><span class="line">m.add();*/</span><br><span class="line">Moo m=new Moo();</span><br><span class="line">m.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>方法中<br>外部方法中的内部类，访问外部类局部变量</p><p>注意：</p><ol><li>局部内部类随方法的调用而被加载</li><li>也可以访问外部类的私有属性 持有外部类应用可以使用this</li><li>局部内部类的对象只能在该类中创建</li><li>局部内部类当中，如果访问外部类的局部变量（方法中的变量）一定是常量（使用final修饰）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class LocInnerClass &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">  final int a=12;</span><br><span class="line">  class Moo&#123;</span><br><span class="line">  int b=13;</span><br><span class="line">  public void add()&#123;</span><br><span class="line">  int c=14;</span><br><span class="line"> // a++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Moo m=new Moo();</span><br><span class="line">  m.add();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  LocInnerClass l=new LocInnerClass();</span><br><span class="line">  l.test();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void test()&#123;</span><br><span class="line">   final int a=12;</span><br><span class="line">  class Moo&#123;</span><br><span class="line">  int b=13;</span><br><span class="line">  public void add()&#123;</span><br><span class="line">  int c=14;</span><br><span class="line"> // a++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  System.out.println(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Moo m=new Moo();</span><br><span class="line">  m.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 2.成员内部类 可以使用4种访问权限符修饰</span><br><span class="line"> *   调用方式</span><br><span class="line"> *     第一种方式：</span><br><span class="line"> *       外部类类名 外部类对象名=new 外部类类名（）；</span><br><span class="line"> *       外部类类名.内部类类名 内部类对象名= 外部类对象名.new 内部类类名();</span><br><span class="line"> *       内部类对象名.方法名（）；</span><br><span class="line"> *      第二种方式：</span><br><span class="line"> *        外部类类名.内部类类名 内部类对象名=new 外部类类名（）.new 内部类类名（）；</span><br><span class="line"> *        内部类对象名.方法名（）；</span><br><span class="line"> * </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class InnerClass &#123;</span><br><span class="line">int a=12;</span><br><span class="line">   //成员内部类</span><br><span class="line">   public class Moo&#123;</span><br><span class="line">   int b=13;</span><br><span class="line">   public void add()&#123;</span><br><span class="line">   int c=14;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   /*InnerClass in=new InnerClass();</span><br><span class="line">   System.out.println(in.a);*/</span><br><span class="line">   //第一种方式</span><br><span class="line">   InnerClass in=new InnerClass();</span><br><span class="line">   InnerClass.Moo m=in.new Moo();</span><br><span class="line">   m.add();</span><br><span class="line">   InnerClass.Moo m1=in.new Moo();</span><br><span class="line">   m1.add();</span><br><span class="line">   </span><br><span class="line">   //第二种方式</span><br><span class="line">   InnerClass.Moo m3=new InnerClass().new Moo();</span><br><span class="line">   m3.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类变量名称一致的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InnerClass2 &#123;</span><br><span class="line">int a=12;</span><br><span class="line">   //成员内部类</span><br><span class="line">   public class Moo&#123;</span><br><span class="line">   int a=13;</span><br><span class="line">   public void add()&#123;</span><br><span class="line">   int a=14;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   System.out.println(&quot;内部类成员变量a=&quot;+new Moo().a);</span><br><span class="line">   System.out.println(&quot;内部类成员变量a=&quot;+this.a);</span><br><span class="line">   System.out.println(&quot;外部类的成员变量a=&quot;+new InnerClass2().a);</span><br><span class="line">   System.out.println(&quot;外部类的成员变量a=&quot;+InnerClass2.this.a);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">   //第二种方式</span><br><span class="line">   InnerClass2.Moo m3=new InnerClass2().new Moo();</span><br><span class="line">   m3.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>语法：</p><p>类名 对象名 = new 类名（）{<br>实现抽象方法<br>}</p><p>注意：</p><p>匿名内部类没有构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 匿名内部类：没有名字</span><br><span class="line"> * 语法：</span><br><span class="line"> *   类名 对象名=new 类名()&#123;</span><br><span class="line"> *      实现抽象方法</span><br><span class="line"> *   &#125;;</span><br><span class="line"> * 注意：</span><br><span class="line"> *   匿名内部类没有构造方法</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class NoNameInnerClass &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">    //AA a=new AA();</span><br><span class="line">    AA a=new BB();</span><br><span class="line">    a.add();</span><br><span class="line">    AA a1=new BB();</span><br><span class="line">    a1.add();</span><br><span class="line">    </span><br><span class="line">    //Animal an=new Animal();</span><br><span class="line">    Cat c=new Cat()&#123;</span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;猫咪正在和老鼠玩耍&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">    </span><br><span class="line">    Cat c1=new Cat()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;小猫咪抓老鼠&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line">    c1.catchMouse();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Cat c3=new MImi();</span><br><span class="line">    c3.catchMouse();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class AA&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;奔跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public abstract void add();</span><br><span class="line">&#125;</span><br><span class="line">class BB extends AA&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line">System.out.println(12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">interface Cat extends Animal&#123;</span><br><span class="line">void catchMouse();</span><br><span class="line">&#125;</span><br><span class="line">class MImi implements Cat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;小猫咪抓老鼠&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java小项目----DVD管理系统</title>
      <link href="/2017/02/07/dvd/"/>
      <url>/2017/02/07/dvd/</url>
      <content type="html"><![CDATA[<p>做了一个DVD的管理系统，包含了增删改查\借出和归还等功能和日期与字符串的装换问题，使用了最简单的java基础知识，封装了方法，属性，实现了基本的功能。这个系统同样适用于图书馆管理系统，里面也实现了借出和归还的功能。</p><p>下面给大家分析一下这个系统：</p><ul><li>用例1：数据初始化</li><li>用例2：实现菜单切换</li><li>用例3：实现查看DVD信息</li><li>用例4：实现新增DVD信息</li><li>用例5：实现删除DVD信息</li><li>用例6：实现借出DVD业务处理</li><li>用例7：实现归还DVD业务处理</li></ul><p><img src="http://img.blog.csdn.net/20171120101502937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171120101517209?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171120101539244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="4"></p><p><img src="http://img.blog.csdn.net/20171120101554328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="5"></p><p><img src="http://img.blog.csdn.net/20171120101638591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="6"></p><p><img src="http://img.blog.csdn.net/20171120101651943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="7"></p><p><img src="http://img.blog.csdn.net/20171120101709822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="8"></p><p><img src="http://img.blog.csdn.net/20171120101719262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="9"></p><p><img src="http://img.blog.csdn.net/20171120101756945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="10"></p><p><img src="http://img.blog.csdn.net/20171120101822847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="11"></p><p><img src="http://img.blog.csdn.net/20171120101832412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="12"></p><p><img src="http://img.blog.csdn.net/20171120101843800?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="13"></p><p><img src="http://img.blog.csdn.net/20171120101854670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="14"></p><p><img src="http://img.blog.csdn.net/20171120101907654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="15"></p><p>下面是源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class DVDSet &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line">int state;</span><br><span class="line">String date;</span><br><span class="line"></span><br><span class="line">public DVDSet() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DVDSet(String name, int state, String date) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.state = state;</span><br><span class="line">this.date = date;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">if(state==0) &#123;</span><br><span class="line">return  name + &quot;\t  &quot; + &quot;已借出&quot; + &quot;\t&quot; + date ;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return  name + &quot;\t  &quot; + &quot;可借&quot; + &quot;\t&quot; + date ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line">public void setState(int state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">&#125;</span><br><span class="line">public String getDate() &#123;</span><br><span class="line">return date;</span><br><span class="line">&#125;</span><br><span class="line">public void setDate(String date) &#123;</span><br><span class="line">this.date = date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class DVDMgr &#123;</span><br><span class="line"></span><br><span class="line">final int LENGTH = 20;</span><br><span class="line"></span><br><span class="line">DVDSet[] dvd = new DVDSet[LENGTH];</span><br><span class="line"></span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">// 在构造器中传入日期样式</span><br><span class="line">// SimpleDateFormat sdf=new SimpleDateFormat(</span><br><span class="line">// &quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot;);</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">public void startMenu() &#123;</span><br><span class="line">printMain();</span><br><span class="line">// 初始化</span><br><span class="line">initial();</span><br><span class="line"></span><br><span class="line">int key = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">// 菜单切换</span><br><span class="line">switch (key) &#123;</span><br><span class="line">case 1:</span><br><span class="line">System.out.print(&quot;请输入新增的DVD名称：&quot;);</span><br><span class="line"></span><br><span class="line">String dName = scanner.next();</span><br><span class="line">System.out.println(&quot;您要增加的DVD名字是《&quot; + dName + &quot;》&quot;);</span><br><span class="line"></span><br><span class="line">add(dName);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">System.out.println(&quot;DVD信息如下：&quot;);</span><br><span class="line">System.out.println(&quot;name\tstate\tdate&quot;);</span><br><span class="line">search();</span><br><span class="line"></span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">System.out.print(&quot;请输入要删除的DVD名称：&quot;);</span><br><span class="line">String deleteN = scanner.next();</span><br><span class="line">System.out.println(&quot;您要删除的DVD名称为《&quot; + deleteN + &quot;》&quot;);</span><br><span class="line"></span><br><span class="line">delete(deleteN);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 4:</span><br><span class="line">System.out.print(&quot;请输入你要借的DVD的名称：&quot;);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"></span><br><span class="line">loan(name);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 5:</span><br><span class="line">System.out.print(&quot;请输入你要归还的DVD的名称：&quot;);</span><br><span class="line">String guihuan = scanner.next();</span><br><span class="line"></span><br><span class="line">returnDvd(guihuan);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 6:</span><br><span class="line">System.exit(0);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;您输入的有误，请重新输入！&quot;);</span><br><span class="line">startMenu();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printMain() &#123;</span><br><span class="line">// 主菜单显示</span><br><span class="line">System.out.println(&quot;欢迎使用迷你DVD管理器&quot;);</span><br><span class="line">System.out.println(&quot;========================================================&quot;);</span><br><span class="line">System.out.println(&quot;1. 新增DVD&quot;);</span><br><span class="line">System.out.println(&quot;2. 查看DVD&quot;);</span><br><span class="line">System.out.println(&quot;3. 删除DVD&quot;);</span><br><span class="line">System.out.println(&quot;4. 借出 DVD&quot;);</span><br><span class="line">System.out.println(&quot;5. 归还DVD&quot;);</span><br><span class="line">System.out.println(&quot;6. 退       出&quot;);</span><br><span class="line">System.out.println(&quot;========================================================&quot;);</span><br><span class="line">System.out.print(&quot;请选择：&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void returnMain() &#123;</span><br><span class="line">System.out.print(&quot;输入0返回：&quot;);</span><br><span class="line">int reStep = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">if (reStep == 0) &#123;</span><br><span class="line">startMenu();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;您输入的有误，请重新输入!&quot;);</span><br><span class="line">returnMain();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void initial() &#123;</span><br><span class="line">dvd[0] = new DVDSet(&quot;罗马假日&quot;, 0, &quot;2013-7-1&quot;);</span><br><span class="line">dvd[1] = new DVDSet(&quot;风声鹤唳&quot;, 1, &quot;&quot;);</span><br><span class="line">dvd[2] = new DVDSet(&quot;浪漫满屋&quot;, 1, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void search() &#123;</span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] != null) &#123;</span><br><span class="line">System.out.println(dvd[i]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(String string) &#123;</span><br><span class="line"></span><br><span class="line">String formatDate = dvdDate();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">dvd[i] = new DVDSet();</span><br><span class="line">dvd[i].setName(string);</span><br><span class="line">dvd[i].setState(1);</span><br><span class="line">dvd[i].setDate(formatDate);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void delete(String string) &#123;</span><br><span class="line">boolean b = false;</span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (string.equals(dvd[i].getName())) &#123;</span><br><span class="line">System.out.println(dvd[i]);</span><br><span class="line">if (dvd[i].getState() == 0) &#123;</span><br><span class="line">System.out.println(&quot;你要删除的DVD已借出，不可以删除！&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; dvd.length - 1) &#123;</span><br><span class="line">dvd[i] = dvd[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">dvd[dvd.length - 1] = null;</span><br><span class="line">System.out.println(&quot;您删除的《&quot; + string + &quot;》&quot; + &quot;删除成功&quot;);</span><br><span class="line">b = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!b) &#123;</span><br><span class="line">System.out.println(&quot;你输入的DVD不存在。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// returnMain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void loan(String string) &#123;</span><br><span class="line">boolean b = false;</span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (string.equals(dvd[i].getName())) &#123;</span><br><span class="line">if (dvd[i].getState() != 0) &#123;</span><br><span class="line">b = true;</span><br><span class="line">dvd[i].setState(0);</span><br><span class="line">System.out.println(&quot;你成功借出了《&quot; + string + &quot;》&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;此书已经借出&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!b) &#123;</span><br><span class="line">System.out.println(&quot;你要借的DVD不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void returnDvd(String string) &#123;</span><br><span class="line">boolean b = false;</span><br><span class="line">String date = dvdDate();</span><br><span class="line">DecimalFormat df = new DecimalFormat(&quot;######0.00&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (string.equals(dvd[i].getName())) &#123;</span><br><span class="line">if (dvd[i].getState() != 1) &#123;</span><br><span class="line">b = true;</span><br><span class="line">dvd[i].setState(1);</span><br><span class="line">System.out.println(&quot;你成功归还了《&quot; + string + &quot;》&quot;);</span><br><span class="line">System.out.println(&quot;借出日期为：&quot; + dvd[i].getDate());</span><br><span class="line">System.out.println(&quot;归还日期为：&quot; + date);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">long a = sdf.parse(date).getTime() - sdf.parse(dvd[i].getDate()).getTime();</span><br><span class="line">double d = a * 0.0000000001;</span><br><span class="line"></span><br><span class="line">df.format(d);</span><br><span class="line">System.out.println(&quot;应付租金（元）：&quot; + d);</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;此书未借出&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!b) &#123;</span><br><span class="line">System.out.println(&quot;你要归还的DVD不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String dvdDate() &#123;</span><br><span class="line">// sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);</span><br><span class="line">// 当前系统时间</span><br><span class="line">Date date = new Date();</span><br><span class="line">// 调用format(Date date)对象传入的日期参数进行格式化</span><br><span class="line">// format(Date date)将日期转化成字符串</span><br><span class="line">String formatDate = sdf.format(date);</span><br><span class="line">// System.out.println(&quot;格式化后的日期为:&quot; + formatDate);</span><br><span class="line"></span><br><span class="line">return formatDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">DVDMgr dvdMgr = new DVDMgr();</span><br><span class="line">dvdMgr.startMenu();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中abstract详解</title>
      <link href="/2017/01/28/abstract/"/>
      <url>/2017/01/28/abstract/</url>
      <content type="html"><![CDATA[<p>今天来介绍一下抽象类。我们用动物类来看，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal= new Animal();</span><br><span class="line">animal.name=&quot;动物&quot;;</span><br><span class="line">animal.shout();</span><br><span class="line">animal.sleep();</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.name= &quot;旺财&quot;;</span><br><span class="line">System.out.print(&quot;狗狗&quot;+dog.name);</span><br><span class="line">dog.shout();</span><br><span class="line">dog.sleep();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.name=&quot;小花&quot;;</span><br><span class="line">System.out.print(&quot;猫咪&quot;+cat.name);</span><br><span class="line">cat.shout();</span><br><span class="line">cat.sleep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">狗狗旺财汪汪叫</span><br><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">猫咪小花喵喵叫</span><br><span class="line">闭上眼睛就睡觉</span><br></pre></td></tr></table></figure><p>从上面的类中我们可以发现animal类中的shout（）方法在生活中几乎是不可能用到的，于是我们为了代码的简洁，shout（）方法不需要方法体，但是会报错误This method requires a body instead of a semicolon。于是我们便引入了abstract关键字。当我们加上abstract之后，还是会报错误The abstract method shout in type Animal can only be defined by an abstract class。那么怎么办呢？抽象方法需要在抽象类中定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void shout() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动物类</span><br><span class="line"> * shout(); 这个方法里的方法体没有用 但这个方法不能注释 让子类重写</span><br><span class="line"> * 1.abstract抽象的</span><br><span class="line"> *   The abstract method shout in type Animal can only be defined by an abstract class</span><br><span class="line"> * 2.如何定义一个抽象方法</span><br><span class="line"> *   语法：</span><br><span class="line"> *     【访问权限符】 abstract 返回值 方法名();</span><br><span class="line"> *   eg：</span><br><span class="line"> *      public abstract void shout();</span><br><span class="line"> * 3.如何定义一个抽象类</span><br><span class="line"> *   语法：</span><br><span class="line"> *    【访问权限符】  abstract class 类名&#123;&#125;</span><br><span class="line"> *   eg:</span><br><span class="line"> *    public abstract class Animal &#123;</span><br><span class="line"> *    &#125;</span><br><span class="line"> * 4.总结</span><br><span class="line"> *     A.抽象方法一定要在抽象类中</span><br><span class="line"> *     B.抽象类中可以有   0 1 多个 抽象方法</span><br><span class="line"> *     C.抽象类不能直接实例对象 只能创建子类对象 抽象类一定要被继承</span><br><span class="line"> *       Cannot instantiate the type Animal</span><br><span class="line"> *     D.子类继承父类 如果父类是抽象类 子类一定要实现父类里所有的抽象方法 除非子类也是抽象类</span><br><span class="line"> *     E.abstract可以修饰   类  方法</span><br><span class="line"> *               不能修饰   成员变量 构造方法</span><br><span class="line"> *     F.抽象类中的成员</span><br><span class="line"> *               成员变量   成员方法  构造方法       </span><br><span class="line"> *        </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>总结一下知识点：</p><ol><li><p>语法</p><p>A.抽象类和抽象方法必须使用 abstract修饰<br>B.抽象类不能直接实例 只能被继承<br>C.抽象类必须有构造方法 创建子类对象时候需要<br>D.抽象类可以有至少0个抽象方法<br>E.抽象方法只有声明没有实现（名字 没有方法体）<br>F.public abstract void shout(){} 不是抽象方法<br>G.子类必须重写抽象方法，如果不重写，自己也得是抽象类</p></li></ol><p>2.意义<br>A.抽象类为所有子类提供了一个通用模板,子类可以在此模板上进行扩展<br>B.通过抽象类，可以避免子类设计随意性<br>C.通过抽象类，可以严格限制子类的设计，使得子类更加通用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类就是用来作父类的用来被继承的</span><br></pre></td></tr></table></figure><p>问题1：<br>Animal an=new Animal(); 没有一种生物叫Animal 创建Animal没有意义<br>拒绝实例<br>解决方法：<br>Animal类 定义为抽象类<br>抽象类不能直接实例但可以被继承</p><p>问题2:<br>dog可以重写shout也可以不重写 如果希望dog必须重写shout方法 不重写就有编译错误</p><p>解决方法：<br>Animal类 里的shout方法定义为抽象方法<br>抽象方法只有声明，没有实现</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中的IO流详细解析----字符流</title>
      <link href="/2016/12/15/java-io3/"/>
      <url>/2016/12/15/java-io3/</url>
      <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20171122204022285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171122204035500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>由于Java采用16位的Unicode字符，因此需 要基于字符的输入/输出操作。从Java1.1 版开始，加入了专门处理字符流的抽象类 Reader和Writer，前者用于处理输入，后 者用于处理输出。这两个类类似于 InputStream和OuputStream，也只是提供 一些用于字符流的规定，本身不能用来生 成对象 </p><p> Java程序语言使用Unicode来表示字符串和字符， Unicode使用两个字节来表示一个字符，即一个 字符占16位 </p><p><strong>交换流</strong></p><p>==InputStreamReader和OutputStreamWriter==</p><p>这是java.io包中用于处理字符流的基本类， 用来在字节流和字符流之间搭一座“桥”。这 里字节流的编码规范与具体的平台有关， 可以在构造流对象时指定规范，也可以使 用当前平台的缺省规范 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从控制台输入一句话保存到文件中</span><br><span class="line"> * 文件输出流 将读到的数据写入到本地文件中</span><br><span class="line"> * 转换流 读 输入信息</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Test3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//1.选择合适的流</span><br><span class="line">BufferedReader br=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">BufferedWriter bw=new BufferedWriter(new FileWriter(&quot;D:\\qf1717\\转换流.txt&quot;));</span><br><span class="line">//BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;D:\\qf1717\\转换流.txt&quot;),&quot;UTf-8&quot;));</span><br><span class="line">//2处理数据</span><br><span class="line">System.out.println(&quot;请输入一些话：(输入end结束)&quot;);</span><br><span class="line">String data = br.readLine();</span><br><span class="line">while(!&quot;end&quot;.equals(data))&#123;</span><br><span class="line">System.out.println(&quot;#&quot;+data);</span><br><span class="line">//写入文件</span><br><span class="line">bw.write(data);</span><br><span class="line">//手动换行处理</span><br><span class="line">bw.newLine();</span><br><span class="line">//再读</span><br><span class="line">data=br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">//3关闭流</span><br><span class="line">bw.close();</span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStreamReader和OutputStreamWriter 类的主要构造方法如下 </p><ul><li>public InputSteamReader(InputSteam in) </li><li>public InputSteamReader(InputSteam in,String enc) </li><li>public OutputStreamWriter(OutputStream out) </li><li>public OutputStreamWriter(OutputStream out,String enc)  </li></ul><p>• 其中in和out分别为输入和输出字节流对象， enc为<strong>指定的编码规范</strong>（若无此参数，表示 使用当前平台的缺省规范，可用 getEncoding()方法得到当前字符流所用 的编码方式）。 </p><p><strong>文件输入输出流</strong></p><p>==FileWriter和FileReader==</p><p>注意：<br> FileWriter(String filePath, boolean append)  </p><p> append ：如果为 true，则将字节写入文件末 尾处，而不是写入文件开始处，默认为false </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line"></span><br><span class="line">public class FileReader1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">FileReader fr = new FileReader(</span><br><span class="line">&quot;c:\\FileReader1.java&quot;);</span><br><span class="line"></span><br><span class="line">BufferedReader br = new BufferedReader(fr);</span><br><span class="line"></span><br><span class="line">String str;</span><br><span class="line"></span><br><span class="line">while (null != (str = br.readLine()))</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.FileWriter;</span><br><span class="line"></span><br><span class="line">public class FileWriter1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">String str = &quot;hello world welcome nihao hehe&quot;;</span><br><span class="line"></span><br><span class="line">char[] buffer = new char[str.length()];</span><br><span class="line"></span><br><span class="line">str.getChars(0, str.length(), buffer, 0);</span><br><span class="line"></span><br><span class="line">FileWriter f = new FileWriter(&quot;file2.txt&quot;);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; buffer.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">f.write(buffer[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符数组流</p><p>==CharArrayReader和CharArrayWriter==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.io.CharArrayReader;</span><br><span class="line"></span><br><span class="line">public class CharArrayReader1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">String tmp = &quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">char[] ch = new char[tmp.length()];</span><br><span class="line"></span><br><span class="line">tmp.getChars(0, tmp.length(), ch, 0);</span><br><span class="line"></span><br><span class="line">CharArrayReader input = new CharArrayReader(ch);</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">while(-1 != (i = input.read()))</span><br><span class="line">&#123;</span><br><span class="line">System.out.println((char)i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲字符流<br>BufferWriter和BufferReader</p><p>和字节流用法一致，我这里不在举例说明。</p><p>Properties类</p><p>主要是用于配置文件，这里简单的说一下。</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class PropertiesUserTest &#123;</span><br><span class="line">  public static void main(String[] args) throws FileNotFoundException, IOException &#123;</span><br><span class="line">  //1.实例一个Properties对象</span><br><span class="line">  Properties info=new Properties();</span><br><span class="line">  //2.将User.properties中的键值对 添加入info集合中</span><br><span class="line"> /* void load(InputStream inStream) </span><br><span class="line">      从输入流中读取属性列表（键和元素对）。 */</span><br><span class="line">  info.load(new BufferedInputStream(new FileInputStream(new File(&quot;file\\User.properties&quot;))));</span><br><span class="line">      System.out.println(info);</span><br><span class="line">      </span><br><span class="line">      //3.在info中添加一对新的键值对</span><br><span class="line">     /* Object setProperty(String key, String value) </span><br><span class="line">      调用 Hashtable 的方法 put。 */</span><br><span class="line">      info.setProperty(&quot;address&quot;, &quot;China&quot;);</span><br><span class="line">      System.out.println(info);</span><br><span class="line">      </span><br><span class="line">      //4.将集合中的新添加的键值对同步到配置文件中</span><br><span class="line">      /*void store(OutputStream out, String comments) </span><br><span class="line">      以适合使用 load(InputStream) 方法加载到 Properties </span><br><span class="line">      表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。 */</span><br><span class="line">      //comments--属性列表的描述</span><br><span class="line">      info.store(new BufferedOutputStream (new FileOutputStream(new File(&quot;file\\User.properties&quot; ))), </span><br><span class="line">      &quot;add a pair of key and value&quot;);</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO流的内容比较多，但是不是很难，希望大家能够看懂例子。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">csdn博客相关内容</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--策略模式（strategy-pattern）解析</title>
      <link href="/2016/11/08/strategy/"/>
      <url>/2016/11/08/strategy/</url>
      <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）中体现了两个非常基本的面相对象设计的原则：</p><ol><li>封装变化的概念</li><li>编程中使用接口，而不是对接口的实现</li></ol><p>策略模式的定义 ：</p><ul><li>定义一组算法，将每个算法都封装起来，并且 使它们之间可以互换。</li><li>策略模式使这些算法在客户端调用它们的时候 能够互不影响地变化</li></ul><p>策略模式的意义</p><ul><li><p>策略模式使开发人员能够开发出由许多可替换 的部分组成的软件，并且各个部分之间是弱连 接的关系。</p></li><li><p>弱连接的特性使软件具有更强的可扩展性，易 于维护；更重要的是，它大大提高了软件的可 重用性</p><p>策略模式的组成</p></li><li><p>抽象策略角色：策略类，通常由一个接口或者 抽象类实现</p></li><li><p>具体策略角色：包装了相关的算法和行为</p></li><li><p>环境角色：持有一个策略类的引用，最终给客 户端调用的。</p><p>策略模式的实现</p></li><li><p>策略模式的用意是针对一组算法，将每一个算 法封装到具有共同接口的独立的类中，从而使 得它们可以相互替换。</p></li><li><p>策略模式使得算法可以在不影响到客户端的情 况下发生变化。使用策略模式可以把行为和环 境分割开来。</p></li><li><p>环境类负责维持和查询行为类，各种算法则在 具体策略中提供。由于算法和环境独立开来， 算法的修改都不会影响环境和客户端</p></li></ul><p>策略模式的编写步骤 ：</p><ol><li>对策略对象定义一个公共接口。</li></ol><p>2．编写策略类，该类实现了上面的公共接口</p><p>3．在使用策略对象的类中保存一个对策略对 象的引用。</p><p>4．在使用策略对象的类中，实现对策略对象 的set和get方法（注入）或者使用构造方法完 成赋值</p><p>小提示：在eclipse里面Ctrl+t 进入到实现类的代码中去。</p><p>下面我们以计算器为例实现我们的策略模式：</p><h6 id="抽象策略角色"><a href="#抽象策略角色" class="headerlink" title="抽象策略角色"></a>抽象策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="具体策略角色"><a href="#具体策略角色" class="headerlink" title="具体策略角色"></a>具体策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AddStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SubtractStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MultiplyStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class DivideStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Environment &#123;</span><br><span class="line"></span><br><span class="line">private Strategy strategy;</span><br><span class="line"></span><br><span class="line">public Environment (Strategy strategy) &#123;</span><br><span class="line">this.strategy= strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Strategy getStrategy() &#123;</span><br><span class="line">return strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b) &#123;</span><br><span class="line">return strategy.calculate(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AddStrategy addStrategy = new AddStrategy();</span><br><span class="line">Environment environment = new Environment(addStrategy);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;3+4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">SubtractStrategy strategy = new SubtractStrategy();</span><br><span class="line">environment.setStrategy(strategy);</span><br><span class="line">System.out.println(&quot;3-4=&quot;+environment.calculate(3, 4));</span><br><span class="line"></span><br><span class="line">MultiplyStrategy multiplyStrategy = new MultiplyStrategy();</span><br><span class="line">environment.setStrategy(multiplyStrategy);</span><br><span class="line">System.out.println(&quot;3*4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">DivideStrategy divideStrategy = new DivideStrategy();</span><br><span class="line">environment.setStrategy(divideStrategy);</span><br><span class="line">System.out.println(&quot;3/4=&quot;+environment.calculate(3,4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3+4=7</span><br><span class="line">3-4=-1</span><br><span class="line">3*4=12</span><br><span class="line">3/4=0</span><br></pre></td></tr></table></figure><p>策略模式的缺点</p><ul><li>客户端必须知道所有的策略类，并自行决定 使用哪一个策略类。</li><li>造成很多的策略类。</li></ul><p>解决方案</p><ul><li>采用工厂方法</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中String类详细解析</title>
      <link href="/2016/04/24/string/"/>
      <url>/2016/04/24/string/</url>
      <content type="html"><![CDATA[<p>1.相等性的比较（==）<br>(1)对于原生数据类型来说，比较的是左右两边的值是否相等<br>（2）对于引用类型来说，比较左右两边的引用是否指向同一个对象，或者说左右两边的引用地址是否相同。</p><p>2.Object 类的tostring方法返回的是一个哈希code值，而string类重写了tostring方法，默认调用tostring方法。<br>API （Application Programming Interface），应用编程接口。<br>当打印引用时，实际上会打印出引用所指对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，而Object类中定义了toString()，因此每个类都有toString()这个方法。</p><p>3.equals方法<br>对于object类的equals方法来说，是用来判断两个对象是不是同一个对象。<br>对于继承了object类的其他类来说，如果重写了equals方法，才是判断内容是否一致，，如果没有重写equals方法，是判断地址是否一致。<br>对于String类的equals()方法来说，它是判断当前字符串与传进来的字符串的内容是否一致。</p><p>4.字符串是一个常量，创建之后值是不能被改变的。</p><p>5.String是常量，其对象一旦创建完毕就无法改变。当使用+拼接字符串时，会生成新的String对象，而不是向原有的String对象追加内容。</p><p>6、 String Pool（字符串池）</p><p>7、 String s = “aaa”;（采用字面值方式赋值）<br>1) 查找String Pool中是否存在“aaa”这个对象，如果不存在，则在String Pool中创建一个“aaa”对象，然后将String Pool中的这个“aaa”对象的地址返回来，赋给引用变量s，这样s会指向String Pool中的这个“aaa”字符串对象<br>2) 如果存在，则不创建任何对象，直接将String Pool中的这个“aaa”对象地址返回来，赋给s引用。</p><p>8、 String s = new String(“aaa”);<br>1) 首先在String Pool中查找有没有“aaa”这个字符串对象，如果有，则不在String Pool中再去创建“aaa”这个对象了，直接在堆中（heap）中创建一个“aaa”字符串对象，然后将堆中的这个“aaa”对象的地址返回来，赋给s引用，导致s指向了堆中创建的这个“aaa”字符串对象。<br>2) 如果没有，则首先在String Pool中创建一个“aaa“对象，然后再在堆中（heap）创建一个”aaa“对象，然后将堆中的这个”aaa“对象的地址返回来，赋给s引用，导致s指向了堆中所创建的这个”aaa“对象。</p><p>9.new出来的对象都是在堆里面</p><p>10.intern（）方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Object object = new Object();</span><br><span class="line">Object object2 = new Object();</span><br><span class="line"></span><br><span class="line">//object类中的equals方法是使用==判断的</span><br><span class="line">System.out.println(object == object2);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line">String str = new String(&quot;aaa&quot;);</span><br><span class="line">String str2 = new String(&quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(str == str2);//false两个对象</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">//StringPool字符串池在栈中，当字符串被赋予字面值的时候，首先检查字符串池里面有没有该对象&quot;bbb&quot;</span><br><span class="line">//如果没有，就将该字符串放入字符串池里面，字符串变量便指向这个对象</span><br><span class="line">//如果有，就不会在字符串池里面创建新的对象，而是在已有的字符串池里面的对象直接返回来赋给字符串变量str4</span><br><span class="line">//所以str4并没有创建对象</span><br><span class="line">//new出来的对象都是在堆里面</span><br><span class="line">String str3 = &quot;bbb&quot;;//创建一个对象</span><br><span class="line">String str4 = &quot;bbb&quot;;//并没有创建对象</span><br><span class="line"></span><br><span class="line">System.out.println(str3 == str4);//true指向同一个对象</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">String str5 = new String(&quot;ccc&quot;);</span><br><span class="line">String str6 = &quot;ccc&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str5 == str6);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">//字符串的拼接并不是将字符串拼接到后面。字符串是常量，创建后就不能改变了，</span><br><span class="line">//加法操作实际上是生成了一个新的对象，而不是往原有的对象追加内容。</span><br><span class="line">String s = &quot;hello&quot;;//</span><br><span class="line">String s1 = &quot;hel&quot;;</span><br><span class="line">String s2 = &quot;lo&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s == s1 + s2);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line">System.out.println(s == &quot;hel&quot; + &quot;lo&quot;);//true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package testPackage;</span><br><span class="line">class Test &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                String hello = &quot;Hello&quot;, lo = &quot;lo&quot;;</span><br><span class="line">                System.out.print((hello == &quot;Hello&quot;) + &quot; &quot;);</span><br><span class="line">                System.out.print((Other.hello == hello) + &quot; &quot;);</span><br><span class="line">                System.out.print((other.Other.hello == hello) + &quot; &quot;);</span><br><span class="line">                System.out.print((hello == (&quot;Hel&quot;+&quot;lo&quot;)) + &quot; &quot;);</span><br><span class="line">                System.out.print((hello == (&quot;Hel&quot;+lo)) + &quot; &quot;);</span><br><span class="line">                System.out.println(hello == (&quot;Hel&quot;+lo).intern());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other &#123; static String hello = &quot;Hello&quot;; &#125;</span><br></pre></td></tr></table></figure><h6 id="and-the-compilation-unit"><a href="#and-the-compilation-unit" class="headerlink" title="and the compilation unit:"></a>and the compilation unit:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">public class Other &#123; static String hello = &quot;Hello&quot;; &#125;</span><br></pre></td></tr></table></figure><h6 id="produces-the-output"><a href="#produces-the-output" class="headerlink" title="produces the output:"></a>produces the output:</h6><p>true true true true false true</p><h6 id="This-example-illustrates-six-points"><a href="#This-example-illustrates-six-points" class="headerlink" title="This example illustrates six points:"></a>This example illustrates six points:</h6><p>1.Literal strings within the same class (§8) in the same package (§7) represent references to the same String object (§4.3.1).<br>2.Literal strings within different classes in the same package represent references to the same String object.<br>3.Literal strings within different classes in different packages likewise represent references to the same String object.<br>4.Strings computed by constant expressions (§15.28) are computed at compile time and then treated as if they were literals.<br>5.Strings computed by concatenation at run time are newly created and therefore distinct.</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中TreeSet底层解析和collections解析</title>
      <link href="/2016/03/27/treeset-collections/"/>
      <url>/2016/03/27/treeset-collections/</url>
      <content type="html"><![CDATA[<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>下图是集合框架中的接口<br><img src="http://img.blog.csdn.net/20171107204219357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>今天我来谈谈SortedSet接口。</p><p>TreeSet实现了SortedSet接口，如果有自然的顺序，TreeSet具有排序的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">set.add(&quot;C&quot;);</span><br><span class="line">set.add(&quot;A&quot;);</span><br><span class="line">set.add(&quot;B&quot;);</span><br><span class="line">set.add(&quot;E&quot;);</span><br><span class="line">set.add(&quot;F&quot;);</span><br><span class="line">set.add(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A,B,C,D,E,F]</span><br></pre></td></tr></table></figure><p>但是如果没有自然顺序的值还有正常的排序吗？我们一起来看看。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出现了，报错误了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other.Person cannot be cast to java.lang.Comparable</span><br></pre></td></tr></table></figure><p>不要慌张，去底层寻找解决办法。</p><p><img src="http://img.blog.csdn.net/20171107210401006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>遇到错误通过文档去查找，大部分都是可以解决的哦，一定要有耐心哟!<br>TreeSet是带有排序的，我们刚才没有给程序说按照什么规则比较，所以我们要向往TreeSet放置对象，我们必须要告诉TreeSet排序的规则，制定好排序的规则，但是在哪里指定呢？和我一起来查看TreeSet的构造方法吧。</p><p><img src="http://img.blog.csdn.net/20171107210824004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>改bug：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan2;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet(new PersonComparator());</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonComparator implements Comparator</span><br><span class="line">&#123;</span><br><span class="line">public int compare(Object arg0, Object arg1)</span><br><span class="line">&#123;</span><br><span class="line">Person p1 = (Person) arg0;</span><br><span class="line">Person p2 = (Person) arg1;</span><br><span class="line"></span><br><span class="line">return p2.score - p1.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">40</span><br><span class="line">30</span><br><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections的一些方法用起来还是很方便的，分享给大家，Collections里面的方法都是静态的，可以直接调用。<br>sort（）；排序<br>reverseOrder()；反序<br>shuffle（）;乱序<br>min();最小<br>max();最大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">LinkedList list = new LinkedList();</span><br><span class="line"></span><br><span class="line">list.add(new Integer(-8));</span><br><span class="line">list.add(new Integer(20));</span><br><span class="line">list.add(new Integer(-20));</span><br><span class="line">list.add(new Integer(8));</span><br><span class="line">//自然顺序的反序操作</span><br><span class="line">Comparator r = Collections.reverseOrder();</span><br><span class="line">//排序</span><br><span class="line">Collections.sort(list, r);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">//乱序</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;minimum value: &quot; + Collections.min(list));</span><br><span class="line">System.out.println(&quot;maximum value: &quot; + Collections.max(list));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">20 8 -8 -20 </span><br><span class="line">-20 20 -8 8 </span><br><span class="line">minimum value: -20</span><br><span class="line">maximum value: 20</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--单例模式</title>
      <link href="/2016/01/23/singleton/"/>
      <url>/2016/01/23/singleton/</url>
      <content type="html"><![CDATA[<p>单例模式分为两种：饿汉式、懒汉式</p><p>既然是单例模式，那么就只有一个实例，那么构造方法就是私有的，就需要创建一个对象，而且也需要是私有的，但是需要调用所以要设置成静态的，然后提供一个方法拿到这个私有的对象。<br>一个类只会生成唯一的一个对象。</p><p>单例模式：饿汉式</p><p>1.私有构造方法<br>2.创建私有的静态对象<br>3.创建一个公共公开的方法，返回该私有对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Single1 &#123;</span><br><span class="line">  private static Single1 s1=new Single1();</span><br><span class="line">  private Single1()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static  Single1 getInstance()&#123;</span><br><span class="line">  return s1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">/*Single1 s1=new Single1();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=new Single1();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);*/</span><br><span class="line">Single1 s1=Single1.getInstance();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=Single1.getInstance();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>饿汉式就是更急切的new出来了对象，而懒汉式就不这样了，其实，本质是一样的，让我们来看看懒汉吧。</p><p>单例模式：懒汉式</p><p>1.私有构造方法</p><ol><li>创建私有静态对象<br>3.创建公开公共的静态方法返回该私有对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Single2 &#123;</span><br><span class="line">  private static Single2 s2=null;</span><br><span class="line">  private Single2()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  s2=new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;</span><br><span class="line">  &#125;</span><br><span class="line">  /*public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  return new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;  错误的</span><br><span class="line">  &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Single2 s1=Single2.getInstance();</span><br><span class="line">  System.out.println(s1);</span><br><span class="line">  Single2 s2=Single2.getInstance();</span><br><span class="line">  System.out.println(s2);</span><br><span class="line">  System.out.println(s1==s2);</span><br><span class="line">  //Object</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式的单例模式有一种错误的方法，我已经在代码中写出来了，大家一定要注意，仔细一点哦。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--工厂模式解析</title>
      <link href="/2015/10/02/factory/"/>
      <url>/2015/10/02/factory/</url>
      <content type="html"><![CDATA[<p>在看工厂模式之前我们先了解一下面相对象的原则。</p><p>面向对象设计的基本原则</p><ul><li>OCP开闭原则：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP依赖倒转原则：要针对接口编程，不要针对实现编程</li><li>LOD迪米特法则：只与你直接的朋友通信，而避免和陌生人通话。</li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>实现了创建者和调用者的分离，下面我用汽车类的例子来介绍。</p><p>详细分类</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>也称之为静态工厂模式，项目开发中通常使用</p><p>(下面的例子对比了使用工厂模式和不适用工厂模式的情况)<br>工厂类：两种方式都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂类用来创建汽车，这个类里的方法需要是static的</span><br><span class="line">public class CarFactory &#123;</span><br><span class="line"></span><br><span class="line">public static Car createCar(String type) &#123;</span><br><span class="line">if(&quot;奥迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;else if (&quot;比亚迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return null;///违反了开闭原则</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CarFactory2 &#123;</span><br><span class="line"></span><br><span class="line">public static Car createAudi() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line">public static  Car  createByd() &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个车的接口，供各种类型的汽车实现</span><br><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不使用工厂模式的情况</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new Audi();</span><br><span class="line">Car car2 = new Byd();</span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单工厂情况下</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Client02 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car = CarFactory.createCar(&quot;奥迪&quot;);</span><br><span class="line">Car car2 = CarFactory.createCar(&quot;比亚迪&quot;);</span><br><span class="line"></span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure><p>简单工厂模式违背了面向对象编程的开闭原则，所以进一步发展就有了咱们下面要介绍的工厂方法模式，其实工厂方法模式在理论上是符合面相编程设计的原则的，但是实用性不如简单工厂模式大，他定义了太多的类和接口，每个具体的车类都需要有一个对应的车工厂，没有简单工厂模式简洁。在实际的开发中，简单工厂模式较为实用。</p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>根据设计理论上工厂方法模式占优势，实际上比简单工厂模式要复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂的接口，来供其他的具体车类实现</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line"></span><br><span class="line">Car createCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AudiFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;奔驰在跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BenzFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Benz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BydFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new AudiFactory().createCar();</span><br><span class="line">car.run();</span><br><span class="line"></span><br><span class="line">Car car2 = new BydFactory().createCar();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure><p>工厂方法模式不修改已有类的前提下，通过增加新的工厂类实现扩展。工厂方法模式在理论上符合面向对象设计的原则，但是带来了类的冗余和拓展，所以实际中不大使用。</p><p>下面来看一下最后一种抽象工厂模式，也是最复杂的一种</p><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>用来生产不同产品族的全部产品（对于增加新的产品，无能为力，支持增加产品族）</p><p><img src="http://img.blog.csdn.net/20171110182731351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建车工厂</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line">Engine createEngine();</span><br><span class="line">Seat createSeat();</span><br><span class="line">Tyre createTyre();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建发动机接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">public interface Engine &#123;</span><br><span class="line">void run();</span><br><span class="line">void start();</span><br><span class="line">&#125;</span><br><span class="line">//高端发动机</span><br><span class="line">class LuxuryEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得快&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动快，可以自动启停&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//高端发动机</span><br><span class="line">class LowEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得慢&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动慢&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建座椅接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface Seat &#123;</span><br><span class="line"></span><br><span class="line">void massage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxurySeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowSeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;不可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建轮胎接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface Tyre &#123;</span><br><span class="line"></span><br><span class="line">void revolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxuryTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;旋转不磨损&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;磨损快&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低端类工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LowCarFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowSeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowTyre();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高端类工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class LuxuryCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxurySeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说一下工厂模式的应用场景<br><img src="http://img.blog.csdn.net/20171110182745587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中Map和Set的底层分析</title>
      <link href="/2015/06/12/map-set/"/>
      <url>/2015/06/12/map-set/</url>
      <content type="html"><![CDATA[<p>1.HashSet底层是使用HashMap实现的。当使用add方法将对象添加到Set当中时，实际上是将该对象作为底层所维护的Map对象的key，而value则都是同一个Object对象（该对象我们用不上）；其他的都是通过定义的HashMap对象实现的。</p><p>2.HashMap的底层，</p><p>loadFactor负载因子为0.75，数据结构中的哈希表有关。通过散列函数也就是哈希函数计算。<br>table是一个Entry类型的数组，当需要的时候回重新调整大小，他的长度必须为2的指数。默认生成一个长度为16的Entry类型的数组。</p><p>3.Entry是HashMap的内部类，实现了Map.Entry接口，实现了他的方法。</p><p>4.HashMap底层维护一个数组，我们向HashMap中所放置的对象实际上是存放在该数组中。</p><p>5.当向HashMap中put一对键值时，它会根据key的hashCode值计算出一个位置，该位置就是此对象准备往数组中存放的位置。<br>6.如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找（Entry类有一个Entry类型的next成员变量，指向了该对象的下一个对象），如果此链上有对象的话，再去使用equals方法进行比较，如果对此链上的某个对象的equals方法比较为false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。</p><p>7.HashMap的内存实现布局：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-20184222441.png" alt="Untitled-1-20184222441"></p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中Map接口实现类HashMap、Map.Entry接口</title>
      <link href="/2015/05/20/map-hashmap/"/>
      <url>/2015/05/20/map-hashmap/</url>
      <content type="html"><![CDATA[<p>来谈谈集合中的Map接口，它常用的实现类为HashMap。<br><img src="http://img.blog.csdn.net/20171108170056226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><hr><ul><li>除了类集，Java 2还在java.util中增加了映射。 映射（map）是一个存储关键字和值的关联 或者说是关键字/值对的对象。给定一个关 键字，可以得到它的值。关键字和值都是 对象。关键字必须是唯一的。但值是可以 重复的。有些映射可以接收null关键字和 null值。而有的则不行</li><li>Map接口映射唯一关键字到值。关键字（key）是 以后用于检索值的对象。给定一个关键字和一个 值，可以存储这个值到一个Map对象中。当这个 值被存储以后，就可以使用它的关键字来检索它。 当调用的映射中没有项存在时，其中的几种方法 会引发一个NoSuchElementException异常。而当对 象与映射中的元素不兼容时，引发一个 ClassCastException异常。如果试图使用映射不允 许使用的null对象时，则引发一个 NullPointerException异常。当试图改变一个不允 许修改的映射时，则引发一个 UnsupportedOperationException异常</li><li>映射循环使用两个基本操作：get( )和put( )。使用 put( )方法可以将一个指定了关键字和值的值加入 映射。为了得到值，可以通过将关键字作为参数 来调用get( )方法。调用返回该值。</li><li>映射不是类集，但可以获得映射的类集“视图”。 为了实现这种功能，可以使用entrySet( )方法，它 返回一个包含了映射中元素的集合（Set）。为了 得到关键字的类集“视图”，可以使用keySet( ) 方法，返回一个Set集合不可以重复。为了得到值的类集“视图”，可以使用 values( )方法，返回一个Collection集合，可以重复。类集“视图”是将映射集成到类集 框架内的手段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line">map.put(&quot;e&quot;, &quot;ee&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">String key = (String)iter.next();</span><br><span class="line">String value = (String)map.get(key);</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot;=&quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=aa</span><br><span class="line">b=bb</span><br><span class="line">c=cc</span><br><span class="line">d=dd</span><br><span class="line">e=ee</span><br></pre></td></tr></table></figure><p>遍历Map的两种方式，一种是直接打印输出，另一种是利用Set集合中的iterator（）；方法，首先调用Map的keySet（）方法返回一个Set集合，通过Set集合中key的值可以得到value的值。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><hr><p>HashMap类使用散列表实现Map接口。这允 许一些基本操作如get( )和put( )的运行时间 保持恒定，即便对大型集合，也是这样的 下面的构造函数定义为：</p><ul><li><p>HashMap( )</p></li><li><p>HashMap(Map m)</p></li><li><p>HashMap(int capacity)</p></li><li><p>HashMap(int capacity, float fillRatio)</p><p>第一种形式构造一个默认的散列映射。<br>第二种形式用m的元素初始化散列映射。<br>第三种形式将散列映射的容量初始化为 capacity。<br>第四种形式用它的参数同时初始化散列映 射的容量和填充比。容量和填充比的含义 与前面介绍的HashSet中的容量和填充比相同。<br>HashMap实现Map并扩展AbstractMap。它 本身并没有增加任何新的方法<br>应该注意的是散列映射并不保证它的元素 的顺序。因此，元素加入散列映射的顺序 并不一定是它们被迭代函数读出的顺序</p></li></ul><h1 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h1><hr><p>Map.Entry接口使得可以操作映射的输入。 回想由Map接口说明的entrySet( )方法，调 用该方法返回一个包含映射输入的集合 （Set）。这些集合元素的每一个都是一个 Map.Entry对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line"></span><br><span class="line">Set set = map.entrySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line"></span><br><span class="line">String key = (String)entry.getKey();</span><br><span class="line">String value = (String)entry.getValue();</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot; : &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a : aa</span><br><span class="line">b : bb</span><br><span class="line">c : cc</span><br><span class="line">d : dd</span><br></pre></td></tr></table></figure><p>Entry对象里面封装了key和value。</p><p>Map是key和value的映射，在Map里面key和value并不是单独存放的，在底层会生成一个entry对象，entry对象里面封装了value和key，所以获得了entry对象就可以同时获得key和value。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java三大特性</title>
      <link href="/2015/03/02/java-base/"/>
      <url>/2015/03/02/java-base/</url>
      <content type="html"><![CDATA[<p>java最大的特点就是面向对象、可跨平台。Java的三大特性分别是继承（Inheritance）、封装（encapsulation ）、多态。（polymorphism ）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>继承就是子类继承父类的属性和方法。就是生活中的儿子继承了父亲，是现实生活中的例子在java语言中的一个抽象。java是单继承的，表示一个类智能从另一个类继承，（被继承的类叫做父类（基类base class），继承的类叫做子类），java中的继承使用extends关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">public Parent() &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当生成子类对象时，Java默认首先调用父类的不带参数的构造方法，然后执行该构造方法，生成父类的对象。接下来，再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象。比如说：没有父亲，就没有孩子】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">super(1);</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">//public Parent() &#123;</span><br><span class="line">//System.out.println(&quot;parent&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">public Parent(int i) &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super关键字表示对父类对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果子类使用super（）显式调用父类的某个构造方法，那么在执行的时候就会寻找与super（）所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Apple apple = new Apple();</span><br><span class="line"></span><br><span class="line">System.out.println(apple.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">//String name = &quot;fruit&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">String name = &quot;apple&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于继承的3点：</p><ul><li>父类有的，子类也有</li><li>父类没有的，子类可以增加</li><li>父类有的，子类可以改变</li></ul><p>关于继承的注意事项</p><ul><li>构造方法不能被继承<ul><li>方法和属性可以被继承</li><li>子类的构造方法隐式地调用父类的不带参数的构造方法</li><li>当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用</li><li>super关键字必须是构造方法中的第一行语句。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is running&quot;);</span><br><span class="line">super.run(); //调用父类的run方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重写（override）：又叫做覆写，子类与父类的方法返回类型一样、方法名称一样、参数一样，这样我们说子类与父类的方法构成了重写方法。</p><p>当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run()不必放在第一行语句，因此此时父类对象已经构造完毕，先调用父类的run()方法还是先调用子类的run()方法是根据程序的逻辑决定的。</p><p>在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是Java中所有类的直接或间接父类）。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><hr><p>多态（Polymorphism）：我们说子类就是父类（菊花是花，女人是人），因此多态的意思是：父类型的引用可以指向子类的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Flower rose = new Rose(); //多态</span><br><span class="line">rose.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Flower</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;flower is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rose extends Flower</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>方法重载不是面向对象的特征，如果不是晚绑定，就不是多态，而方法重载不是晚绑定而是早绑定。（参考Thinking in java）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Parent parent = new Parent();</span><br><span class="line">//parent.sing();</span><br><span class="line"></span><br><span class="line">//Child child = new Child();</span><br><span class="line">//child.sing();</span><br><span class="line"></span><br><span class="line">Parent p = new Child();</span><br><span class="line">p.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;parent is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;child is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parent p = new Child();当使用多态方式调用方法时，首先检查父类中是否有sing()方法，如果没有则编译错误；如果有，再去调用子类的sing()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest2</span><br><span class="line">&#123;</span><br><span class="line">public static  void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal2 = animal;</span><br><span class="line">animal2.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal = animal2;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">Animal animal = cat;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Animal();</span><br><span class="line">Cat cat = (Cat)animal;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//向上类型转换</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line"></span><br><span class="line">Animal animal = cat;</span><br><span class="line"></span><br><span class="line">animal.sing();</span><br><span class="line"></span><br><span class="line">//向下类型转换</span><br><span class="line">Animal a = new Cat();</span><br><span class="line"></span><br><span class="line">Cat c = (Cat)a;</span><br><span class="line"></span><br><span class="line">c.sing();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;cat is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种类型的强制类型转换：</p><ol><li>向上类型转换（upcast）：比如说将Cat类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显式指定。<ol><li>向下类型转换（downcast）：比如将Animal类型转换为Cat类型。即将父类型转换为子类型。对于向下类型转换，必须要显式指定（必须要使用强制类型转换）。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.run();</span><br><span class="line"></span><br><span class="line">//Pear p = (Pear)f;</span><br><span class="line">//p.run();</span><br><span class="line">//是不可以的，父类中没有grow（），强制类型转换后可以</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.grow();</span><br><span class="line"></span><br><span class="line">Fruit f = new Pear();</span><br><span class="line"></span><br><span class="line">Pear p = (Pear)f;</span><br><span class="line"></span><br><span class="line">p.grow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;fruit is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pear extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void grow()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is growing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想使用子类特有的方法，而此方法没有在父类中出现的时候可以使用强制类型转换（向下类型转换）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest4</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A a = null;</span><br><span class="line"></span><br><span class="line">if(args[0].equals(&quot;1&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new B();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;2&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new C();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;3&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;D&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>晚绑定，编译的时候不知道，等到执行的时候才能确定下来具体的子类。</p><p>Connecting a function call to a function body is called binding.（将函数体和函数调用关联起来，就叫绑定）</p><p>早绑定（Early binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When binding is performed before the program is run (by the compiler and linker), it&apos; s called early binding</span><br><span class="line">在程序运行之前（也就是编译和链接时），执行的绑定是早绑定。</span><br></pre></td></tr></table></figure><p>晚绑定（late binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">late binding, which means the binding occurs at runtime, based on the type of the object. When a language implements late binding, there must be some mechanism to determine the  type of the object at runtime and call the appropriate member function.</span><br></pre></td></tr></table></figure><p>早绑定的优点是:</p><ul><li>编译效率</li><li>代码提示(代码智能感知)</li><li>编译时类型检查</li></ul><p>晚绑定的优点是:</p><ul><li>不用申明类型</li><li>对象类型可以随时更改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest5</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void run(BMW bmw)</span><br><span class="line">&#123;</span><br><span class="line">bmw.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(QQ qq)</span><br><span class="line">&#123;</span><br><span class="line">qq.run();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public void run(Car car)</span><br><span class="line">&#123;</span><br><span class="line">car.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">BMW bmw = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(bmw);</span><br><span class="line"></span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">Car car = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(car);</span><br><span class="line">//向上类型转换</span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;car is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BMW extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;BMW is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class QQ extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;QQ is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态屏蔽掉了子类给我们带来的差异性</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><hr><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问，其实前面用到了封装。</p><p>访问权限符：<br><img src="http://img.blog.csdn.net/20171108110832150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>封装的优点：</p><ol><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ol><p>修改属性的可见性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个值属性提供对外的公共方法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class EncapTest&#123;</span><br><span class="line"> </span><br><span class="line">   private String name;</span><br><span class="line">   private String idNum;</span><br><span class="line">   private int age;</span><br><span class="line"> </span><br><span class="line">   public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getIdNum()&#123;</span><br><span class="line">      return idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setAge( int newAge)&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String newName)&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setIdNum( String newId)&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用封装解决非法赋值问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">import other.Other;</span><br><span class="line"></span><br><span class="line">class Test2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(200);</span><br><span class="line">student.setId(1001);</span><br><span class="line">student.setName(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">student.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">private int id;</span><br><span class="line">private int age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Student(int id, int age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.id = id;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">if(age&lt;0||age&gt;150) &#123;</span><br><span class="line">this.age=0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;Student:id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:id=1001,name=张三,age=0</span><br></pre></td></tr></table></figure><p>近期系统的学习了java，做了一些知识的总结和思考，以博客的形式展示了出来，希望大家指点。我的第一篇博客完成，希望自己今后能够坚持下来，认真的反思与思考，总结博客，对各方面的知识能够更深入的研究学习。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
