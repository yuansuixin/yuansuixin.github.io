<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>jupyter-notebook快捷方式</title>
      <link href="/2018/04/02/jupyter/"/>
      <url>/2018/04/02/jupyter/</url>
      <content type="html"><![CDATA[<hr><p>title: jupyter 快捷键<br>date: 2017-11-20 12:32:50<br>categories:</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><blockquote><p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。<br>Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。–百度百科</p></blockquote><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>Jupyter笔记本有两种不同的键盘输入模式，<strong>编辑模式</strong> 允许将代码或文本输入到单元格，并以绿色单元格边框表示。<strong>命令行模式</strong> 允许输入各种命令，并有具有蓝色左边框的灰色单元格边框表示。</p><p>从命令行模式进入编辑模式按<code>Enter</code>键，从编辑模式切换到命令行模式按<code>Esc</code>键。</p><p>下表将对快捷键做简单的说明：</p><h2 id="命令行模式快捷键（按Esc键开启）"><a href="#命令行模式快捷键（按Esc键开启）" class="headerlink" title="命令行模式快捷键（按Esc键开启）"></a>命令行模式快捷键（按Esc键开启）</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>F</td><td>寻找和替换</td><td></td></tr><tr><td>Ctrl-Shift-F</td><td>打开命令调色板</td><td></td></tr><tr><td>Ctrl-Shift-P</td><td>打开命令调色板</td><td></td></tr><tr><td>Enter</td><td>转入编辑模式</td><td></td></tr><tr><td>P</td><td>打开命令调色板</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下个单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在其下插入新单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Y</td><td>单元转入代码状态</td><td></td></tr><tr><td>M</td><td>单元转入 markdown 状态</td><td></td></tr><tr><td>R</td><td>单元转入 raw 状态</td><td></td></tr><tr><td>1</td><td>设定 1 级标题</td><td>仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态</td></tr><tr><td>2</td><td>设定 2 级标题</td><td></td></tr><tr><td>3</td><td>设定 3 级标题</td><td></td></tr><tr><td>4</td><td>设定 4 级标题</td><td></td></tr><tr><td>5</td><td>设定 5 级标题</td><td></td></tr><tr><td>6</td><td>设定 6 级标题</td><td></td></tr><tr><td>K</td><td>选中上方单元</td><td></td></tr><tr><td>Up</td><td>选中上方单元</td><td></td></tr><tr><td>Down</td><td>选中下方单元</td><td></td></tr><tr><td>J</td><td>选中下方单元</td><td></td></tr><tr><td>Shift-Down</td><td>扩展下面的选定单元格</td><td></td></tr><tr><td>Shift-J</td><td>扩展下面的选定单元格</td><td></td></tr><tr><td>Shift-K</td><td>连续选择上方单元</td><td></td></tr><tr><td>Shift-J</td><td>连续选择下方单元</td><td></td></tr><tr><td>A</td><td>在上方插入新单元</td><td></td></tr><tr><td>B</td><td>在下方插入新单元</td><td></td></tr><tr><td>X</td><td>剪切选中的单元</td><td></td></tr><tr><td>C</td><td>复制选中的单元</td><td></td></tr><tr><td>Shift-V</td><td>粘贴到上方单元</td><td></td></tr><tr><td>V</td><td>粘贴到下方单元</td><td></td></tr><tr><td>Z</td><td>恢复删除的最后一个单元</td><td></td></tr><tr><td>D,D</td><td>删除选中的单元</td><td>连续按两个 D 键</td></tr><tr><td>Shift-M</td><td>合并选中的单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>L</td><td>开关行号</td><td>编辑框的行号是可以开启和关闭的</td></tr><tr><td>O</td><td>转换输出</td><td></td></tr><tr><td>Shift-O</td><td>转换输出滚动</td><td></td></tr><tr><td>H</td><td>显示快捷键帮助</td><td></td></tr><tr><td>I,I</td><td>中断 NoteBook 内核</td><td></td></tr><tr><td>0,0</td><td>重启 NoteBook 内核</td><td></td></tr><tr><td>Esc</td><td>关闭页面</td><td></td></tr><tr><td>Q</td><td>关闭页面</td><td></td></tr><tr><td>Shift-L</td><td>切换所有单元格中的行号，并坚持设置</td><td></td></tr><tr><td>Shift-Space</td><td>向上滚动</td><td></td></tr><tr><td>Space</td><td>向下滚动</td></tr></tbody></table><h2 id="编辑模式快捷键（按Enter键启动）"><a href="#编辑模式快捷键（按Enter键启动）" class="headerlink" title="编辑模式快捷键（按Enter键启动）"></a>编辑模式快捷键（按Enter键启动）</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>快捷键</td><td>作用</td><td>说明</td></tr><tr><td>Tab</td><td>代码补全或缩进</td><td></td></tr><tr><td>Shift-Tab</td><td>提示</td><td>输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助</td></tr><tr><td>Ctrl-]</td><td>缩进向右缩进</td><td></td></tr><tr><td>Ctrl-[</td><td>解除缩进</td><td>向左缩进</td></tr><tr><td>Ctrl-A</td><td>全选</td><td></td></tr><tr><td>Ctrl-Z</td><td>撤销</td><td></td></tr><tr><td>Ctrl-D</td><td>删除整行</td><td></td></tr><tr><td>Ctrl-U</td><td>撤消选择</td><td></td></tr><tr><td>Insert</td><td>切换覆盖标志</td><td></td></tr><tr><td>Ctrl-Home</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-Up</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-End</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Down</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Left</td><td>跳到左边一个字首</td><td></td></tr><tr><td>Ctrl-Right</td><td>跳到右边一个字首</td><td></td></tr><tr><td>Ctrl-Backspace</td><td>删除前面一个字</td><td></td></tr><tr><td>Ctrl-Delete</td><td>删除后面一个字</td><td></td></tr><tr><td>Ctrl-Y</td><td>重做</td><td></td></tr><tr><td>Ctrl-Shift-Z</td><td>重做</td><td></td></tr><tr><td>Esc</td><td>切换到命令模式</td><td></td></tr><tr><td>Ctrl-M</td><td>切换到命令模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下一单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在下面插入一单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Ctrl-Shift–</td><td>分割单元</td><td>按光标所在行进行分割</td></tr><tr><td>Ctrl-Shift-Subtract</td><td>分割单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Up</td><td>光标上移或转入上一单元</td><td></td></tr><tr><td>Down</td><td>光标下移或转入下一单元</td><td></td></tr><tr><td>Ctrl-/</td><td>注释整行/撤销注释</td><td>仅代码状态有效</td></tr></tbody></table><h5 id="【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等"><a href="#【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等" class="headerlink" title="【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等"></a><strong>【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等</strong></h5>]]></content>
      
      
    </entry>
    
    <entry>
      <title>github可以添加表情啦~</title>
      <link href="/2018/03/22/github/"/>
      <url>/2018/03/22/github/</url>
      <content type="html"><![CDATA[<h3 id="提升github的逼格"><a href="#提升github的逼格" class="headerlink" title="提升github的逼格"></a>提升github的逼格</h3><h5 id="github上可以添加表情啦，"><a href="#github上可以添加表情啦，" class="headerlink" title="github上可以添加表情啦，"></a>github上可以添加表情啦，</h5><ul><li><p>在github上插入表情的使用方法：</p><ul><li>使用方法为前后冒号包围表情代号的句法。<figure class="highlight plain"><figcaption><span>会显示成对应的表情，所以你在提交代码的时候可以这样写提交信息：`</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git commit –m ‘commit some changes :blush:’</span><br><span class="line">\</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表情列表</p></li></ul><p><a href="https://github.com/yuansuixin/emoji-list" target="_blank" rel="noopener">表情大全</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>会话技术cookie和session的区别和联系</title>
      <link href="/2018/02/12/cookie-session/"/>
      <url>/2018/02/12/cookie-session/</url>
      <content type="html"><![CDATA[<h1 id="COOKIE-和-SESSION-有什么区别和联系"><a href="#COOKIE-和-SESSION-有什么区别和联系" class="headerlink" title="COOKIE 和 SESSION 有什么区别和联系"></a>COOKIE 和 SESSION 有什么区别和联系</h1><ul><li><p>存储位置</p><ul><li>cookie 保存在客户端中</li><li>session 保存在服务器端</li></ul></li><li><p>Session 是服务器保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</p></li><li>Cookie 是客户端保存用户信息的一个机制，用来记录用户的一些信息，也是实现Session的一个方式，存储在用户的浏览器中</li></ul><h2 id="不要混淆-cookie-和-session-实现"><a href="#不要混淆-cookie-和-session-实现" class="headerlink" title="不要混淆 cookie 和 session 实现"></a>不要混淆 cookie 和 session 实现</h2><ul><li>本身 session 是一个抽象的概念，将user agent 和server 之前一对一的交互，抽象为’会话‘，进而衍生出’会话状态‘，也就是session的概念</li><li>而 cookie 是一个实际存在的东西，http 协议中定义在header中的字段，可以认为是 session 的后端无状态实现</li><li>现在的 session ，是为了绕开 cookie 的各种限制，通常借助与cookie本身和后端存储实现的，一种更高级的状态实现</li></ul><ul><li>session、cookie、token会话技术</li></ul><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201833011500.png" alt="会话"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jupyter（IPython）相关知识点</title>
      <link href="/2018/02/03/ipython/"/>
      <url>/2018/02/03/ipython/</url>
      <content type="html"><![CDATA[<h2 id="一、启动程序"><a href="#一、启动程序" class="headerlink" title="一、启动程序"></a>一、启动程序</h2><p>执行以下命令：</p><blockquote><p>jupyter notebook</p></blockquote><p>[NotebookApp] Serving notebooks from local directory: /home/nanfengpo</p><p>[NotebookApp] 0 active kernels </p><p>[NotebookApp] The IPython Notebook is running at: <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p><p>[NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</p><p>注意以下几点：</p><ul><li>打开地址为当前bash的目录，默认的根目录</li><li>浏览器地址为<a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></li><li>通过control -C终止jupyter程序</li></ul><p>几个基本操作：</p><ul><li>双击D：删除当前cell</li><li>单击M：转为markdown文档</li><li>markdown文档下运行变为预览模式</li></ul><h2 id="二、IPython的帮助文档"><a href="#二、IPython的帮助文档" class="headerlink" title="二、IPython的帮助文档"></a>二、IPython的帮助文档</h2><h4 id="1-使用help（）"><a href="#1-使用help（）" class="headerlink" title="1.使用help（）"></a>1.使用help（）</h4><p>通过以下命令来获得帮助文档：</p><blockquote><p>help(len)</p></blockquote><p>Help on built-in function len in module builtins:</p><p>len(obj, /)<br>    Return the number of items in a container.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(len)</span><br></pre></td></tr></table></figure></p><h4 id="2-使用？"><a href="#2-使用？" class="headerlink" title="2.使用？"></a>2.使用？</h4><blockquote><p>len？</p></blockquote><p>还可以应用到自定义的变量和自定义的函数上来返回帮助文档</p><p>此外，使用两个??可以把函数的源代码显示出来</p><h4 id="3-tab自动补全"><a href="#3-tab自动补全" class="headerlink" title="3.tab自动补全"></a>3.tab自动补全</h4><h2 id="三、IPython魔法命令"><a href="#三、IPython魔法命令" class="headerlink" title="三、IPython魔法命令"></a>三、IPython魔法命令</h2><h4 id="1-运行外部的Python文件"><a href="#1-运行外部的Python文件" class="headerlink" title="1. 运行外部的Python文件"></a>1. 运行外部的Python文件</h4><p>使用下面命令运行外部python文件（默认是当前目录，最好加上绝对路径）</p><blockquote><p>%run *.py</p></blockquote><p>例如在当前目录下有一个myscript.py文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    &quot;&quot;&quot;square a number&quot;&quot;&quot;</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line">for N in range(1, 4):</span><br><span class="line">    print(N, &quot;squared is&quot;, square(N))</span><br></pre></td></tr></table></figure></p><p>我们可以通过下面命令执行它：</p><blockquote><p>%run myscript.py</p></blockquote><p>尤其要注意的是，当我们使用魔法命令执行了一个外部文件时，该文件的函数就能在当前会话中使用</p><blockquote><p>square(5)</p></blockquote><h4 id="2-运行计时"><a href="#2-运行计时" class="headerlink" title="2.运行计时"></a>2.运行计时</h4><p>用下面命令计算statement的运行时间：</p><blockquote><p>%time statement</p></blockquote><p>用下面命令计算statement的平均运行时间：   </p><blockquote><p>%timeit statement</p></blockquote><p>timeit会多次运行statement，最后得到一个更为精准的预期运行时间</p><p>可以使用两个百分号来测试多行代码的平均运行时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">statement1</span><br><span class="line">statement2</span><br><span class="line">statement3</span><br></pre></td></tr></table></figure></p><p>记住：</p><ul><li>%time一般用于耗时长的代码段</li><li>%timeit一般用于耗时短的代码段</li></ul><h4 id="3-查看当前会话中的所有变量和函数"><a href="#3-查看当前会话中的所有变量和函数" class="headerlink" title="3. 查看当前会话中的所有变量和函数"></a>3. 查看当前会话中的所有变量和函数</h4><p>快速查看当前会话的所有变量与函数名称：</p><blockquote><p>%who</p></blockquote><p>查看当前会话的所有变量与函数名称的详细信息：</p><blockquote><p>%whos</p></blockquote><p>返回一个字符串列表，里面元素是当前会话的所有变量与函数名称：</p><blockquote><p>%who_ls</p></blockquote><h4 id="4-执行Linux指令"><a href="#4-执行Linux指令" class="headerlink" title="4.执行Linux指令"></a>4.执行Linux指令</h4><p>在Linux指令之前加上  <font size="5" color="green">!</font>，即可在ipython当中执行Linux指令。<br>注意，会将标准输出以字符串形式返回</p><h4 id="5-更多的魔法命令"><a href="#5-更多的魔法命令" class="headerlink" title="5. 更多的魔法命令"></a>5. 更多的魔法命令</h4><p>列出所有魔法命令</p><blockquote><p>lsmagic</p></blockquote><h2 id="四、IPython输入输出历史"><a href="#四、IPython输入输出历史" class="headerlink" title="四、IPython输入输出历史"></a>四、IPython输入输出历史</h2><h4 id="1-使用in、out调用输入输出历史"><a href="#1-使用in、out调用输入输出历史" class="headerlink" title="1. 使用in、out调用输入输出历史"></a>1. 使用in、out调用输入输出历史</h4><p>In返回一个字符串列表，里面是所有输入命令的字符串<br>Out返回一个含有输出的命令的序号及其输出组成的字典<br>两者皆可以通过索引获取元素</p><h4 id="2-使用下划线表示输出"><a href="#2-使用下划线表示输出" class="headerlink" title="2. 使用下划线表示输出"></a>2. 使用下划线表示输出</h4><p>“_”表示上一个输出<br>“_2”表示Out[2]</p><h2 id="五、jupyter-notebook的快捷键"><a href="#五、jupyter-notebook的快捷键" class="headerlink" title="五、jupyter-notebook的快捷键"></a>五、jupyter-notebook的快捷键</h2><p><a href="https://yuansuixin.github.io/archives/2018/04/" title="快捷键">jupyter-notebook快捷键</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>hello~</title>
      <link href="/2018/01/02/hello/"/>
      <url>/2018/01/02/hello/</url>
      <content type="html"><![CDATA[<blockquote><p>因为很多原因，一直没能进行博客的更新，今天终于又和大家见面了。</p></blockquote><ul><li>nice to meet you !</li><li>欢迎来到我的博客，希望和大家一同进步，一同分享知识。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的注解（Annotation)详细解析</title>
      <link href="/2017/12/15/annotation/"/>
      <url>/2017/12/15/annotation/</url>
      <content type="html"><![CDATA[<h6 id="Annotation工作方式："><a href="#Annotation工作方式：" class="headerlink" title="Annotation工作方式："></a>Annotation工作方式：</h6><p>从java5.0以来，提供了一个真实的annotation功能：允许开发者定义、使用自己的额annotation类型，此功能由一个定义annotation类型的语法和一个描述annotation声明的语法，读取annotation的API，一个使用annotation修饰的Class文件，一个annotation处理工具apt组成。</p><p>annotation<strong>并不会直接影响代码语义</strong>，但是它能够工作的方式被看做类似程序的工具或者类库，他会反过来对正在运行的程序语义有所影响。annotation可以从源文件，class文件或者以在运行时反射的多种方式被读取。</p><p>注解可以用在方法，类，变量等上面，注解的使用范围很广。</p><p><strong>Override注解表示子类要重写（override）父类方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OverrideTest &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;This is OverrideTest&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">OverrideTest overrideTest = new OverrideTest();</span><br><span class="line">System.out.println(overrideTest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is OverrideTest</span><br></pre></td></tr></table></figure><p><strong>Deprecate注解表示方法是不建议被使用的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DeprecatedTest &#123;</span><br><span class="line">@Deprecated</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">System.out.println(&quot;do something &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">DeprecatedTest deprecatedTest= new DeprecatedTest();</span><br><span class="line">//不建议被使用的</span><br><span class="line">deprecatedTest.doSomething();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Date d= new Date();</span><br><span class="line">//System.out.println(d.toLocaleString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SuppressWarnings注解表示抑制警告。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningsTest &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)//不检查</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map=new TreeMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;hello&quot;, new Date());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningsTest &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;,&quot;deprecation&quot;&#125;)//不检查，不推荐使用的</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map=new TreeMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;hello&quot;, new Date());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(date.toLocaleString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解跟着值的时候可以使用大括号，也可以省略。@SuppressWarnings({“unchecked”,”deprecation”})</strong></p><p>以上就是注解的使用方式，我们也可以自己定义注解，下面来介绍一下自定义注解。</p><p>当注解中的属性名为value时，在对其赋值时可以不指定属性的名称而直接写上属性值即可，除了value以外的其他值都需要使用name=value这种赋值方式，即明确指定给谁赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public @interface AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">//定义属性</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@AnnotationTest(value=&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">public class AnnoationUsage &#123;</span><br><span class="line"></span><br><span class="line">@AnnotationTest(value=&quot;world&quot;)</span><br><span class="line">public void method() &#123;</span><br><span class="line">System.out.println(&quot;usage of annoation&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AnnoationUsage annoationUsage = new AnnoationUsage();</span><br><span class="line">annoationUsage.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的值可以默认的具体赋值，使用@interface自行定义Annotation形态时，实际上是自动继承了java.lang.annotation.Annotation接口由编译程序自动为您完成其他产生的细节，<strong>在定义Annotation形态时，不能继承其他的Annotation形态或是接口。</strong></p><p>当我们使用@interface关键字定义一个注解时，该注解隐含地继承了java.lang.annotation.Annotation接口；如果我们定义了一个接口，并且让该接口继承自Annotation，那么我们所定义的接口依然还是接口而不是注解；Annotation本身是接口而不是注解。可以与Enum类比。</p><p>定义annotation类型时也可以使用包来管理类别，方式同于类的导入功能</p><h6 id="告知编译器如何处理-Retention"><a href="#告知编译器如何处理-Retention" class="headerlink" title="告知编译器如何处理@Retention"></a>告知编译器如何处理@Retention</h6><p>使用java.lang.annotation.Retention，在定义时要指定java.lang.annotation.RetentionPolicy的枚举值之一</p><p>java.lang.annotation.Retention形态可以在你定义Annotation时，指示编译程序该如何对待您的自定义的Annotation。预设上编译程序会将Annotation信息留在.class档案中，但不被虚拟机读取，而仅用于编译程序或工具程序运行时提供信息。</p><p>Retention和RetentionPolicy总是成对出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line"></span><br><span class="line">SOURCE,//编译程序处理完annotation信息后就完成任务</span><br><span class="line">CLASS,//编译程序将annotation储存于Class档中，默认就是这个</span><br><span class="line">RUNTIME//编译程序将annotation储存于Class文档中，可以由VM读入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为SOURSE的例子是<br>@SuppressWarnings仅在编译时期告知编译程序来抑制警告，所以不必将这个信息储存于class文档<br>为RUNTIME的时机，可以像是你使用java设计一个程序代码分析工具，你必须让vm能读出Annotation信息，以便在分析程序时使用，<strong>搭配反射机制就可以达到这个目的</strong></p><p>定义annotation时必须设定RetentionPolicy为RUNTIME，也就是可以在vm中读取Annotation信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">//自定义一个注解</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String hello() default &quot;zhangsan&quot;;</span><br><span class="line">String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation(hello=&quot;beijing&quot;,world=&quot;shanghai&quot;)</span><br><span class="line">public class MyTest &#123;</span><br><span class="line"></span><br><span class="line">//一个方法可以由多个注解修饰</span><br><span class="line">@MyAnnotation(hello=&quot;tianjin&quot;,world=&quot;shangdi&quot;)</span><br><span class="line">@Deprecated</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void output() &#123;</span><br><span class="line">System.out.println(&quot;output method&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyReflaction &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)throws Exception &#123;</span><br><span class="line"></span><br><span class="line">MyTest myTest = new MyTest();</span><br><span class="line"></span><br><span class="line">Class&lt;MyTest&gt; class1= MyTest.class;</span><br><span class="line"></span><br><span class="line">Method method =class1.getMethod(&quot;output&quot;, new Class[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//判断是否存在这样也一个Annotation</span><br><span class="line">if(method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">method.invoke(myTest, new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//得到一个Annotation，返回这个Annotation的一个实例</span><br><span class="line">MyAnnotation myAnnotation =method.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">//获得这个Annotation的属性值</span><br><span class="line">String hello=myAnnotation.hello();</span><br><span class="line">String world=myAnnotation.world();</span><br><span class="line"></span><br><span class="line">System.out.println(hello+&quot; ,&quot;+world);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果完全是由RetentionPolicy决定的，只有RUNTIME的可以读取到</span><br><span class="line">Annotation[] annotations=method.getAnnotations();</span><br><span class="line"></span><br><span class="line">//必须RetentionPolicy为RUNTIME才可以读取到</span><br><span class="line">for(Annotation annotation: annotations) &#123;</span><br><span class="line">System.out.println(annotation.annotationType().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output method</span><br><span class="line">tianjin ,shangdi</span><br><span class="line">MyAnnotation</span><br><span class="line">java.lang.Deprecated</span><br></pre></td></tr></table></figure><p>这个例子主要练习了几个和反射、注解有关的方法。只要理解了反射机制就很容易理解了，我再注释中都已经详细的介绍了，这里就不过多的描述了。</p><h6 id="限定annotation使用对象-Target"><a href="#限定annotation使用对象-Target" class="headerlink" title="限定annotation使用对象@Target"></a>限定annotation使用对象@Target</h6><p>使用java.lang.annotation.Target可以定义其使用之时机，在定义时要指定java.lang.annotation.ElementType的枚举值之一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line"></span><br><span class="line">TYPE,//适用Class,interface ,enum</span><br><span class="line">FIELD,//适用文件</span><br><span class="line">METHOD,//适用于方法</span><br><span class="line">PARAMETER,//适用method上之parameter</span><br><span class="line">CONSTRUCTOR,//适用constructor</span><br><span class="line">LOCAL_VARIABLE,//适用局部变量</span><br><span class="line">ANNOTATION_TYPE,//适用annotation形态</span><br><span class="line">PACKAGE//适用package</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="要求为API文件-Documented"><a href="#要求为API文件-Documented" class="headerlink" title="要求为API文件@Documented"></a>要求为API文件@Documented</h6><p>想要在使用者制作javaDoc文件的同时，也一并将Annotation的信息加入至API文档中使用。</p><h6 id="子类是否继承父类-Inherited"><a href="#子类是否继承父类-Inherited" class="headerlink" title="子类是否继承父类@Inherited"></a>子类是否继承父类@Inherited</h6><p>预设上父类中的annotation并不会被继承至子类中，可以在定义Annotation形态时加上java.lang.annotation.Inherited形态的Annotation。</p><p>注解在实际中的应用，注解主要应用在单元测试中，我来简单的说一下。</p><p>Junit有两个经典的版本，Junit3和Junit4。</p><p>Junit3继承TestCase,方法必须以test开头。keep the bar green to keep the code clean.这些底层都是通过反射机制实现的。</p><p>Junit3是基于反射的，Junit4是基于反射和注解的</p><p>JUnit4的执行的一般流程：</p><ol><li>首先获得待测试类所对应的Class对象。</li><li>然后通过该Class对象获得当前类中所有public方法所对应的Method数组。</li><li>遍历该Method数组，取得每一个Method对象</li><li>调用每个Method对象的isAnnotationPresent(Test.class)方法，判断该方法是否被Test注解所修饰。</li><li>如果该方法返回true，那么调用method.invoke()方法去执行该方法，否则不执行。</li></ol><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式---代理模式（Proxy）（动态代理）</title>
      <link href="/2017/11/05/proxy2/"/>
      <url>/2017/11/05/proxy2/</url>
      <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p> Java动态代理类位于java.lang.reflect包下，一般主要 涉及到以下两个类： </p><p> (1)<strong>Interface InvocationHandler接口</strong>：该接口中仅定义了 一个方法 </p><ul><li><p>public object invoke(Object obj,Method method, Object[] args) </p></li><li><p>在实际使用时，第一个参数obj一般是指代理类，代理实例的方法被调用 第二个参数method是被代理的方法，如上例中的request()，第三个参数args 为该方法的参数数组。 这个抽象方法在代理类中动态实现。</p></li></ul><p>这个接口是由一个代理实例的调用处理器来实现的。</p><p>每一个代理实例都会有一个与之关联的调用处理器。当我们调用一个代理实例的某一个方法的时候，这个方法调用就会被编码并且被派发到与之关联的他的调用处理器的invoke方法上，被调用。</p><p>invoke方法会处理代理实例上的一个方法调用，并且将真正的调用结果返回回来。当一个调用处理器关联到这个处理器的某个代理实例，我们调用这个代理实例上的某个方法的时候，这个方法就会转移到与这个实例所关联的那个调用处理器的invoke方法，由它帮我们完成调用。</p><p>(2)<strong>Proxy</strong>：该类即为动态代理类，作用类似于上例中的</p><p>Proxy提供了一些静态方法用于创建动态代理类和实例，他也是由这些方法所创建的动态代理类的一个父类。</p><p>ProxySubject，其中主要包含以下内容</p><ul><li><p>protected Proxy(InvocationHandler h)：构造函数， 用于给内部的h赋值。</p></li><li><p>static Class getProxyClass (ClassLoader loader, Class[] interfaces)：获得一个代理类，其中loader是 类装载器，interfaces是真实类所拥有的全部接口的数组 。</p></li><li><p>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)： <strong>返回代理类的一个实例</strong>，返回后的代理类可以当作被代理 类使用(可使用被代理类的在Subject接口中声明过的方法 )</p></li><li><p>所谓Dynamic Proxy是这样一种class： 它是在<strong>运行时生成</strong>的class，<strong>在生成它时你 必须提供一组interface给它，然后该class 就宣称它实现了这些 interface</strong>。你当然可 以把该class的实例当作这些interface中的 任何一个来用(多态)。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作 实质性的工作，在生成它的实例时你必须 提供一个handler，由它接管实际的工作</p></li><li><p>在使用动态代理类时，我们必须实现 InvocationHandler接口 </p></li></ul><h6 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">System.out.println(&quot;from real subject&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该代理类的内部属性是Object类型，实际使用的时候通过该类的构造方法传递进来一个对象</span><br><span class="line"> * 此外，该类还实现了invoke方法，该方法中的method.invoke其实就是调用被代理对象的将要</span><br><span class="line"> * 执行的方法，方法参数是sub，表示该方法从属于sub，通过动态代理类，我们可以在执行真实对象的方法前后</span><br><span class="line"> * 加入自己的一些额外方法。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DynamicSubject implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">//真实对象的引用，因为是动态代理，他可以代理任意一个对象，所以就要定义为Object类型。如果是RealSubject就很受限制了。</span><br><span class="line">private Object sub;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public  DynamicSubject(Object object) &#123;</span><br><span class="line">   this.sub=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;before calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">//使用的是反射，进行的调用</span><br><span class="line">method.invoke(sub, args);</span><br><span class="line"></span><br><span class="line">System.out.println(args==null);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">//这个例子没有返回值，直接返回空就可以</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">RealSubject realSubject = new RealSubject();</span><br><span class="line"></span><br><span class="line">//多态</span><br><span class="line">//代理谁就传谁</span><br><span class="line">InvocationHandler handler = new DynamicSubject(realSubject);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=handler.getClass();</span><br><span class="line"></span><br><span class="line">     //下面的代码一次性生成代理</span><br><span class="line">//第一个参数为类装载器，通过Class类可以获得，我们现在要动态的生成类了，这个类是由哪个类装载器装载的呢</span><br><span class="line">//代理类返回的是一个Object类型的，需要转换类型</span><br><span class="line">//运行的时候生成一个class，然后生成class类的一个对象</span><br><span class="line">Subject subject=(Subject)Proxy.newProxyInstance(classType.getClassLoader(),</span><br><span class="line">realSubject.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">subject.request();</span><br><span class="line"></span><br><span class="line">System.out.println(subject.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before calling:public abstract void com.suixin.pattern.dynamicsubject.Subject.request()</span><br><span class="line">from real subject</span><br><span class="line">null</span><br><span class="line">after calling:public abstract void com.suixin.pattern.dynamicsubject.Subject.request()</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br></pre></td></tr></table></figure><p><strong>只要使用动态代理类，有一个动态代理类就会有一个InvocationHandler，他们总是相互关联的。</strong>代理类并不会真正的完成方法的调用，而都是由与之关联的InvocationHandler的invoke方法真正完成目标方法的调用。</p><p>下面通过这个例子，我来给大家详细的介绍一下执行的流程和注意事项，详细步骤解读：</p><ol><li><p>首先进行实例化，实例化已经知道的我们需要用到的类，也就是说实例化RealSubject和DynamicSubject，这里用到了多态的知识点，这里我给大家补充一下， <strong>多态：所谓多态，就是父类型的引用可以指向子类型的对象，或者接口类型的引用可以指向实现该接口的类的实例。关于接口与实现接口的类之间的强制类型转换方式与父类和子类之间的强制类型转换方式完全一样。</strong></p><pre><code> RealSubject realSubject = new RealSubject();//多态//因为这里是动态代理，代理的对象不能指定为一个，所以代理谁就传谁InvocationHandler handler = new DynamicSubject(realSubject);</code></pre></li><li><p>获得调用处理器的Class对象，这里使用的是getClass（）方法。获得这个Class对象是为了生成代理的时候使用。</p></li></ol><p>3.一次性生成代理实例，这里的生成实例，既不是真实对象的实例也不是代理对象DynamicSubject的实例，而是java在运行的时候生成的一个Class类，然后生成这个Class类的一个对象。</p><pre><code>Subject subject=(Subject)Proxy.newProxyInstance(classType.getClassLoader(),realSubject.getClass().getInterfaces(), handler);</code></pre><p>第一个参数为类加载器，通过Class类可以获得，我们现在要动态的生成类了，这个类是由哪个类装载器装载的呢，因为我们要动态的生成一个代理角色的类，而代理角色类的方法都是由调用处理器来实现的，所以这个类加载器就是调用处理器也就是代理角色的类加载器，classType.getClassLoader()。这个类的实例宣称实现了真实角色实现的所有的接口，也就是realSubject.getClass().getInterfaces()这些接口，所以生成出来的那个对象我们可以将其转换成Subject类型，（不要装换为对应的具体的实现类类型，因为并不知道他对应了那些实现类），装换之后正常的调用方法就可以了。</p><p><strong>生成动态代理类，而与之关联的调用处理器就是DynamicSubject</strong></p><p>4.调用方法的时候，就会转而由InvocationHandler的invoke方法来执行，并且将参数也分别传递过去。就会执行invoke（）方法，执行完之后再回到Client继续执行下面的代码。这就实现了动态代理，over。</p><hr><p>通过这种方式，被代理的对象 (RealSubject)可以在运行时动态改变，需 要控制的接口(Subject接口)可以在运行时 改变，控制的方式(DynamicSubject类) 也可以动态改变，从而实现了非常灵活的 动态代理关系</p><ul><li>动态代理是指客户通过代理类来调用其它 对象的方法</li><li><p>动态代理使用场合:</p><p> 调试 </p><p> 远程方法调用(RMI)</p></li></ul><p><img src="http://img.blog.csdn.net/20171113172042542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>实现动态代理的步骤：</p><ol><li>创建一个实现接口InvocationHandler的 类，它必须实现invoke方法</li><li>创建被代理的类以及接口</li><li>通过Proxy的静态方法 newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个代理 </li><li>通过代理调用方法</li></ol><p>我想大家对于代理模式已经有了一个了解了，但是我们为了更好的掌握它，还是得再巩固一下，我们练习一下带有参数传递的动态代理模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class VectorProxy implements InvocationHandler&#123;</span><br><span class="line">private Object proxyObj;</span><br><span class="line"></span><br><span class="line">public VectorProxy(Object object) &#123;</span><br><span class="line">this.proxyObj=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Object factory(Object object) &#123;</span><br><span class="line">Class&lt;?&gt; classType=object.getClass();</span><br><span class="line"></span><br><span class="line">return Proxy.newProxyInstance(classType.getClassLoader(), </span><br><span class="line">classType.getInterfaces(), new VectorProxy(object));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;before calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">if(null!=args) &#123;</span><br><span class="line">for(Object object:args) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object=method.invoke(proxyObj, args);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after calling :&quot;+method);</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//vList是运行时动态生成的类的实例</span><br><span class="line">List vList=(List) factory(new Vector());</span><br><span class="line"></span><br><span class="line">//我们把这个动态生成的实例的名字打印出来</span><br><span class="line">System.out.println(vList.getClass().getName());</span><br><span class="line"></span><br><span class="line">vList.add(&quot;new&quot;);</span><br><span class="line">vList.add(&quot;York&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(vList);</span><br><span class="line"></span><br><span class="line">vList.remove(0);</span><br><span class="line">System.out.println(vList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">before calling:public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">new</span><br><span class="line">after calling :public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">before calling:public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">York</span><br><span class="line">after calling :public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line"></span><br><span class="line">before calling:public java.lang.String java.lang.Object.toString()</span><br><span class="line">after calling :public java.lang.String java.lang.Object.toString()</span><br><span class="line">[new, York]</span><br><span class="line">before calling:public abstract java.lang.Object java.util.List.remove(int)</span><br><span class="line">0</span><br><span class="line">after calling :public abstract java.lang.Object java.util.List.remove(int)</span><br><span class="line">before calling:public java.lang.String java.lang.Object.toString()</span><br><span class="line">after calling :public java.lang.String java.lang.Object.toString()</span><br><span class="line">[York]</span><br></pre></td></tr></table></figure><p>我们一起来分析一下这个程序，其实原理都是一样的。我把所有的内容写到了一个类里面。</p><ol><li>首先从入口开始说起吧，定义了List，vList是运行时动态生成的类的实例。也就是factory方法的返回值。factory方法有一个参数object代表着传入的要代理的对象。factory返回的值是Object，但是newProxyInstance生成的类是实现了传入的参数所实现的所有的方法，new Vector（）实现了List的接口，那么动态代理也肯定实现了这个接口，可以通过强制类型转换为List类型。</li><li>然后调用add方法，传入一个“new”进去，当你调用生成代理对象的任何一个方法，都会立刻转由invoke方法执行。将参数传给invoke方法，我们遍历参数的数组args就会打印出来。继续执行invoke方法，执行完之后，再回来执行add（“york”）;再重复上面的执行过程。</li><li>我们打印出来vList看看是什么，其实和上面的过程是一样的，打印vList相当于调用了vList.toString();方法，过程和上面调用方法的步骤一致，只是没有传参数而已。<br>4.调用remove方法也是同样的道理，我就不再重复了。</li></ol><p>动态代理是能够用一个动态代理类，代理多个真实对象，那么我们举例来看一下，这里我就不详细的介绍了。</p><p>公共的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Foo &#123;</span><br><span class="line">void doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个真实的角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FoolImp1 implements Foo&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doAction() &#123;</span><br><span class="line">System.out.println(&quot;in FooImpl doAction&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个真实角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class FooImpl2 implements Foo &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doAction() &#123;</span><br><span class="line">System.out.println(&quot;in FooImp2 doAction&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class CommonInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">private Object object;</span><br><span class="line"> public CommonInvocationHandler(Object object) &#123;</span><br><span class="line">this.object=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public CommonInvocationHandler() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> public void setObject(Object object) &#123;</span><br><span class="line">this.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代理角色</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">return method.invoke(object, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.logging.Handler;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">CommonInvocationHandler cHandler=new CommonInvocationHandler();</span><br><span class="line"></span><br><span class="line">Foo foo=null;</span><br><span class="line"></span><br><span class="line">cHandler.setObject(new FoolImp1());</span><br><span class="line"></span><br><span class="line">foo=(Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(), </span><br><span class="line">new Class[] &#123;Foo.class&#125;, cHandler);</span><br><span class="line"></span><br><span class="line">foo.doAction();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;==================================================&quot;);</span><br><span class="line"></span><br><span class="line">cHandler.setObject(new FooImpl2());</span><br><span class="line"></span><br><span class="line">foo=(Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">new Class[] &#123;Foo.class&#125;, cHandler);</span><br><span class="line"></span><br><span class="line">foo.doAction();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in FooImpl doAction</span><br><span class="line">==================================================</span><br><span class="line">in FooImp2 doAction</span><br></pre></td></tr></table></figure><p>这个例子中FoolImp1、FoolImp2是两个真实的角色，用一个代理Proxy代理他们两个，通过在运行时期生成动态代理实例来代理，完成真实角色要实现的方法，其实，方法都是在invoke方法中得到真实调用的，代理实例不会真正的真实角色的方法，最终还是由真实角色里实现的。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式----代理模式（Proxy）（静态代理模式）</title>
      <link href="/2017/10/22/proxy/"/>
      <url>/2017/10/22/proxy/</url>
      <content type="html"><![CDATA[<h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>代理模式分为静态代理和动态代理，有代理对象叫做静态代理，没有代理对象叫做动态代理</p><p>代理模式的作用是：为其他对象提供一个代理以控制对这个对象的访问。<br>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>代理模式一般涉及到的角色：</p><ul><li>抽象角色：声明真实对象和代理对象的<strong>共同接口</strong></li><li>代理对象：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时代理对象可以在执行真实对象操作时，附加其他操作，相当于对真实对象进行封装</li><li>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理模式比较抽象，我们利用代码例子来理解。</p><h6 id="抽象角色"><a href="#抽象角色" class="headerlink" title="抽象角色"></a>抽象角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色</span><br><span class="line">public abstract class Subject &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;form real subject&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ProxySubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">private RealSubject realsubject; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void proRequest() &#123;</span><br><span class="line">System.out.println(&quot;pro request&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">this.proRequest();</span><br><span class="line"></span><br><span class="line">if(realsubject==null) &#123;</span><br><span class="line">realsubject = new RealSubject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">realsubject.request();</span><br><span class="line"></span><br><span class="line">this.postRequest();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void postRequest() &#123;</span><br><span class="line">System.out.println(&quot;post quest&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ProxySubject proxySubject = new ProxySubject();</span><br><span class="line">proxySubject.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pro request</span><br><span class="line">form real subject</span><br><span class="line">post quest</span><br></pre></td></tr></table></figure><ul><li>由以上代码可以看出，客户实际需要调用的是 RealSubject类的request()方法，现在用ProxySubject 来代理 RealSubject类，同样达到目的，同时还封装了 其他方法(preRequest(),postRequest())，可以处理一 些其他问题。 </li><li>另外，<strong>如果要按照上述的方法使用代理模式，那么真实角 色必须是事先已经存在的，并将其作为代理对象的内部属性。</strong>但是实际使用时，一个真实角色必须对应一个代理 角色，如果大量使用会导致类的急剧膨胀；此外，如果事 先并不知道真实角色，该如何使用代理呢？这个问题可以 通过Java的动态代理类来解决</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射机制深入剖析（二）</title>
      <link href="/2017/06/02/reflection2/"/>
      <url>/2017/06/02/reflection2/</url>
      <content type="html"><![CDATA[<p>继续来谈谈反射机制</p><ol><li>要想使用反射，首先需要获得待处理类或对象所对应的Class对象。</li></ol><p><strong>2. 获取某个类或某个对象所对应的Class对象的常用的3种方式：</strong></p><ul><li><strong>使用Class类的静态方法forName，Class.forName(“java.lang.String”);</strong></li><li><strong>使用类的.class语法：String.class;</strong></li><li><strong>使用对象的getClass()方法： String s=”aa”;Class&lt;?&gt; class=s.getClass();</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class ReflactTester &#123;</span><br><span class="line"></span><br><span class="line">//该方法实现对Customer对象的拷贝操作</span><br><span class="line">public Object copy(Object object) throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; classType=object.getClass();</span><br><span class="line"></span><br><span class="line">//System.out.println(classType.getName());</span><br><span class="line"></span><br><span class="line">Constructor constructor = classType.getConstructor(new Class[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">Object object2= constructor.newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以上两行代码等价于下面一行</span><br><span class="line">//Object object2=classType.newInstance();</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//Constructor constructor3 = classType.getConstructor(new Class[] &#123;String.class,int.class&#125;);</span><br><span class="line">//</span><br><span class="line">//Object object3= constructor3.newInstance(new Object[] &#123;&quot;hello&quot;,4&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(object2);</span><br><span class="line">//System.out.println(object3);</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">ReflactTester tester= new ReflactTester();</span><br><span class="line">tester.copy(new Customer());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer&#123;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public Customer() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Customer (String name, int age) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(Long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer@15db9742</span><br></pre></td></tr></table></figure><p>3.若想通过类的不带参数的构造方法来生成对象，我们有两种方式：</p><ul><li><p>先获得 Class 对象，然后通过该 Class 对象的 newInstance()方法直接生成即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = String.class; </span><br><span class="line">Object obj = classType.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先获得 Class 对象，然后通过该对象获得对应的 Constructor 对象，再通过该 Constructor 对象的 newInstance()方法生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = Customer.class; </span><br><span class="line">Constructor cons = classType.getConstructor(new Class[]&#123;&#125;);</span><br><span class="line">Object obj = cons.newInstance(new Object[]&#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>4.若想通过类的带参数的构造方法生成对象，只能使用下面这一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = Customer.class; </span><br><span class="line">Constructor cons = classType.getConstructor(new Class[]&#123;String.class, int.class&#125;); </span><br><span class="line">Object obj = cons.newInstance(new Object[]&#123;“hello”, 3&#125;);</span><br></pre></td></tr></table></figure><hr><p>我们再来看一个例子,ReflectTester类有一个 copy(Object object)方法，这个方法能够创建 一个和参数object 同样类型的对象，然后把 object对象中的所有属性拷贝到新建的对象中， 并将它返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflactTester2 &#123;</span><br><span class="line"></span><br><span class="line">public Object copy(Object object )throws Exception &#123;</span><br><span class="line">    //获得对象的类型</span><br><span class="line">Class&lt;?&gt; classType = object.getClass();</span><br><span class="line">//System.out.println(&quot;Class:&quot;+classType.getName());</span><br><span class="line"></span><br><span class="line">//通过无参数的构造方法构造出来类并且实例化</span><br><span class="line">Object objectCopy=classType.getConstructor(new Class[] &#123;&#125;).newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//获得对象的所有成员变量</span><br><span class="line"></span><br><span class="line">Field[] fields= classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">for(Field field:fields) &#123;</span><br><span class="line">//获得属性的名称</span><br><span class="line">String name=field.getName();</span><br><span class="line"></span><br><span class="line">//变量名称首字母大写</span><br><span class="line">String firstLetter=name.substring(0,1).toUpperCase();</span><br><span class="line"></span><br><span class="line">//获取到get、set方法的名称</span><br><span class="line">String getMethodName=&quot;get&quot;+firstLetter+name.substring(1);</span><br><span class="line">String setMethodName=&quot;set&quot;+firstLetter+name.substring(1);</span><br><span class="line"></span><br><span class="line">//获取到get、set方法</span><br><span class="line">Method getMethod=classType.getMethod(getMethodName, new Class[] &#123;&#125;);</span><br><span class="line">Method setMethod=classType.getMethod(setMethodName, new Class[] &#123;field.getType()&#125;);</span><br><span class="line"></span><br><span class="line">//set方法没有参数</span><br><span class="line">Object value=getMethod.invoke(object, new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//将get到的属性值传入</span><br><span class="line">setMethod.invoke(objectCopy, new Object[] &#123;value&#125;);</span><br><span class="line">&#125;</span><br><span class="line">return objectCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Customer customer = new Customer(&quot;Tom&quot;,20);</span><br><span class="line">//注意是long类型的哟</span><br><span class="line">customer.setId(1L);</span><br><span class="line"></span><br><span class="line">ReflactTester tester = new ReflactTester();</span><br><span class="line"></span><br><span class="line">Customer customer2 = (Customer) tester.copy(customer);</span><br><span class="line"></span><br><span class="line">//System.out.println(customer2.getId()+&quot;,&quot;+customer2.getName()+&quot;,&quot;+customer2.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,Tom,20</span><br></pre></td></tr></table></figure><p>Class类是Reflection API 中的核心类，它有以下方法 :</p><ul><li><p>getName()：获得类的完整名字。</p></li><li><p>getFields()：获得类的public类型的属性。</p></li><li><p>getDeclaredFields()：获得类的所有属性。</p></li><li><p>getMethods()：获得类的<strong>public类型</strong>的方法。</p></li><li><p>getDeclaredMethods()：获得类的所有方法。</p><p>Method类的invoke(Object obj,Object args[])方法<strong>接 收的参数必须为对象</strong>，如果参数为基本类型数据，必须转 换为相应的包装类型的对象。<strong>invoke()方法的返回值总是 对象</strong>，如果实际被调用的方法的返回类型是基本类型数据 ，那么invoke()方法会把它转换为相应的包装类型的对象 ，再将其返回.</p></li></ul><p>下面我们来看看数组，java.lang.Array 类提供了动态创建和访 问数组元素的各种静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">public class ArrayTester1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">Object array = Array.newInstance(classType, 10);</span><br><span class="line"></span><br><span class="line">Array.set(array, 5, &quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">String str = (String)Array.get(array, 5);</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>hello</p><hr><p>创建 了一个 5 x 10 x 15 的整型数组，并把索 引位置为[3][5][10] 的元素的值为设37</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">public class ArrayTester2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int[] dims = new int[] &#123; 5, 10, 15 &#125;;</span><br><span class="line"></span><br><span class="line">Object array = Array.newInstance(Integer.TYPE, dims);</span><br><span class="line"></span><br><span class="line">System.out.println(array instanceof int[][][]);</span><br><span class="line"></span><br><span class="line">//二维数组</span><br><span class="line">Object arrayObj = Array.get(array, 3);</span><br><span class="line"></span><br><span class="line">//Class&lt;?&gt; classType=arrayObj.getClass().getComponentType();</span><br><span class="line">//System.out.println(classType);</span><br><span class="line"></span><br><span class="line">//一维数组</span><br><span class="line">arrayObj = Array.get(arrayObj, 5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array.setInt(arrayObj, 10, 37);</span><br><span class="line"></span><br><span class="line">int[][][] arrayCast = (int[][][]) array;</span><br><span class="line"></span><br><span class="line">System.out.println(arrayCast[3][5][10]);</span><br><span class="line"></span><br><span class="line">// System.out.println(Integer.TYPE);</span><br><span class="line">// System.out.println(Integer.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">37</span><br></pre></td></tr></table></figure><ol><li>Integer.TYPE 返回的是 int，而 Integer.class 返回的是 Integer 类所对应的 Class 对象。</li></ol><p>反射破坏了类的封装性，可以调用私有的方法，变量，接下来我们一起来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PivateTest &#123;</span><br><span class="line"></span><br><span class="line">private String sayHello(String name) &#123;</span><br><span class="line">return &quot;hello&quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Private &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">PivateTest private1 = new PivateTest();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=private1.getClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Method  method = classType.getDeclaredMethod(&quot;sayHello&quot;, new Class[] &#123;String.class&#125;);</span><br><span class="line"></span><br><span class="line">method.setAccessible(true);//压制java的访问权限的内部检查</span><br><span class="line"></span><br><span class="line">String string = (String)method.invoke(private1, new Object[] &#123;&quot;  zhangsan&quot;&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello  zhangsan</span><br></pre></td></tr></table></figure><p>用反射更改私有的成员变量的值，怎么实现呢，我们来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class Private2 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private String name=&quot;zhangsan&quot;;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">Private2 private2 = new Private2();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=Private.class;</span><br><span class="line"></span><br><span class="line">Field field=classType.getDeclaredField(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">//压制java对访问修饰符的检查</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//对于属性的操作，直接使用get或是set方法就可以了</span><br><span class="line">field.set(private2, &quot;lisi&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(private2.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisi</span><br></pre></td></tr></table></figure><p>众所周知Java有个Object class，是所有 Java classes的继承根源，其内声明了数 个应该在所有Java class中被改写的 methods：hashCode()、equals()、 clone()、toString()、getClass()等。其 中getClass()返回一个Class object。</p><ul><li>Class class十分特殊。它和一般classes一样继承自 Object，其实体用以表达Java程序运行时的classes和 interfaces，也用来表达enum、array、primitive Java types</li><li>（boolean, byte, char, short, int, long, float, double）以及关键词void。当一个class被加载，或当加 载器（class loader）的defineClass()被JVM调用， JVM 便自动产生一个Class object。如果您想借由“修 改Java标准库源码”来观察Class object的实际生成时 机（例如在Class的constructor内添加一个println()） ，不能够！因为Class并没有public constructor<br>只有java虚拟机可以创建一个Class</li></ul><ul><li>Class是Reflection起源。针对任何您想探 勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十 多个的Reflection APIs</li></ul><p><strong>为什么获得Method object时不需指定回返类型？</strong></p><ul><li>因为method overloading机制要求 signature必须唯一，而回返类型并非 signature的一个成份。换句话说，只要指定了method名称和参数列，就一定指出了 一个独一无二的method。（在方法重载的那个地方也是这样）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Class&lt;?&gt; classType = Child.class;</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Parent&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Child</span><br><span class="line">class Parent</span><br><span class="line">class java.lang.Object</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>什么时候能用到反射呢？</p><p>实际开发中一般是用不到反射的，除非自己去写框架肯定会用到反射，掌握了反射机制，对于以后学框架有利，理解更深入。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射机制深入剖析（一）</title>
      <link href="/2017/05/24/reflection1/"/>
      <url>/2017/05/24/reflection1/</url>
      <content type="html"><![CDATA[<p>我们来谈谈反射，这个知识点有些难度，不好理解，我介绍的详细一些，尽量细致，不对的地方往大家指正。</p><p>我们平时编的代码和接触到的都是在java编译环境中的，而在java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是<strong>肯定的</strong> 这种动态获取类的信息以及动态调用对象的方法的功能来自于java语言的反射机制。</p><p>java反射机制的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ul><p>编程语言分为动态语言和静态语言</p><p>动态语言：程序运行时，允许改变程序结构或变量类型。Perl,Python,Ruby是动态语言，而C++，java，C#不是动态语言。</p><p>而反射机制是java被视为动态语言的一个关键性质。这个机制允许程序在运行时透过Reflaction APIs取得任何一个已知名称的class的内部信息。包括其 modifiers（诸如public, static 等等）、superclass（ 例如Object）、实现之interfaces（例如Serializable） ，也包括fields和methods的所有信息，并可于运行时改 变fields内容或调用methods</p><p>尽管在这样的定义与分类下Java不是动态语言， 它却有着一个非常突出的动态相关机制： Reflection。这个字的意思是“反射、映象、倒 影”，用在Java身上指的是我们可以于运行时加 载、探知、使用编译期间完全未知的classes。换 句话说，Java程序可以加载一个运行时才得知名 称的class，获悉其完整构造（但不包括 methods定义），并生成其对象实体、或对其 fields设值、或唤起其methods。这种“看透 class”的能力（the ability of the program to examine itself）被称为introspection（内省、 内观、反省）。Reflection和introspection是常 被并提的两个术语。</p><p>在JDK中，主要由以下类来实现Java反射机制，这些类都 位于java.lang.reflect包中</p><ul><li>Class类：代表一个类。</li><li>Field 类：代表类的成员变量（成员变量也称为类的属性）。</li><li>Method类：代表类的方法。</li><li>Constructor 类：代表类的构造方法。</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li></ul><p>了解了这么多理论，大家也晕了吧，让我们来看看反射在程序中怎么使用的。。。</p><p>来介绍一下基本的作用<br><strong>java中，无论生成某各类的多少个对象，这些对象都会对应于同一个Class对象。这个Class对象是在没有生成任何类之前由jvm帮我们生成好的，在类被装载的时候Class对象就已经生成好了。这个Class对象生成好之后就会获悉我们当前类所有的成员变量以及所有的方法。</strong></p><p>首先要获得class类，这里不止一种方式，我会陆续介绍给大家。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DumpMehtod &#123;</span><br><span class="line"></span><br><span class="line">//这里我们主要是学习反射，对于异常的问题就直接抛出了</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得class类的第一种方式</span><br><span class="line">Class&lt;?&gt; class1 = Class.forName(&quot;java.lang.Object&quot;); </span><br><span class="line"></span><br><span class="line">Method[] methods = class1.getDeclaredMethods();</span><br><span class="line">//增强的for循环</span><br><span class="line">for(Method method: methods) &#123;</span><br><span class="line">System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果将获得Object类的所有方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void java.lang.Object.finalize() throws java.lang.Throwable</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public java.lang.String java.lang.Object.toString()</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">private static native void java.lang.Object.registerNatives()</span><br></pre></td></tr></table></figure><p>接下来再深入了解通过反射调用自己定义的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class InvokeTest &#123;</span><br><span class="line"></span><br><span class="line">public int  add(int a, int b) &#123;</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String echo(String string) &#123;</span><br><span class="line">return &quot;hello&quot;+string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">    </span><br><span class="line">    //平时的调用步骤</span><br><span class="line">    // InvokeTester test = new InvokeTester();</span><br><span class="line">// System.out.println(test.add(1, 2));</span><br><span class="line">// System.out.println(test.echo(&quot;tom&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获得class类的第二种方法，泛型中的？表示继承Object</span><br><span class="line">Class&lt;?&gt; classType = InvokeTest.class; </span><br><span class="line">//将类进行实例</span><br><span class="line">Object incokeTest=classType.newInstance();</span><br><span class="line">//获得类的方法，</span><br><span class="line">//使用class类调用getMethod（）方法</span><br><span class="line">//第一个参数是类的名称，第二个参数为方法的形式参数所对应的class对象构成的数组</span><br><span class="line">Method addMethod = classType.getMethod(&quot;add&quot;, new Class[] &#123;int.class,int.class&#125;);</span><br><span class="line">//调用方法的invoke（）方法，执行此方法，</span><br><span class="line">//第一个参数为此类的实例，第二个参数是为这个方法传递的参数组成的数组</span><br><span class="line">//自动装箱</span><br><span class="line">Object result=addMethod.invoke(incokeTest, new Object[]&#123;1,2&#125;);</span><br><span class="line">//返回的肯定是一个Integer类型，这里是自动拆箱</span><br><span class="line">System.out.println((Integer)result);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">Method echoMethod=classType.getMethod(&quot;echo&quot;, new Class[] &#123;String.class&#125;);</span><br><span class="line"></span><br><span class="line">Object result2=echoMethod.invoke(incokeTest, new Object[] &#123;&quot;  world&quot;&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println((String)result2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">--------------------------------------------------</span><br><span class="line">hello  world</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的内部类详细解析</title>
      <link href="/2017/03/02/inner-class/"/>
      <url>/2017/03/02/inner-class/</url>
      <content type="html"><![CDATA[<p>来说一说内部类，内部类一共分为四种，分别是</p><ol><li>静态内部类</li><li>局部内部类</li><li>成员内部类</li><li>匿名内部类</li></ol><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>类的成员</p><ol><li>成员变量</li><li>成员方法</li><li>构造方法</li><li>代码块</li><li>静态代码块</li><li>内部类</li></ol><p>按照内部类声明方式</p><ol><li>静态内部类<ul><li>static</li><li>属于类：类比于静态变量 静态方法，没有外部类的引用（不需要对象）（直接使用外部类的this也就是意味着不能直接访问外部类的非静态属性</li></ul></li></ol><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li><strong>静态内部类可以直接访问外部类的静态成员变量，静态内部类不可以直接 访问外部类的非静态成员变量</strong></li><li>调用方式：</li></ol><ul><li><p>导包的时候倒到外部类名为止<br>外部类类名.内部类类名 内部类对象名=new 外部类类名.内部类类名（）；</p></li><li><p>导包的时候倒到内部类的类名为止</p><p>内部类类名 内部类的对象名 =new 内部类类名 （）；</p><ul><li>内部类的对象名.内部类方法名（）；</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClass &#123;</span><br><span class="line"> static  int a=12;</span><br><span class="line"> //静态内部类</span><br><span class="line">     public static class Moo&#123;</span><br><span class="line">     int b=13;</span><br><span class="line">     public void add()&#123;</span><br><span class="line">     int c=14;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">Moo m=new Moo();</span><br><span class="line">m.add();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import com.qf.oop.innerclass.StaticInnerClass;</span><br><span class="line">import com.qf.oop.innerclass.StaticInnerClass.Moo;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*StaticInnerClass.Moo m=new StaticInnerClass.Moo();</span><br><span class="line">m.add();*/</span><br><span class="line">Moo m=new Moo();</span><br><span class="line">m.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>方法中<br>外部方法中的内部类，访问外部类局部变量</p><p>注意：</p><ol><li>局部内部类随方法的调用而被加载</li><li>也可以访问外部类的私有属性 持有外部类应用可以使用this</li><li>局部内部类的对象只能在该类中创建</li><li>局部内部类当中，如果访问外部类的局部变量（方法中的变量）一定是常量（使用final修饰）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class LocInnerClass &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">  final int a=12;</span><br><span class="line">  class Moo&#123;</span><br><span class="line">  int b=13;</span><br><span class="line">  public void add()&#123;</span><br><span class="line">  int c=14;</span><br><span class="line"> // a++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Moo m=new Moo();</span><br><span class="line">  m.add();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  LocInnerClass l=new LocInnerClass();</span><br><span class="line">  l.test();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void test()&#123;</span><br><span class="line">   final int a=12;</span><br><span class="line">  class Moo&#123;</span><br><span class="line">  int b=13;</span><br><span class="line">  public void add()&#123;</span><br><span class="line">  int c=14;</span><br><span class="line"> // a++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  System.out.println(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Moo m=new Moo();</span><br><span class="line">  m.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 2.成员内部类 可以使用4种访问权限符修饰</span><br><span class="line"> *   调用方式</span><br><span class="line"> *     第一种方式：</span><br><span class="line"> *       外部类类名 外部类对象名=new 外部类类名（）；</span><br><span class="line"> *       外部类类名.内部类类名 内部类对象名= 外部类对象名.new 内部类类名();</span><br><span class="line"> *       内部类对象名.方法名（）；</span><br><span class="line"> *      第二种方式：</span><br><span class="line"> *        外部类类名.内部类类名 内部类对象名=new 外部类类名（）.new 内部类类名（）；</span><br><span class="line"> *        内部类对象名.方法名（）；</span><br><span class="line"> * </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class InnerClass &#123;</span><br><span class="line">int a=12;</span><br><span class="line">   //成员内部类</span><br><span class="line">   public class Moo&#123;</span><br><span class="line">   int b=13;</span><br><span class="line">   public void add()&#123;</span><br><span class="line">   int c=14;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   /*InnerClass in=new InnerClass();</span><br><span class="line">   System.out.println(in.a);*/</span><br><span class="line">   //第一种方式</span><br><span class="line">   InnerClass in=new InnerClass();</span><br><span class="line">   InnerClass.Moo m=in.new Moo();</span><br><span class="line">   m.add();</span><br><span class="line">   InnerClass.Moo m1=in.new Moo();</span><br><span class="line">   m1.add();</span><br><span class="line">   </span><br><span class="line">   //第二种方式</span><br><span class="line">   InnerClass.Moo m3=new InnerClass().new Moo();</span><br><span class="line">   m3.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类变量名称一致的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InnerClass2 &#123;</span><br><span class="line">int a=12;</span><br><span class="line">   //成员内部类</span><br><span class="line">   public class Moo&#123;</span><br><span class="line">   int a=13;</span><br><span class="line">   public void add()&#123;</span><br><span class="line">   int a=14;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   System.out.println(&quot;内部类成员变量a=&quot;+new Moo().a);</span><br><span class="line">   System.out.println(&quot;内部类成员变量a=&quot;+this.a);</span><br><span class="line">   System.out.println(&quot;外部类的成员变量a=&quot;+new InnerClass2().a);</span><br><span class="line">   System.out.println(&quot;外部类的成员变量a=&quot;+InnerClass2.this.a);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">   //第二种方式</span><br><span class="line">   InnerClass2.Moo m3=new InnerClass2().new Moo();</span><br><span class="line">   m3.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>语法：</p><p>类名 对象名 = new 类名（）{<br>实现抽象方法<br>}</p><p>注意：</p><p>匿名内部类没有构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 匿名内部类：没有名字</span><br><span class="line"> * 语法：</span><br><span class="line"> *   类名 对象名=new 类名()&#123;</span><br><span class="line"> *      实现抽象方法</span><br><span class="line"> *   &#125;;</span><br><span class="line"> * 注意：</span><br><span class="line"> *   匿名内部类没有构造方法</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class NoNameInnerClass &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">    //AA a=new AA();</span><br><span class="line">    AA a=new BB();</span><br><span class="line">    a.add();</span><br><span class="line">    AA a1=new BB();</span><br><span class="line">    a1.add();</span><br><span class="line">    </span><br><span class="line">    //Animal an=new Animal();</span><br><span class="line">    Cat c=new Cat()&#123;</span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;猫咪正在和老鼠玩耍&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">    </span><br><span class="line">    Cat c1=new Cat()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;小猫咪抓老鼠&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line">    c1.catchMouse();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Cat c3=new MImi();</span><br><span class="line">    c3.catchMouse();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class AA&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;奔跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public abstract void add();</span><br><span class="line">&#125;</span><br><span class="line">class BB extends AA&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line">System.out.println(12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">interface Cat extends Animal&#123;</span><br><span class="line">void catchMouse();</span><br><span class="line">&#125;</span><br><span class="line">class MImi implements Cat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;小猫咪抓老鼠&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中abstract详解</title>
      <link href="/2017/01/28/abstract/"/>
      <url>/2017/01/28/abstract/</url>
      <content type="html"><![CDATA[<p>今天来介绍一下抽象类。我们用动物类来看，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal= new Animal();</span><br><span class="line">animal.name=&quot;动物&quot;;</span><br><span class="line">animal.shout();</span><br><span class="line">animal.sleep();</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.name= &quot;旺财&quot;;</span><br><span class="line">System.out.print(&quot;狗狗&quot;+dog.name);</span><br><span class="line">dog.shout();</span><br><span class="line">dog.sleep();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.name=&quot;小花&quot;;</span><br><span class="line">System.out.print(&quot;猫咪&quot;+cat.name);</span><br><span class="line">cat.shout();</span><br><span class="line">cat.sleep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">狗狗旺财汪汪叫</span><br><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">猫咪小花喵喵叫</span><br><span class="line">闭上眼睛就睡觉</span><br></pre></td></tr></table></figure><p>从上面的类中我们可以发现animal类中的shout（）方法在生活中几乎是不可能用到的，于是我们为了代码的简洁，shout（）方法不需要方法体，但是会报错误This method requires a body instead of a semicolon。于是我们便引入了abstract关键字。当我们加上abstract之后，还是会报错误The abstract method shout in type Animal can only be defined by an abstract class。那么怎么办呢？抽象方法需要在抽象类中定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void shout() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动物类</span><br><span class="line"> * shout(); 这个方法里的方法体没有用 但这个方法不能注释 让子类重写</span><br><span class="line"> * 1.abstract抽象的</span><br><span class="line"> *   The abstract method shout in type Animal can only be defined by an abstract class</span><br><span class="line"> * 2.如何定义一个抽象方法</span><br><span class="line"> *   语法：</span><br><span class="line"> *     【访问权限符】 abstract 返回值 方法名();</span><br><span class="line"> *   eg：</span><br><span class="line"> *      public abstract void shout();</span><br><span class="line"> * 3.如何定义一个抽象类</span><br><span class="line"> *   语法：</span><br><span class="line"> *    【访问权限符】  abstract class 类名&#123;&#125;</span><br><span class="line"> *   eg:</span><br><span class="line"> *    public abstract class Animal &#123;</span><br><span class="line"> *    &#125;</span><br><span class="line"> * 4.总结</span><br><span class="line"> *     A.抽象方法一定要在抽象类中</span><br><span class="line"> *     B.抽象类中可以有   0 1 多个 抽象方法</span><br><span class="line"> *     C.抽象类不能直接实例对象 只能创建子类对象 抽象类一定要被继承</span><br><span class="line"> *       Cannot instantiate the type Animal</span><br><span class="line"> *     D.子类继承父类 如果父类是抽象类 子类一定要实现父类里所有的抽象方法 除非子类也是抽象类</span><br><span class="line"> *     E.abstract可以修饰   类  方法</span><br><span class="line"> *               不能修饰   成员变量 构造方法</span><br><span class="line"> *     F.抽象类中的成员</span><br><span class="line"> *               成员变量   成员方法  构造方法       </span><br><span class="line"> *        </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>总结一下知识点：</p><ol><li><p>语法</p><p>A.抽象类和抽象方法必须使用 abstract修饰<br>B.抽象类不能直接实例 只能被继承<br>C.抽象类必须有构造方法 创建子类对象时候需要<br>D.抽象类可以有至少0个抽象方法<br>E.抽象方法只有声明没有实现（名字 没有方法体）<br>F.public abstract void shout(){} 不是抽象方法<br>G.子类必须重写抽象方法，如果不重写，自己也得是抽象类</p></li></ol><p>2.意义<br>A.抽象类为所有子类提供了一个通用模板,子类可以在此模板上进行扩展<br>B.通过抽象类，可以避免子类设计随意性<br>C.通过抽象类，可以严格限制子类的设计，使得子类更加通用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类就是用来作父类的用来被继承的</span><br></pre></td></tr></table></figure><p>问题1：<br>Animal an=new Animal(); 没有一种生物叫Animal 创建Animal没有意义<br>拒绝实例<br>解决方法：<br>Animal类 定义为抽象类<br>抽象类不能直接实例但可以被继承</p><p>问题2:<br>dog可以重写shout也可以不重写 如果希望dog必须重写shout方法 不重写就有编译错误</p><p>解决方法：<br>Animal类 里的shout方法定义为抽象方法<br>抽象方法只有声明，没有实现</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--策略模式（strategy-pattern）解析</title>
      <link href="/2016/11/08/strategy/"/>
      <url>/2016/11/08/strategy/</url>
      <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）中体现了两个非常基本的面相对象设计的原则：</p><ol><li>封装变化的概念</li><li>编程中使用接口，而不是对接口的实现</li></ol><p>策略模式的定义 ：</p><ul><li>定义一组算法，将每个算法都封装起来，并且 使它们之间可以互换。</li><li>策略模式使这些算法在客户端调用它们的时候 能够互不影响地变化</li></ul><p>策略模式的意义</p><ul><li><p>策略模式使开发人员能够开发出由许多可替换 的部分组成的软件，并且各个部分之间是弱连 接的关系。</p></li><li><p>弱连接的特性使软件具有更强的可扩展性，易 于维护；更重要的是，它大大提高了软件的可 重用性</p><p>策略模式的组成</p></li><li><p>抽象策略角色：策略类，通常由一个接口或者 抽象类实现</p></li><li><p>具体策略角色：包装了相关的算法和行为</p></li><li><p>环境角色：持有一个策略类的引用，最终给客 户端调用的。</p><p>策略模式的实现</p></li><li><p>策略模式的用意是针对一组算法，将每一个算 法封装到具有共同接口的独立的类中，从而使 得它们可以相互替换。</p></li><li><p>策略模式使得算法可以在不影响到客户端的情 况下发生变化。使用策略模式可以把行为和环 境分割开来。</p></li><li><p>环境类负责维持和查询行为类，各种算法则在 具体策略中提供。由于算法和环境独立开来， 算法的修改都不会影响环境和客户端</p></li></ul><p>策略模式的编写步骤 ：</p><ol><li>对策略对象定义一个公共接口。</li></ol><p>2．编写策略类，该类实现了上面的公共接口</p><p>3．在使用策略对象的类中保存一个对策略对 象的引用。</p><p>4．在使用策略对象的类中，实现对策略对象 的set和get方法（注入）或者使用构造方法完 成赋值</p><p>小提示：在eclipse里面Ctrl+t 进入到实现类的代码中去。</p><p>下面我们以计算器为例实现我们的策略模式：</p><h6 id="抽象策略角色"><a href="#抽象策略角色" class="headerlink" title="抽象策略角色"></a>抽象策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="具体策略角色"><a href="#具体策略角色" class="headerlink" title="具体策略角色"></a>具体策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AddStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SubtractStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MultiplyStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class DivideStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Environment &#123;</span><br><span class="line"></span><br><span class="line">private Strategy strategy;</span><br><span class="line"></span><br><span class="line">public Environment (Strategy strategy) &#123;</span><br><span class="line">this.strategy= strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Strategy getStrategy() &#123;</span><br><span class="line">return strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b) &#123;</span><br><span class="line">return strategy.calculate(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AddStrategy addStrategy = new AddStrategy();</span><br><span class="line">Environment environment = new Environment(addStrategy);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;3+4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">SubtractStrategy strategy = new SubtractStrategy();</span><br><span class="line">environment.setStrategy(strategy);</span><br><span class="line">System.out.println(&quot;3-4=&quot;+environment.calculate(3, 4));</span><br><span class="line"></span><br><span class="line">MultiplyStrategy multiplyStrategy = new MultiplyStrategy();</span><br><span class="line">environment.setStrategy(multiplyStrategy);</span><br><span class="line">System.out.println(&quot;3*4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">DivideStrategy divideStrategy = new DivideStrategy();</span><br><span class="line">environment.setStrategy(divideStrategy);</span><br><span class="line">System.out.println(&quot;3/4=&quot;+environment.calculate(3,4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3+4=7</span><br><span class="line">3-4=-1</span><br><span class="line">3*4=12</span><br><span class="line">3/4=0</span><br></pre></td></tr></table></figure><p>策略模式的缺点</p><ul><li>客户端必须知道所有的策略类，并自行决定 使用哪一个策略类。</li><li>造成很多的策略类。</li></ul><p>解决方案</p><ul><li>采用工厂方法</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中String类详细解析</title>
      <link href="/2016/04/24/string/"/>
      <url>/2016/04/24/string/</url>
      <content type="html"><![CDATA[<p>1.相等性的比较（==）<br>(1)对于原生数据类型来说，比较的是左右两边的值是否相等<br>（2）对于引用类型来说，比较左右两边的引用是否指向同一个对象，或者说左右两边的引用地址是否相同。</p><p>2.Object 类的tostring方法返回的是一个哈希code值，而string类重写了tostring方法，默认调用tostring方法。<br>API （Application Programming Interface），应用编程接口。<br>当打印引用时，实际上会打印出引用所指对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，而Object类中定义了toString()，因此每个类都有toString()这个方法。</p><p>3.equals方法<br>对于object类的equals方法来说，是用来判断两个对象是不是同一个对象。<br>对于继承了object类的其他类来说，如果重写了equals方法，才是判断内容是否一致，，如果没有重写equals方法，是判断地址是否一致。<br>对于String类的equals()方法来说，它是判断当前字符串与传进来的字符串的内容是否一致。</p><p>4.字符串是一个常量，创建之后值是不能被改变的。</p><p>5.String是常量，其对象一旦创建完毕就无法改变。当使用+拼接字符串时，会生成新的String对象，而不是向原有的String对象追加内容。</p><p>6、 String Pool（字符串池）</p><p>7、 String s = “aaa”;（采用字面值方式赋值）<br>1) 查找String Pool中是否存在“aaa”这个对象，如果不存在，则在String Pool中创建一个“aaa”对象，然后将String Pool中的这个“aaa”对象的地址返回来，赋给引用变量s，这样s会指向String Pool中的这个“aaa”字符串对象<br>2) 如果存在，则不创建任何对象，直接将String Pool中的这个“aaa”对象地址返回来，赋给s引用。</p><p>8、 String s = new String(“aaa”);<br>1) 首先在String Pool中查找有没有“aaa”这个字符串对象，如果有，则不在String Pool中再去创建“aaa”这个对象了，直接在堆中（heap）中创建一个“aaa”字符串对象，然后将堆中的这个“aaa”对象的地址返回来，赋给s引用，导致s指向了堆中创建的这个“aaa”字符串对象。<br>2) 如果没有，则首先在String Pool中创建一个“aaa“对象，然后再在堆中（heap）创建一个”aaa“对象，然后将堆中的这个”aaa“对象的地址返回来，赋给s引用，导致s指向了堆中所创建的这个”aaa“对象。</p><p>9.new出来的对象都是在堆里面</p><p>10.intern（）方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Object object = new Object();</span><br><span class="line">Object object2 = new Object();</span><br><span class="line"></span><br><span class="line">//object类中的equals方法是使用==判断的</span><br><span class="line">System.out.println(object == object2);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line">String str = new String(&quot;aaa&quot;);</span><br><span class="line">String str2 = new String(&quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(str == str2);//false两个对象</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">//StringPool字符串池在栈中，当字符串被赋予字面值的时候，首先检查字符串池里面有没有该对象&quot;bbb&quot;</span><br><span class="line">//如果没有，就将该字符串放入字符串池里面，字符串变量便指向这个对象</span><br><span class="line">//如果有，就不会在字符串池里面创建新的对象，而是在已有的字符串池里面的对象直接返回来赋给字符串变量str4</span><br><span class="line">//所以str4并没有创建对象</span><br><span class="line">//new出来的对象都是在堆里面</span><br><span class="line">String str3 = &quot;bbb&quot;;//创建一个对象</span><br><span class="line">String str4 = &quot;bbb&quot;;//并没有创建对象</span><br><span class="line"></span><br><span class="line">System.out.println(str3 == str4);//true指向同一个对象</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">String str5 = new String(&quot;ccc&quot;);</span><br><span class="line">String str6 = &quot;ccc&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str5 == str6);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">//字符串的拼接并不是将字符串拼接到后面。字符串是常量，创建后就不能改变了，</span><br><span class="line">//加法操作实际上是生成了一个新的对象，而不是往原有的对象追加内容。</span><br><span class="line">String s = &quot;hello&quot;;//</span><br><span class="line">String s1 = &quot;hel&quot;;</span><br><span class="line">String s2 = &quot;lo&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s == s1 + s2);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line">System.out.println(s == &quot;hel&quot; + &quot;lo&quot;);//true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package testPackage;</span><br><span class="line">class Test &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                String hello = &quot;Hello&quot;, lo = &quot;lo&quot;;</span><br><span class="line">                System.out.print((hello == &quot;Hello&quot;) + &quot; &quot;);</span><br><span class="line">                System.out.print((Other.hello == hello) + &quot; &quot;);</span><br><span class="line">                System.out.print((other.Other.hello == hello) + &quot; &quot;);</span><br><span class="line">                System.out.print((hello == (&quot;Hel&quot;+&quot;lo&quot;)) + &quot; &quot;);</span><br><span class="line">                System.out.print((hello == (&quot;Hel&quot;+lo)) + &quot; &quot;);</span><br><span class="line">                System.out.println(hello == (&quot;Hel&quot;+lo).intern());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other &#123; static String hello = &quot;Hello&quot;; &#125;</span><br></pre></td></tr></table></figure><h6 id="and-the-compilation-unit"><a href="#and-the-compilation-unit" class="headerlink" title="and the compilation unit:"></a>and the compilation unit:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">public class Other &#123; static String hello = &quot;Hello&quot;; &#125;</span><br></pre></td></tr></table></figure><h6 id="produces-the-output"><a href="#produces-the-output" class="headerlink" title="produces the output:"></a>produces the output:</h6><p>true true true true false true</p><h6 id="This-example-illustrates-six-points"><a href="#This-example-illustrates-six-points" class="headerlink" title="This example illustrates six points:"></a>This example illustrates six points:</h6><p>1.Literal strings within the same class (§8) in the same package (§7) represent references to the same String object (§4.3.1).<br>2.Literal strings within different classes in the same package represent references to the same String object.<br>3.Literal strings within different classes in different packages likewise represent references to the same String object.<br>4.Strings computed by constant expressions (§15.28) are computed at compile time and then treated as if they were literals.<br>5.Strings computed by concatenation at run time are newly created and therefore distinct.</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中TreeSet底层解析和collections解析</title>
      <link href="/2016/03/27/treeset-collections/"/>
      <url>/2016/03/27/treeset-collections/</url>
      <content type="html"><![CDATA[<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>下图是集合框架中的接口<br><img src="http://img.blog.csdn.net/20171107204219357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>今天我来谈谈SortedSet接口。</p><p>TreeSet实现了SortedSet接口，如果有自然的顺序，TreeSet具有排序的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">set.add(&quot;C&quot;);</span><br><span class="line">set.add(&quot;A&quot;);</span><br><span class="line">set.add(&quot;B&quot;);</span><br><span class="line">set.add(&quot;E&quot;);</span><br><span class="line">set.add(&quot;F&quot;);</span><br><span class="line">set.add(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A,B,C,D,E,F]</span><br></pre></td></tr></table></figure><p>但是如果没有自然顺序的值还有正常的排序吗？我们一起来看看。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出现了，报错误了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other.Person cannot be cast to java.lang.Comparable</span><br></pre></td></tr></table></figure><p>不要慌张，去底层寻找解决办法。</p><p><img src="http://img.blog.csdn.net/20171107210401006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>遇到错误通过文档去查找，大部分都是可以解决的哦，一定要有耐心哟!<br>TreeSet是带有排序的，我们刚才没有给程序说按照什么规则比较，所以我们要向往TreeSet放置对象，我们必须要告诉TreeSet排序的规则，制定好排序的规则，但是在哪里指定呢？和我一起来查看TreeSet的构造方法吧。</p><p><img src="http://img.blog.csdn.net/20171107210824004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>改bug：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan2;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet(new PersonComparator());</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonComparator implements Comparator</span><br><span class="line">&#123;</span><br><span class="line">public int compare(Object arg0, Object arg1)</span><br><span class="line">&#123;</span><br><span class="line">Person p1 = (Person) arg0;</span><br><span class="line">Person p2 = (Person) arg1;</span><br><span class="line"></span><br><span class="line">return p2.score - p1.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">40</span><br><span class="line">30</span><br><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections的一些方法用起来还是很方便的，分享给大家，Collections里面的方法都是静态的，可以直接调用。<br>sort（）；排序<br>reverseOrder()；反序<br>shuffle（）;乱序<br>min();最小<br>max();最大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">LinkedList list = new LinkedList();</span><br><span class="line"></span><br><span class="line">list.add(new Integer(-8));</span><br><span class="line">list.add(new Integer(20));</span><br><span class="line">list.add(new Integer(-20));</span><br><span class="line">list.add(new Integer(8));</span><br><span class="line">//自然顺序的反序操作</span><br><span class="line">Comparator r = Collections.reverseOrder();</span><br><span class="line">//排序</span><br><span class="line">Collections.sort(list, r);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">//乱序</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;minimum value: &quot; + Collections.min(list));</span><br><span class="line">System.out.println(&quot;maximum value: &quot; + Collections.max(list));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">20 8 -8 -20 </span><br><span class="line">-20 20 -8 8 </span><br><span class="line">minimum value: -20</span><br><span class="line">maximum value: 20</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--单例模式</title>
      <link href="/2016/01/23/singleton/"/>
      <url>/2016/01/23/singleton/</url>
      <content type="html"><![CDATA[<p>单例模式分为两种：饿汉式、懒汉式</p><p>既然是单例模式，那么就只有一个实例，那么构造方法就是私有的，就需要创建一个对象，而且也需要是私有的，但是需要调用所以要设置成静态的，然后提供一个方法拿到这个私有的对象。<br>一个类只会生成唯一的一个对象。</p><p>单例模式：饿汉式</p><p>1.私有构造方法<br>2.创建私有的静态对象<br>3.创建一个公共公开的方法，返回该私有对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Single1 &#123;</span><br><span class="line">  private static Single1 s1=new Single1();</span><br><span class="line">  private Single1()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static  Single1 getInstance()&#123;</span><br><span class="line">  return s1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">/*Single1 s1=new Single1();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=new Single1();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);*/</span><br><span class="line">Single1 s1=Single1.getInstance();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=Single1.getInstance();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>饿汉式就是更急切的new出来了对象，而懒汉式就不这样了，其实，本质是一样的，让我们来看看懒汉吧。</p><p>单例模式：懒汉式</p><p>1.私有构造方法</p><ol><li>创建私有静态对象<br>3.创建公开公共的静态方法返回该私有对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Single2 &#123;</span><br><span class="line">  private static Single2 s2=null;</span><br><span class="line">  private Single2()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  s2=new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;</span><br><span class="line">  &#125;</span><br><span class="line">  /*public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  return new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;  错误的</span><br><span class="line">  &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Single2 s1=Single2.getInstance();</span><br><span class="line">  System.out.println(s1);</span><br><span class="line">  Single2 s2=Single2.getInstance();</span><br><span class="line">  System.out.println(s2);</span><br><span class="line">  System.out.println(s1==s2);</span><br><span class="line">  //Object</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式的单例模式有一种错误的方法，我已经在代码中写出来了，大家一定要注意，仔细一点哦。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--工厂模式解析</title>
      <link href="/2015/10/02/factory/"/>
      <url>/2015/10/02/factory/</url>
      <content type="html"><![CDATA[<p>在看工厂模式之前我们先了解一下面相对象的原则。</p><p>面向对象设计的基本原则</p><ul><li>OCP开闭原则：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP依赖倒转原则：要针对接口编程，不要针对实现编程</li><li>LOD迪米特法则：只与你直接的朋友通信，而避免和陌生人通话。</li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>实现了创建者和调用者的分离，下面我用汽车类的例子来介绍。</p><p>详细分类</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>也称之为静态工厂模式，项目开发中通常使用</p><p>(下面的例子对比了使用工厂模式和不适用工厂模式的情况)<br>工厂类：两种方式都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂类用来创建汽车，这个类里的方法需要是static的</span><br><span class="line">public class CarFactory &#123;</span><br><span class="line"></span><br><span class="line">public static Car createCar(String type) &#123;</span><br><span class="line">if(&quot;奥迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;else if (&quot;比亚迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return null;///违反了开闭原则</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CarFactory2 &#123;</span><br><span class="line"></span><br><span class="line">public static Car createAudi() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line">public static  Car  createByd() &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个车的接口，供各种类型的汽车实现</span><br><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不使用工厂模式的情况</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new Audi();</span><br><span class="line">Car car2 = new Byd();</span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单工厂情况下</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Client02 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car = CarFactory.createCar(&quot;奥迪&quot;);</span><br><span class="line">Car car2 = CarFactory.createCar(&quot;比亚迪&quot;);</span><br><span class="line"></span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure><p>简单工厂模式违背了面向对象编程的开闭原则，所以进一步发展就有了咱们下面要介绍的工厂方法模式，其实工厂方法模式在理论上是符合面相编程设计的原则的，但是实用性不如简单工厂模式大，他定义了太多的类和接口，每个具体的车类都需要有一个对应的车工厂，没有简单工厂模式简洁。在实际的开发中，简单工厂模式较为实用。</p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>根据设计理论上工厂方法模式占优势，实际上比简单工厂模式要复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂的接口，来供其他的具体车类实现</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line"></span><br><span class="line">Car createCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AudiFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;奔驰在跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BenzFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Benz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BydFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new AudiFactory().createCar();</span><br><span class="line">car.run();</span><br><span class="line"></span><br><span class="line">Car car2 = new BydFactory().createCar();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure><p>工厂方法模式不修改已有类的前提下，通过增加新的工厂类实现扩展。工厂方法模式在理论上符合面向对象设计的原则，但是带来了类的冗余和拓展，所以实际中不大使用。</p><p>下面来看一下最后一种抽象工厂模式，也是最复杂的一种</p><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>用来生产不同产品族的全部产品（对于增加新的产品，无能为力，支持增加产品族）</p><p><img src="http://img.blog.csdn.net/20171110182731351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建车工厂</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line">Engine createEngine();</span><br><span class="line">Seat createSeat();</span><br><span class="line">Tyre createTyre();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建发动机接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">public interface Engine &#123;</span><br><span class="line">void run();</span><br><span class="line">void start();</span><br><span class="line">&#125;</span><br><span class="line">//高端发动机</span><br><span class="line">class LuxuryEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得快&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动快，可以自动启停&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//高端发动机</span><br><span class="line">class LowEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得慢&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动慢&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建座椅接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface Seat &#123;</span><br><span class="line"></span><br><span class="line">void massage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxurySeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowSeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;不可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建轮胎接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface Tyre &#123;</span><br><span class="line"></span><br><span class="line">void revolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxuryTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;旋转不磨损&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;磨损快&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低端类工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LowCarFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowSeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowTyre();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高端类工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class LuxuryCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxurySeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说一下工厂模式的应用场景<br><img src="http://img.blog.csdn.net/20171110182745587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中Map和Set的底层分析</title>
      <link href="/2015/06/12/map-set/"/>
      <url>/2015/06/12/map-set/</url>
      <content type="html"><![CDATA[<p>1.HashSet底层是使用HashMap实现的。当使用add方法将对象添加到Set当中时，实际上是将该对象作为底层所维护的Map对象的key，而value则都是同一个Object对象（该对象我们用不上）；其他的都是通过定义的HashMap对象实现的。</p><p>2.HashMap的底层，</p><p>loadFactor负载因子为0.75，数据结构中的哈希表有关。通过散列函数也就是哈希函数计算。<br>table是一个Entry类型的数组，当需要的时候回重新调整大小，他的长度必须为2的指数。默认生成一个长度为16的Entry类型的数组。</p><p>3.Entry是HashMap的内部类，实现了Map.Entry接口，实现了他的方法。</p><p>4.HashMap底层维护一个数组，我们向HashMap中所放置的对象实际上是存放在该数组中。</p><p>5.当向HashMap中put一对键值时，它会根据key的hashCode值计算出一个位置，该位置就是此对象准备往数组中存放的位置。<br>6.如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找（Entry类有一个Entry类型的next成员变量，指向了该对象的下一个对象），如果此链上有对象的话，再去使用equals方法进行比较，如果对此链上的某个对象的equals方法比较为false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。</p><p>7.HashMap的内存实现布局：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-20184222441.png" alt="Untitled-1-20184222441"></p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中Map接口实现类HashMap、Map.Entry接口</title>
      <link href="/2015/05/20/map-hashmap/"/>
      <url>/2015/05/20/map-hashmap/</url>
      <content type="html"><![CDATA[<p>来谈谈集合中的Map接口，它常用的实现类为HashMap。<br><img src="http://img.blog.csdn.net/20171108170056226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><hr><ul><li>除了类集，Java 2还在java.util中增加了映射。 映射（map）是一个存储关键字和值的关联 或者说是关键字/值对的对象。给定一个关 键字，可以得到它的值。关键字和值都是 对象。关键字必须是唯一的。但值是可以 重复的。有些映射可以接收null关键字和 null值。而有的则不行</li><li>Map接口映射唯一关键字到值。关键字（key）是 以后用于检索值的对象。给定一个关键字和一个 值，可以存储这个值到一个Map对象中。当这个 值被存储以后，就可以使用它的关键字来检索它。 当调用的映射中没有项存在时，其中的几种方法 会引发一个NoSuchElementException异常。而当对 象与映射中的元素不兼容时，引发一个 ClassCastException异常。如果试图使用映射不允 许使用的null对象时，则引发一个 NullPointerException异常。当试图改变一个不允 许修改的映射时，则引发一个 UnsupportedOperationException异常</li><li>映射循环使用两个基本操作：get( )和put( )。使用 put( )方法可以将一个指定了关键字和值的值加入 映射。为了得到值，可以通过将关键字作为参数 来调用get( )方法。调用返回该值。</li><li>映射不是类集，但可以获得映射的类集“视图”。 为了实现这种功能，可以使用entrySet( )方法，它 返回一个包含了映射中元素的集合（Set）。为了 得到关键字的类集“视图”，可以使用keySet( ) 方法，返回一个Set集合不可以重复。为了得到值的类集“视图”，可以使用 values( )方法，返回一个Collection集合，可以重复。类集“视图”是将映射集成到类集 框架内的手段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line">map.put(&quot;e&quot;, &quot;ee&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">String key = (String)iter.next();</span><br><span class="line">String value = (String)map.get(key);</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot;=&quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=aa</span><br><span class="line">b=bb</span><br><span class="line">c=cc</span><br><span class="line">d=dd</span><br><span class="line">e=ee</span><br></pre></td></tr></table></figure><p>遍历Map的两种方式，一种是直接打印输出，另一种是利用Set集合中的iterator（）；方法，首先调用Map的keySet（）方法返回一个Set集合，通过Set集合中key的值可以得到value的值。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><hr><p>HashMap类使用散列表实现Map接口。这允 许一些基本操作如get( )和put( )的运行时间 保持恒定，即便对大型集合，也是这样的 下面的构造函数定义为：</p><ul><li><p>HashMap( )</p></li><li><p>HashMap(Map m)</p></li><li><p>HashMap(int capacity)</p></li><li><p>HashMap(int capacity, float fillRatio)</p><p>第一种形式构造一个默认的散列映射。<br>第二种形式用m的元素初始化散列映射。<br>第三种形式将散列映射的容量初始化为 capacity。<br>第四种形式用它的参数同时初始化散列映 射的容量和填充比。容量和填充比的含义 与前面介绍的HashSet中的容量和填充比相同。<br>HashMap实现Map并扩展AbstractMap。它 本身并没有增加任何新的方法<br>应该注意的是散列映射并不保证它的元素 的顺序。因此，元素加入散列映射的顺序 并不一定是它们被迭代函数读出的顺序</p></li></ul><h1 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h1><hr><p>Map.Entry接口使得可以操作映射的输入。 回想由Map接口说明的entrySet( )方法，调 用该方法返回一个包含映射输入的集合 （Set）。这些集合元素的每一个都是一个 Map.Entry对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line"></span><br><span class="line">Set set = map.entrySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line"></span><br><span class="line">String key = (String)entry.getKey();</span><br><span class="line">String value = (String)entry.getValue();</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot; : &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a : aa</span><br><span class="line">b : bb</span><br><span class="line">c : cc</span><br><span class="line">d : dd</span><br></pre></td></tr></table></figure><p>Entry对象里面封装了key和value。</p><p>Map是key和value的映射，在Map里面key和value并不是单独存放的，在底层会生成一个entry对象，entry对象里面封装了value和key，所以获得了entry对象就可以同时获得key和value。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java三大特性</title>
      <link href="/2015/03/02/java-base/"/>
      <url>/2015/03/02/java-base/</url>
      <content type="html"><![CDATA[<p>java最大的特点就是面向对象、可跨平台。Java的三大特性分别是继承（Inheritance）、封装（encapsulation ）、多态。（polymorphism ）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>继承就是子类继承父类的属性和方法。就是生活中的儿子继承了父亲，是现实生活中的例子在java语言中的一个抽象。java是单继承的，表示一个类智能从另一个类继承，（被继承的类叫做父类（基类base class），继承的类叫做子类），java中的继承使用extends关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">public Parent() &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当生成子类对象时，Java默认首先调用父类的不带参数的构造方法，然后执行该构造方法，生成父类的对象。接下来，再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象。比如说：没有父亲，就没有孩子】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">super(1);</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">//public Parent() &#123;</span><br><span class="line">//System.out.println(&quot;parent&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">public Parent(int i) &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super关键字表示对父类对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果子类使用super（）显式调用父类的某个构造方法，那么在执行的时候就会寻找与super（）所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Apple apple = new Apple();</span><br><span class="line"></span><br><span class="line">System.out.println(apple.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">//String name = &quot;fruit&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">String name = &quot;apple&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于继承的3点：</p><ul><li>父类有的，子类也有</li><li>父类没有的，子类可以增加</li><li>父类有的，子类可以改变</li></ul><p>关于继承的注意事项</p><ul><li>构造方法不能被继承<ul><li>方法和属性可以被继承</li><li>子类的构造方法隐式地调用父类的不带参数的构造方法</li><li>当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用</li><li>super关键字必须是构造方法中的第一行语句。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is running&quot;);</span><br><span class="line">super.run(); //调用父类的run方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重写（override）：又叫做覆写，子类与父类的方法返回类型一样、方法名称一样、参数一样，这样我们说子类与父类的方法构成了重写方法。</p><p>当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run()不必放在第一行语句，因此此时父类对象已经构造完毕，先调用父类的run()方法还是先调用子类的run()方法是根据程序的逻辑决定的。</p><p>在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是Java中所有类的直接或间接父类）。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><hr><p>多态（Polymorphism）：我们说子类就是父类（菊花是花，女人是人），因此多态的意思是：父类型的引用可以指向子类的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Flower rose = new Rose(); //多态</span><br><span class="line">rose.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Flower</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;flower is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rose extends Flower</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>方法重载不是面向对象的特征，如果不是晚绑定，就不是多态，而方法重载不是晚绑定而是早绑定。（参考Thinking in java）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Parent parent = new Parent();</span><br><span class="line">//parent.sing();</span><br><span class="line"></span><br><span class="line">//Child child = new Child();</span><br><span class="line">//child.sing();</span><br><span class="line"></span><br><span class="line">Parent p = new Child();</span><br><span class="line">p.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;parent is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;child is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parent p = new Child();当使用多态方式调用方法时，首先检查父类中是否有sing()方法，如果没有则编译错误；如果有，再去调用子类的sing()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest2</span><br><span class="line">&#123;</span><br><span class="line">public static  void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal2 = animal;</span><br><span class="line">animal2.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal = animal2;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">Animal animal = cat;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Animal();</span><br><span class="line">Cat cat = (Cat)animal;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//向上类型转换</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line"></span><br><span class="line">Animal animal = cat;</span><br><span class="line"></span><br><span class="line">animal.sing();</span><br><span class="line"></span><br><span class="line">//向下类型转换</span><br><span class="line">Animal a = new Cat();</span><br><span class="line"></span><br><span class="line">Cat c = (Cat)a;</span><br><span class="line"></span><br><span class="line">c.sing();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;cat is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种类型的强制类型转换：</p><ol><li>向上类型转换（upcast）：比如说将Cat类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显式指定。<ol><li>向下类型转换（downcast）：比如将Animal类型转换为Cat类型。即将父类型转换为子类型。对于向下类型转换，必须要显式指定（必须要使用强制类型转换）。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.run();</span><br><span class="line"></span><br><span class="line">//Pear p = (Pear)f;</span><br><span class="line">//p.run();</span><br><span class="line">//是不可以的，父类中没有grow（），强制类型转换后可以</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.grow();</span><br><span class="line"></span><br><span class="line">Fruit f = new Pear();</span><br><span class="line"></span><br><span class="line">Pear p = (Pear)f;</span><br><span class="line"></span><br><span class="line">p.grow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;fruit is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pear extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void grow()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is growing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想使用子类特有的方法，而此方法没有在父类中出现的时候可以使用强制类型转换（向下类型转换）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest4</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A a = null;</span><br><span class="line"></span><br><span class="line">if(args[0].equals(&quot;1&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new B();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;2&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new C();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;3&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;D&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>晚绑定，编译的时候不知道，等到执行的时候才能确定下来具体的子类。</p><p>Connecting a function call to a function body is called binding.（将函数体和函数调用关联起来，就叫绑定）</p><p>早绑定（Early binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When binding is performed before the program is run (by the compiler and linker), it&apos; s called early binding</span><br><span class="line">在程序运行之前（也就是编译和链接时），执行的绑定是早绑定。</span><br></pre></td></tr></table></figure><p>晚绑定（late binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">late binding, which means the binding occurs at runtime, based on the type of the object. When a language implements late binding, there must be some mechanism to determine the  type of the object at runtime and call the appropriate member function.</span><br></pre></td></tr></table></figure><p>早绑定的优点是:</p><ul><li>编译效率</li><li>代码提示(代码智能感知)</li><li>编译时类型检查</li></ul><p>晚绑定的优点是:</p><ul><li>不用申明类型</li><li>对象类型可以随时更改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest5</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void run(BMW bmw)</span><br><span class="line">&#123;</span><br><span class="line">bmw.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(QQ qq)</span><br><span class="line">&#123;</span><br><span class="line">qq.run();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public void run(Car car)</span><br><span class="line">&#123;</span><br><span class="line">car.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">BMW bmw = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(bmw);</span><br><span class="line"></span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">Car car = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(car);</span><br><span class="line">//向上类型转换</span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;car is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BMW extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;BMW is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class QQ extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;QQ is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态屏蔽掉了子类给我们带来的差异性</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><hr><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问，其实前面用到了封装。</p><p>访问权限符：<br><img src="http://img.blog.csdn.net/20171108110832150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>封装的优点：</p><ol><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ol><p>修改属性的可见性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个值属性提供对外的公共方法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class EncapTest&#123;</span><br><span class="line"> </span><br><span class="line">   private String name;</span><br><span class="line">   private String idNum;</span><br><span class="line">   private int age;</span><br><span class="line"> </span><br><span class="line">   public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getIdNum()&#123;</span><br><span class="line">      return idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setAge( int newAge)&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String newName)&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setIdNum( String newId)&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用封装解决非法赋值问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">import other.Other;</span><br><span class="line"></span><br><span class="line">class Test2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(200);</span><br><span class="line">student.setId(1001);</span><br><span class="line">student.setName(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">student.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">private int id;</span><br><span class="line">private int age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Student(int id, int age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.id = id;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">if(age&lt;0||age&gt;150) &#123;</span><br><span class="line">this.age=0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;Student:id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:id=1001,name=张三,age=0</span><br></pre></td></tr></table></figure><p>近期系统的学习了java，做了一些知识的总结和思考，以博客的形式展示了出来，希望大家指点。我的第一篇博客完成，希望自己今后能够坚持下来，认真的反思与思考，总结博客，对各方面的知识能够更深入的研究学习。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
