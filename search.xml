<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>机器学习算法剖析----KNN近邻算法</title>
      <link href="/2018/04/13/KNN/"/>
      <url>/2018/04/13/KNN/</url>
      <content type="html"><![CDATA[<h1 id="K-近邻算法（KNN）"><a href="#K-近邻算法（KNN）" class="headerlink" title="K-近邻算法（KNN）"></a>K-近邻算法（KNN）</h1><p>K nearest neighbour</p><ul><li>说明：本文采用的是jupyter-notebook环境，我直接贴的IPython代码，小伙伴们要到jypyter-notebook上运行哟！:smile:</li><li>案例下载<a href="https://github.com/yuansuixin/k-Nearest-Neighbor" title="案例" target="_blank" rel="noopener">案例</a></li></ul><h2 id="0、导引"><a href="#0、导引" class="headerlink" title="0、导引"></a>0、导引</h2><h3 id="如何进行电影分类"><a href="#如何进行电影分类" class="headerlink" title="如何进行电影分类"></a>如何进行电影分类</h3><p>众所周知，电影可以按照题材分类，然而题材本身是如何定义的?由谁来判定某部电影属于哪<br>个题材?也就是说同一题材的电影具有哪些公共特征?这些都是在进行电影分类时必须要考虑的问<br>题。没有哪个电影人会说自己制作的电影和以前的某部电影类似，但我们确实知道每部电影在风格<br>上的确有可能会和同题材的电影相近。那么动作片具有哪些共有特征，使得动作片之间非常类似，<br>而与爱情片存在着明显的差别呢？动作片中也会存在接吻镜头，爱情片中也会存在打斗场景，我们<br>不能单纯依靠是否存在打斗或者亲吻来判断影片的类型。但是爱情片中的亲吻镜头更多，动作片中<br>的打斗场景也更频繁，基于此类场景在某部电影中出现的次数可以用来进行电影分类。</p><p>本章介绍第一个机器学习算法：K-近邻算法，它非常有效而且易于掌握。</p><h2 id="1、k-近邻算法原理"><a href="#1、k-近邻算法原理" class="headerlink" title="1、k-近邻算法原理"></a>1、k-近邻算法原理</h2><p>简单地说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。</p><ul><li>优点：精度高、对异常值不敏感、无数据输入假定。</li><li>缺点：时间复杂度高、空间复杂度高。</li><li>适用数据范围：数值型和标称型。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据<br>与所属分类的对应关系。输人没有标签的新数据后，将新数据的每个特征与样本集中数据对应的<br>特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们<br>只选择样本数据集中前K个最相似的数据，这就是K-近邻算法中K的出处,通常<em>K是不大于20的整数。<br>最后 ，选择K个最相似数据中出现次数最多的分类，作为新数据的分类</em>。</p><p>回到前面电影分类的例子，使用K-近邻算法分类爱情片和动作片。有人曾经统计过很多电影的打斗镜头和接吻镜头，下图显示了6部电影的打斗和接吻次数。假如有一部未看过的电影，如何确定它是爱情片还是动作片呢？我们可以使用K-近邻算法来解决这个问题。</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192352.PNG" alt="Untitled-1-2018413192352"></p><p>首先我们需要知道这个未知电影存在多少个打斗镜头和接吻镜头，上图中问号位置是该未知电影出现的镜头数图形化展示，具体数字参见下表。<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841319243.PNG" alt="Untitled-1-201841319243"></p><p>即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先计算未知电影与样本集中其他电影的距离，如图所示。</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192410.PNG" alt="Untitled-1-2018413192410"></p><p>现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到K个距<br>离最近的电影。假定k=3，则三个最靠近的电影依次是California Man、He’s Not Really into Dudes、Beautiful Woman。K-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。</p><h3 id="欧几里得距离-Euclidean-Distance"><a href="#欧几里得距离-Euclidean-Distance" class="headerlink" title="欧几里得距离(Euclidean Distance)"></a>欧几里得距离(Euclidean Distance)</h3><p>欧氏距离是最常见的距离度量，衡量的是多维空间中各个点之间的绝对距离。公式如下：</p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192416.png" alt="Untitled-1-2018413192416"></p><h2 id="2、在scikit-learn库中使用k-近邻算法"><a href="#2、在scikit-learn库中使用k-近邻算法" class="headerlink" title="2、在scikit-learn库中使用k-近邻算法"></a>2、在scikit-learn库中使用k-近邻算法</h2><ul><li><p>分类问题：from sklearn.neighbors import KNeighborsClassifier</p></li><li><p>回归问题：from sklearn.neighbors import KNeighborsRegressor</p></li></ul><h3 id="0）一个最简单的例子"><a href="#0）一个最简单的例子" class="headerlink" title="0）一个最简单的例子"></a>0）一个最简单的例子</h3><p>身高、体重、鞋子尺码数据对应性别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理分类问题</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment"># 处理回归问题</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建KNN分类器对象</span></span><br><span class="line"><span class="comment"># n_neighbors应设置为一个奇数，表示距离预测样本最近的n个样本点</span></span><br><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X_train必须是一个列向量（二维数组）</span></span><br><span class="line">X_train = np.array([[<span class="number">19</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">18</span>],[<span class="number">25</span>,<span class="number">1</span>],[<span class="number">24</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">17</span>]])</span><br><span class="line">y_train = np.array([<span class="string">'动作'</span>,<span class="string">'爱情'</span>,<span class="string">'动作'</span>,<span class="string">'动作'</span>,<span class="string">'爱情'</span>])</span><br><span class="line">display(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>array([[19,  1],       [ 2, 18],       [25,  1],       [24,  3],       [ 3, 17]])array([&apos;动作&apos;, &apos;爱情&apos;, &apos;动作&apos;, &apos;动作&apos;, &apos;爱情&apos;], dtype=&apos;&lt;U2&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练分类器模型</span></span><br><span class="line">knnclf.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=3, p=2,           weights=&apos;uniform&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_test = np.array([[<span class="number">13</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">10</span>]])</span><br><span class="line">knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><pre><code>array([&apos;动作&apos;, &apos;爱情&apos;], dtype=&apos;&lt;U2&apos;)</code></pre><h3 id="1）用于分类"><a href="#1）用于分类" class="headerlink" title="1）用于分类"></a>1）用于分类</h3><p>导包，机器学习的算法KNN、数据鸢尾花</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load_iris是机器学习库提供给我们研究算法的数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br></pre></td></tr></table></figure><p>获取训练样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">iris</span><br></pre></td></tr></table></figure><pre><code>{&apos;DESCR&apos;: &apos;Iris Plants Database\n====================\n\nNotes\n-----\nData Set Characteristics:\n    :Number of Instances: 150 (50 in each of three classes)\n    :Number of Attributes: 4 numeric, predictive attributes and the class\n    :Attribute Information:\n        - sepal length in cm\n        - sepal width in cm\n        - petal length in cm\n        - petal width in cm\n        - class:\n                - Iris-Setosa\n                - Iris-Versicolour\n                - Iris-Virginica\n    :Summary Statistics:\n\n    ============== ==== ==== ======= ===== ====================\n                    Min  Max   Mean    SD   Class Correlation\n    ============== ==== ==== ======= ===== ====================\n    sepal length:   4.3  7.9   5.84   0.83    0.7826\n    sepal width:    2.0  4.4   3.05   0.43   -0.4194\n    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)\n    petal width:    0.1  2.5   1.20  0.76     0.9565  (high!)\n    ============== ==== ==== ======= ===== ====================\n\n    :Missing Attribute Values: None\n    :Class Distribution: 33.3% for each of 3 classes.\n    :Creator: R.A. Fisher\n    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)\n    :Date: July, 1988\n\nThis is a copy of UCI ML iris datasets.\nhttp://archive.ics.uci.edu/ml/datasets/Iris\n\nThe famous Iris database, first used by Sir R.A Fisher\n\nThis is perhaps the best known database to be found in the\npattern recognition literature.  Fisher\&apos;s paper is a classic in the field and\nis referenced frequently to this day.  (See Duda &amp; Hart, for example.)  The\ndata set contains 3 classes of 50 instances each, where each class refers to a\ntype of iris plant.  One class is linearly separable from the other 2; the\nlatter are NOT linearly separable from each other.\n\nReferences\n----------\n   - Fisher,R.A. &quot;The use of multiple measurements in taxonomic problems&quot;\n     Annual Eugenics, 7, Part II, 179-188 (1936); also in &quot;Contributions to\n     Mathematical Statistics&quot; (John Wiley, NY, 1950).\n   - Duda,R.O., &amp; Hart,P.E. (1973) Pattern Classification and Scene Analysis.\n     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.\n   - Dasarathy, B.V. (1980) &quot;Nosing Around the Neighborhood: A New System\n     Structure and Classification Rule for Recognition in Partially Exposed\n     Environments&quot;.  IEEE Transactions on Pattern Analysis and Machine\n     Intelligence, Vol. PAMI-2, No. 1, 67-71.\n   - Gates, G.W. (1972) &quot;The Reduced Nearest Neighbor Rule&quot;.  IEEE Transactions\n     on Information Theory, May 1972, 431-433.\n   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&quot;s AUTOCLASS II\n     conceptual clustering system finds 3 classes in the data.\n   - Many, many more ...\n&apos;, &apos;data&apos;: array([[5.1, 3.5, 1.4, 0.2],        [4.9, 3. , 1.4, 0.2],        [4.7, 3.2, 1.3, 0.2],        [4.6, 3.1, 1.5, 0.2],        [5. , 3.6, 1.4, 0.2],        [5.4, 3.9, 1.7, 0.4],        [4.6, 3.4, 1.4, 0.3],        [5. , 3.4, 1.5, 0.2],        [4.4, 2.9, 1.4, 0.2],        [4.9, 3.1, 1.5, 0.1],        [5.4, 3.7, 1.5, 0.2],        [4.8, 3.4, 1.6, 0.2],        [4.8, 3. , 1.4, 0.1],        [4.3, 3. , 1.1, 0.1],        [5.8, 4. , 1.2, 0.2],        [5.7, 4.4, 1.5, 0.4],        [5.4, 3.9, 1.3, 0.4],        [5.1, 3.5, 1.4, 0.3],        [5.7, 3.8, 1.7, 0.3],        [5.1, 3.8, 1.5, 0.3],        [5.4, 3.4, 1.7, 0.2],        [5.1, 3.7, 1.5, 0.4],        [4.6, 3.6, 1. , 0.2],        [5.1, 3.3, 1.7, 0.5],        [4.8, 3.4, 1.9, 0.2],        [5. , 3. , 1.6, 0.2],        [5. , 3.4, 1.6, 0.4],        [5.2, 3.5, 1.5, 0.2],        [5.2, 3.4, 1.4, 0.2],        [4.7, 3.2, 1.6, 0.2],        [4.8, 3.1, 1.6, 0.2],        [5.4, 3.4, 1.5, 0.4],        [5.2, 4.1, 1.5, 0.1],        [5.5, 4.2, 1.4, 0.2],        [4.9, 3.1, 1.5, 0.1],        [5. , 3.2, 1.2, 0.2],        [5.5, 3.5, 1.3, 0.2],        [4.9, 3.1, 1.5, 0.1],        [4.4, 3. , 1.3, 0.2],        [5.1, 3.4, 1.5, 0.2],        [5. , 3.5, 1.3, 0.3],        [4.5, 2.3, 1.3, 0.3],        [4.4, 3.2, 1.3, 0.2],        [5. , 3.5, 1.6, 0.6],        [5.1, 3.8, 1.9, 0.4],        [4.8, 3. , 1.4, 0.3],        [5.1, 3.8, 1.6, 0.2],        [4.6, 3.2, 1.4, 0.2],        [5.3, 3.7, 1.5, 0.2],        [5. , 3.3, 1.4, 0.2],        [7. , 3.2, 4.7, 1.4],        [6.4, 3.2, 4.5, 1.5],        [6.9, 3.1, 4.9, 1.5],        [5.5, 2.3, 4. , 1.3],        [6.5, 2.8, 4.6, 1.5],        [5.7, 2.8, 4.5, 1.3],        [6.3, 3.3, 4.7, 1.6],        [4.9, 2.4, 3.3, 1. ],        [6.6, 2.9, 4.6, 1.3],        [5.2, 2.7, 3.9, 1.4],        [5. , 2. , 3.5, 1. ],        [5.9, 3. , 4.2, 1.5],        [6. , 2.2, 4. , 1. ],        [6.1, 2.9, 4.7, 1.4],        [5.6, 2.9, 3.6, 1.3],        [6.7, 3.1, 4.4, 1.4],        [5.6, 3. , 4.5, 1.5],        [5.8, 2.7, 4.1, 1. ],        [6.2, 2.2, 4.5, 1.5],        [5.6, 2.5, 3.9, 1.1],        [5.9, 3.2, 4.8, 1.8],        [6.1, 2.8, 4. , 1.3],        [6.3, 2.5, 4.9, 1.5],        [6.1, 2.8, 4.7, 1.2],        [6.4, 2.9, 4.3, 1.3],        [6.6, 3. , 4.4, 1.4],        [6.8, 2.8, 4.8, 1.4],        [6.7, 3. , 5. , 1.7],        [6. , 2.9, 4.5, 1.5],        [5.7, 2.6, 3.5, 1. ],        [5.5, 2.4, 3.8, 1.1],        [5.5, 2.4, 3.7, 1. ],        [5.8, 2.7, 3.9, 1.2],        [6. , 2.7, 5.1, 1.6],        [5.4, 3. , 4.5, 1.5],        [6. , 3.4, 4.5, 1.6],        [6.7, 3.1, 4.7, 1.5],        [6.3, 2.3, 4.4, 1.3],        [5.6, 3. , 4.1, 1.3],        [5.5, 2.5, 4. , 1.3],        [5.5, 2.6, 4.4, 1.2],        [6.1, 3. , 4.6, 1.4],        [5.8, 2.6, 4. , 1.2],        [5. , 2.3, 3.3, 1. ],        [5.6, 2.7, 4.2, 1.3],        [5.7, 3. , 4.2, 1.2],        [5.7, 2.9, 4.2, 1.3],        [6.2, 2.9, 4.3, 1.3],        [5.1, 2.5, 3. , 1.1],        [5.7, 2.8, 4.1, 1.3],        [6.3, 3.3, 6. , 2.5],        [5.8, 2.7, 5.1, 1.9],        [7.1, 3. , 5.9, 2.1],        [6.3, 2.9, 5.6, 1.8],        [6.5, 3. , 5.8, 2.2],        [7.6, 3. , 6.6, 2.1],        [4.9, 2.5, 4.5, 1.7],        [7.3, 2.9, 6.3, 1.8],        [6.7, 2.5, 5.8, 1.8],        [7.2, 3.6, 6.1, 2.5],        [6.5, 3.2, 5.1, 2. ],        [6.4, 2.7, 5.3, 1.9],        [6.8, 3. , 5.5, 2.1],        [5.7, 2.5, 5. , 2. ],        [5.8, 2.8, 5.1, 2.4],        [6.4, 3.2, 5.3, 2.3],        [6.5, 3. , 5.5, 1.8],        [7.7, 3.8, 6.7, 2.2],        [7.7, 2.6, 6.9, 2.3],        [6. , 2.2, 5. , 1.5],        [6.9, 3.2, 5.7, 2.3],        [5.6, 2.8, 4.9, 2. ],        [7.7, 2.8, 6.7, 2. ],        [6.3, 2.7, 4.9, 1.8],        [6.7, 3.3, 5.7, 2.1],        [7.2, 3.2, 6. , 1.8],        [6.2, 2.8, 4.8, 1.8],        [6.1, 3. , 4.9, 1.8],        [6.4, 2.8, 5.6, 2.1],        [7.2, 3. , 5.8, 1.6],        [7.4, 2.8, 6.1, 1.9],        [7.9, 3.8, 6.4, 2. ],        [6.4, 2.8, 5.6, 2.2],        [6.3, 2.8, 5.1, 1.5],        [6.1, 2.6, 5.6, 1.4],        [7.7, 3. , 6.1, 2.3],        [6.3, 3.4, 5.6, 2.4],        [6.4, 3.1, 5.5, 1.8],        [6. , 3. , 4.8, 1.8],        [6.9, 3.1, 5.4, 2.1],        [6.7, 3.1, 5.6, 2.4],        [6.9, 3.1, 5.1, 2.3],        [5.8, 2.7, 5.1, 1.9],        [6.8, 3.2, 5.9, 2.3],        [6.7, 3.3, 5.7, 2.5],        [6.7, 3. , 5.2, 2.3],        [6.3, 2.5, 5. , 1.9],        [6.5, 3. , 5.2, 2. ],        [6.2, 3.4, 5.4, 2.3],        [5.9, 3. , 5.1, 1.8]]), &apos;feature_names&apos;: [&apos;sepal length (cm)&apos;,  &apos;sepal width (cm)&apos;,  &apos;petal length (cm)&apos;,  &apos;petal width (cm)&apos;], &apos;target&apos;: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), &apos;target_names&apos;: array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=&apos;&lt;U10&apos;)}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = iris.data</span><br><span class="line">target = iris.target</span><br><span class="line">target_names = iris.target_names</span><br><span class="line">feature_names = iris.feature_names</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">features = DataFrame(data=data,columns = feature_names)</span><br><span class="line">features.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">0</span>].std()</span><br></pre></td></tr></table></figure><pre><code>0.828066127977863</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">2</span>].std()</span><br></pre></td></tr></table></figure><pre><code>1.7644204199522626</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">1</span>].std()</span><br></pre></td></tr></table></figure><pre><code>0.4335943113621737</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features.iloc[:,<span class="number">3</span>].std()</span><br></pre></td></tr></table></figure><pre><code>0.7631607417008411</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># samples(训练集、测试集)</span></span><br><span class="line">X_train = features.iloc[:<span class="number">130</span>,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">y_train = target[:<span class="number">130</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集(验证训练模型的准确度)</span></span><br><span class="line">X_test = features.iloc[<span class="number">130</span>:,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">y_test = target[<span class="number">130</span>:]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display(X_train.shape,y_train.shape,X_test.shape,y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(130, 2)(130,)(20, 2)(20,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_names</span><br></pre></td></tr></table></figure><pre><code>array([&apos;setosa&apos;, &apos;versicolor&apos;, &apos;virginica&apos;], dtype=&apos;&lt;U10&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># （离散性的、标称型）目标值是不参与运算的，所以不是必须要转换成数字的格式</span></span><br><span class="line">target</span><br></pre></td></tr></table></figure><pre><code>array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><p>绘制图形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">samples = features.iloc[:,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示真实数据的分类情况</span></span><br><span class="line">plt.scatter(samples.iloc[:,<span class="number">0</span>],samples.iloc[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-2-feaf3557f814&gt; in &lt;module&gt;()      1 import matplotlib.pyplot as plt      2 get_ipython().run_line_magic(&apos;matplotlib&apos;, &apos;inline&apos;)----&gt; 3 samples = features.iloc[:,2:4]      4       5 # 展示真实数据的分类情况NameError: name &apos;features&apos; is not defined</code></pre><p>定义KNN分类器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>第一步，训练数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knnclf.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=5, p=2,           weights=&apos;uniform&apos;)</code></pre><p>第二步预测数据：，所预测的数据，自己创造，就是上面所显示图片的背景点  </p><p>生成预测数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模型准确度的评估</span></span><br><span class="line"><span class="comment"># 1. 测试样本及应该是随机的</span></span><br><span class="line"><span class="comment"># 2. 测试样本集数量不能太小</span></span><br><span class="line">y_ = knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_test</span><br></pre></td></tr></table></figure><pre><code>array([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_</span><br></pre></td></tr></table></figure><pre><code>array([2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有预测点（满屏幕的点）</span></span><br><span class="line">xmin,xmax = samples.iloc[:,<span class="number">0</span>].min(),samples.iloc[:,<span class="number">0</span>].max()</span><br><span class="line">ymin,ymax = samples.iloc[:,<span class="number">1</span>].min(),samples.iloc[:,<span class="number">1</span>].max()</span><br><span class="line"></span><br><span class="line">x = np.linspace(xmin,xmax,<span class="number">100</span>)</span><br><span class="line">y = np.linspace(ymin,ymax,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">xx,yy = np.meshgrid(x,y)</span><br><span class="line"></span><br><span class="line">X_test = np.c_[xx.ravel(),yy.ravel()]</span><br></pre></td></tr></table></figure><p>对数据进行预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_ = knnclf.predict(X_test)</span><br></pre></td></tr></table></figure><p>显示数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">cmap = ListedColormap([<span class="string">'#aa00ff'</span>,<span class="string">'#00aaff'</span>,<span class="string">'#ffaa00'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示预测数据的分类情况</span></span><br><span class="line">plt.scatter(X_test[:,<span class="number">0</span>],X_test[:,<span class="number">1</span>],c=y_,cmap=cmap)</span><br><span class="line"><span class="comment"># 展示真实数据的分类情况</span></span><br><span class="line">plt.scatter(samples.iloc[:,<span class="number">0</span>],samples.iloc[:,<span class="number">1</span>],c=target)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x189b2990&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201841319285.png" alt="Untitled-1-201841319285"></p><h3 id="2）用于回归"><a href="#2）用于回归" class="headerlink" title="2）用于回归"></a>2）用于回归</h3><p>回归用于对趋势的预测</p><p>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br></pre></td></tr></table></figure><p>生成样本数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一组符合正弦分布的数据</span></span><br><span class="line">x = np.linspace(-np.pi,np.pi,<span class="number">40</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"><span class="comment"># 原始数据的分布规律</span></span><br><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x19be92b0&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192811.png" alt="Untitled-1-2018413192811"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noise = np.random.random(size=<span class="number">20</span>) - <span class="number">0.5</span></span><br><span class="line">noise</span><br></pre></td></tr></table></figure><pre><code>array([-0.01419036, -0.05222776,  0.4114977 , -0.48535771,  0.4725629 ,        0.49193969, -0.4352523 , -0.48704335,  0.39377464, -0.32509247,        0.09969959, -0.10353899,  0.35402717,  0.09005099, -0.32349592,       -0.41517568,  0.13719123,  0.40893228,  0.25830619,  0.00900481])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[::<span class="number">2</span>] += noise</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x18594890&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192816.png" alt="Untitled-1-2018413192816"></p><p>生成测试数据的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train = x.reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y_train = y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">knn = KNeighborsRegressor(n_neighbors=<span class="number">7</span>)</span><br><span class="line">knn.fit(X_train,y_train)</span><br><span class="line"></span><br><span class="line">X_test = np.linspace(-np.pi,np.pi,<span class="number">100</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">y_ = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line">plt.plot(X_test,y_,color=<span class="string">'green'</span>)</span><br><span class="line">plt.scatter(X_train,y_train,color=<span class="string">'orange'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过拟合</span></span><br><span class="line"><span class="comment"># 欠拟合</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x19b872b0&gt;</code></pre><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192821.png" alt="Untitled-1-2018413192821"></p><p>第一步：生成模型，并训练数据</p><p>第二步：使用模型，预测数据</p><p>绘图显示数据</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>人类动作识别<br>步行，上楼，下楼，坐着，站立和躺着  </p><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413193022.jpg" alt="Untitled-1-2018413193022"><br>数据采集每个人在腰部穿着智能手机，进行了六个活动（步行，上楼，下楼，坐着，站立和躺着）。采用嵌入式加速度计和陀螺仪，以50Hz的恒定速度捕获3轴线性加速度和3轴角速度，来获取数据</p><p>导入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_train = np.load(<span class="string">'x_train.npy'</span>)</span><br><span class="line">y_train = np.load(<span class="string">'y_train.npy'</span>)</span><br><span class="line"></span><br><span class="line">X_test = np.load(<span class="string">'x_test.npy'</span>)</span><br><span class="line">y_test = np.load(<span class="string">'y_test.npy'</span>)</span><br><span class="line"></span><br><span class="line">display(X_train.shape,y_train.shape,X_test.shape,y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(7352, 561)(7352,)(2947, 561)(2947,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame(X_train).head(</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Series(y_train).unique()</span><br></pre></td></tr></table></figure><pre><code>array([5, 4, 6, 1, 3, 2], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label = &#123;<span class="number">1</span>:<span class="string">'WALKING'</span>, </span><br><span class="line">         <span class="number">2</span>:<span class="string">'WALKING UPSTAIRS'</span>, </span><br><span class="line">         <span class="number">3</span>:<span class="string">'WALKING DOWNSTAIRS'</span>,</span><br><span class="line">         <span class="number">4</span>:<span class="string">'SITTING'</span>, </span><br><span class="line">         <span class="number">5</span>:<span class="string">'STANDING'</span>, </span><br><span class="line">         <span class="number">6</span>:<span class="string">'LAYING'</span>&#125;</span><br></pre></td></tr></table></figure><p>获取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整算法参数只能对算法调优，不能决定算法的高度</span></span><br><span class="line">knnclf = KNeighborsClassifier(n_neighbors=<span class="number">9</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KNN在训练的时候，是不进行运算的（距离）</span></span><br><span class="line">knnclf.fit(X_train,y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,           metric_params=None, n_jobs=1, n_neighbors=9, p=2,           weights=&apos;uniform&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KNN在进行预测的时候，才开始计算训练集和测试集中样本点之间的距离</span></span><br><span class="line">y_ = knnclf.predict(X_test[:<span class="number">1000</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类算法的评分就是这么算的</span></span><br><span class="line">(y_ == y_test[:<span class="number">1000</span>]).sum()/y_.size</span><br></pre></td></tr></table></figure><pre><code>0.922</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算分类算法的评分</span></span><br><span class="line">knnclf.score(X_test[:<span class="number">500</span>],y_test[:<span class="number">500</span>])</span><br></pre></td></tr></table></figure><pre><code>0.928</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">8</span>))</span><br><span class="line">colors = [<span class="string">'red'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>,<span class="string">'cyan'</span>,<span class="string">'purple'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i)</span><br><span class="line">    title = label[i]</span><br><span class="line">    Series(X_train[y_train==i][<span class="number">0</span>]).plot(color=colors[i<span class="number">-1</span>],title=title)</span><br></pre></td></tr></table></figure><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-2018413192827.png" alt="Untitled-1-2018413192827"></p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WebSocket详细解析</title>
      <link href="/2018/04/10/websocket/"/>
      <url>/2018/04/10/websocket/</url>
      <content type="html"><![CDATA[<h3 id="你真的了解WebSocket吗？"><a href="#你真的了解WebSocket吗？" class="headerlink" title="你真的了解WebSocket吗？"></a>你真的了解WebSocket吗？</h3><p>  WebSocket协议是基于TCP的一种新的协议。WebSocket最初在HTML5规范中被引用为TCP连接，作为基于TCP的套接字API的占位符。它实现了浏览器与服务器全双工(full-duplex)通信。其本质是保持TCP连接，在浏览器和服务端通过Socket进行通信。</p><p> 本文将使用Python编写Socket服务端，一步一步分析请求过程！！！</p><h3 id="1-启动服务端"><a href="#1-启动服务端" class="headerlink" title="1.启动服务端"></a>1.启动服务端</h3><ul><li>启动服务器后，等待用户连接，然后进行收发数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&apos;127.0.0.1&apos;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"># 等待用户连接</span><br><span class="line">conn, address = sock.accept()</span><br></pre></td></tr></table></figure><h3 id="2-客户端连接"><a href="#2-客户端连接" class="headerlink" title="2.客户端连接"></a>2.客户端连接</h3><ul><li>当客户端向服务端发送连接请求时，不仅连接还会发送【握手】信息，并等待服务端响应，至此连接才创建成功！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var socket = new WebSocket(&quot;ws://127.0.0.1:8002/xxoo&quot;);</span><br><span class="line">    ...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-建立链接【握手】"><a href="#3-建立链接【握手】" class="headerlink" title="3.建立链接【握手】"></a>3.建立链接【握手】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&apos;127.0.0.1&apos;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"># 获取客户端socket对象</span><br><span class="line">conn, address = sock.accept()</span><br><span class="line"># 获取客户端的【握手】信息</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">conn.send(&apos;响应【握手】信息&apos;)</span><br></pre></td></tr></table></figure><p>请求和响应的【握手】信息需要遵循规则：</p><ul><li>从请求【握手】信息中提取 Sec-WebSocket-Key</li><li>利用magic_string 和 Sec-WebSocket-Key 进行hmac1加密，再进行base64加密</li><li>将加密结果响应给客户端<h4 id="注：magic-string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11"><a href="#注：magic-string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11" class="headerlink" title="注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11"></a>注：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11</h4></li></ul><p>请求【握手】信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /chatsocket HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8002</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http://localhost:63342</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: mnwFxiOlctXFN/DeMt1Amg==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><p>提取Sec-WebSocket-Key值并加密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import base64</span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">def get_headers(data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将请求头格式化成字典</span><br><span class="line">    :param data:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    header_dict = &#123;&#125;</span><br><span class="line">    data = str(data, encoding=&apos;utf-8&apos;)</span><br><span class="line"> </span><br><span class="line">    for i in data.split(&apos;\r\n&apos;):</span><br><span class="line">        print(i)</span><br><span class="line">    header, body = data.split(&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">    header_list = header.split(&apos;\r\n&apos;)</span><br><span class="line">    for i in range(0, len(header_list)):</span><br><span class="line">        if i == 0:</span><br><span class="line">            if len(header_list[i].split(&apos; &apos;)) == 3:</span><br><span class="line">                header_dict[&apos;method&apos;], header_dict[&apos;url&apos;], header_dict[&apos;protocol&apos;] = header_list[i].split(&apos; &apos;)</span><br><span class="line">        else:</span><br><span class="line">            k, v = header_list[i].split(&apos;:&apos;, 1)</span><br><span class="line">            header_dict[k] = v.strip()</span><br><span class="line">    return header_dict</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&apos;127.0.0.1&apos;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"> </span><br><span class="line">conn, address = sock.accept()</span><br><span class="line">data = conn.recv(1024)</span><br><span class="line">headers = get_headers(data) # 提取请求头信息</span><br><span class="line"># 对请求头中的sec-websocket-key进行加密</span><br><span class="line">response_tpl = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; \</span><br><span class="line">      &quot;Upgrade:websocket\r\n&quot; \</span><br><span class="line">      &quot;Connection: Upgrade\r\n&quot; \</span><br><span class="line">      &quot;Sec-WebSocket-Accept: %s\r\n&quot; \</span><br><span class="line">      &quot;WebSocket-Location: ws://%s%s\r\n\r\n&quot;</span><br><span class="line">magic_string = &apos;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&apos;</span><br><span class="line">value = headers[&apos;Sec-WebSocket-Key&apos;] + magic_string</span><br><span class="line">ac = base64.b64encode(hashlib.sha1(value.encode(&apos;utf-8&apos;)).digest())</span><br><span class="line">response_str = response_tpl % (ac.decode(&apos;utf-8&apos;), headers[&apos;Host&apos;], headers[&apos;url&apos;])</span><br><span class="line"># 响应【握手】信息</span><br><span class="line">conn.send(bytes(response_str, encoding=&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure><h3 id="4-客户端和服务端收发数据"><a href="#4-客户端和服务端收发数据" class="headerlink" title="4.客户端和服务端收发数据"></a>4.客户端和服务端收发数据</h3><p>详细原理：<a href="https://yuansuixin.github.io/2018/04/09/websocket-data/" title="解包和封包原理">解包和封包原理</a></p><p>客户端和服务端传输数据时，需要对数据进行【封包】和【解包】。客户端的JavaScript类库已经封装【封包】和【解包】过程，但Socket服务端需要手动实现。</p><p>第一步：获取客户端发送的数据【解包】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   info = conn.recv(8096)</span><br><span class="line"></span><br><span class="line">    payload_len = info[1] &amp; 127</span><br><span class="line">    if payload_len == 126:</span><br><span class="line">        extend_payload_len = info[2:4]</span><br><span class="line">        mask = info[4:8]</span><br><span class="line">        decoded = info[8:]</span><br><span class="line">    elif payload_len == 127:</span><br><span class="line">        extend_payload_len = info[2:10]</span><br><span class="line">        mask = info[10:14]</span><br><span class="line">        decoded = info[14:]</span><br><span class="line">    else:</span><br><span class="line">        extend_payload_len = None</span><br><span class="line">        mask = info[2:6]</span><br><span class="line">        decoded = info[6:]</span><br><span class="line"></span><br><span class="line">    bytes_list = bytearray()</span><br><span class="line">    for i in range(len(decoded)):</span><br><span class="line">        chunk = decoded[i] ^ mask[i % 4]</span><br><span class="line">        bytes_list.append(chunk)</span><br><span class="line">    body = str(bytes_list, encoding=&apos;utf-8&apos;)</span><br><span class="line">    print(body)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p> 第二步：向客户端发送数据【封包】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def send_msg(conn, msg_bytes):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    WebSocket服务端向客户端发送消息</span><br><span class="line">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span><br><span class="line">    :param msg_bytes: 向客户端发送的字节</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import struct</span><br><span class="line"></span><br><span class="line">    token = b&quot;\x81&quot;</span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    if length &lt; 126:</span><br><span class="line">        token += struct.pack(&quot;B&quot;, length)</span><br><span class="line">    elif length &lt;= 0xFFFF:</span><br><span class="line">        token += struct.pack(&quot;!BH&quot;, 126, length)</span><br><span class="line">    else:</span><br><span class="line">        token += struct.pack(&quot;!BQ&quot;, 127, length)</span><br><span class="line"></span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><p><a href="https://github.com/yuansuixin/WebSocket" title="基于Python的简单示例" target="_blank" rel="noopener">基于Python的简单示例</a></p><p><a href="https://github.com/yuansuixin/WebSocket-Tornado-Chat" title="基于Tornado框架的Web聊天室" target="_blank" rel="noopener">基于Tornado框架的Web聊天室</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/04/10/jupyter/"/>
      <url>/2018/04/10/jupyter/</url>
      <content type="html"><![CDATA[<hr><p>title: jupyter-notebook 快捷方式<br>date: 2017-11-20 12:32:50<br>categories:</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><blockquote><p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。<br>Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。–百度百科</p></blockquote><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>Jupyter笔记本有两种不同的键盘输入模式，<strong>编辑模式</strong> 允许将代码或文本输入到单元格，并以绿色单元格边框表示。<strong>命令行模式</strong> 允许输入各种命令，并有具有蓝色左边框的灰色单元格边框表示。</p><p>从命令行模式进入编辑模式按<code>Enter</code>键，从编辑模式切换到命令行模式按<code>Esc</code>键。</p><p>下表将对快捷键做简单的说明：</p><h2 id="命令行模式快捷键（按Esc键开启）"><a href="#命令行模式快捷键（按Esc键开启）" class="headerlink" title="命令行模式快捷键（按Esc键开启）"></a>命令行模式快捷键（按Esc键开启）</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>F</td><td>寻找和替换</td><td></td></tr><tr><td>Ctrl-Shift-F</td><td>打开命令调色板</td><td></td></tr><tr><td>Ctrl-Shift-P</td><td>打开命令调色板</td><td></td></tr><tr><td>Enter</td><td>转入编辑模式</td><td></td></tr><tr><td>P</td><td>打开命令调色板</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下个单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在其下插入新单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Y</td><td>单元转入代码状态</td><td></td></tr><tr><td>M</td><td>单元转入 markdown 状态</td><td></td></tr><tr><td>R</td><td>单元转入 raw 状态</td><td></td></tr><tr><td>1</td><td>设定 1 级标题</td><td>仅在 markdown 状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到 markdown 状态</td></tr><tr><td>2</td><td>设定 2 级标题</td><td></td></tr><tr><td>3</td><td>设定 3 级标题</td><td></td></tr><tr><td>4</td><td>设定 4 级标题</td><td></td></tr><tr><td>5</td><td>设定 5 级标题</td><td></td></tr><tr><td>6</td><td>设定 6 级标题</td><td></td></tr><tr><td>K</td><td>选中上方单元</td><td></td></tr><tr><td>Up</td><td>选中上方单元</td><td></td></tr><tr><td>Down</td><td>选中下方单元</td><td></td></tr><tr><td>J</td><td>选中下方单元</td><td></td></tr><tr><td>Shift-Down</td><td>扩展下面的选定单元格</td><td></td></tr><tr><td>Shift-J</td><td>扩展下面的选定单元格</td><td></td></tr><tr><td>Shift-K</td><td>连续选择上方单元</td><td></td></tr><tr><td>Shift-J</td><td>连续选择下方单元</td><td></td></tr><tr><td>A</td><td>在上方插入新单元</td><td></td></tr><tr><td>B</td><td>在下方插入新单元</td><td></td></tr><tr><td>X</td><td>剪切选中的单元</td><td></td></tr><tr><td>C</td><td>复制选中的单元</td><td></td></tr><tr><td>Shift-V</td><td>粘贴到上方单元</td><td></td></tr><tr><td>V</td><td>粘贴到下方单元</td><td></td></tr><tr><td>Z</td><td>恢复删除的最后一个单元</td><td></td></tr><tr><td>D,D</td><td>删除选中的单元</td><td>连续按两个 D 键</td></tr><tr><td>Shift-M</td><td>合并选中的单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>L</td><td>开关行号</td><td>编辑框的行号是可以开启和关闭的</td></tr><tr><td>O</td><td>转换输出</td><td></td></tr><tr><td>Shift-O</td><td>转换输出滚动</td><td></td></tr><tr><td>H</td><td>显示快捷键帮助</td><td></td></tr><tr><td>I,I</td><td>中断 NoteBook 内核</td><td></td></tr><tr><td>0,0</td><td>重启 NoteBook 内核</td><td></td></tr><tr><td>Esc</td><td>关闭页面</td><td></td></tr><tr><td>Q</td><td>关闭页面</td><td></td></tr><tr><td>Shift-L</td><td>切换所有单元格中的行号，并坚持设置</td><td></td></tr><tr><td>Shift-Space</td><td>向上滚动</td><td></td></tr><tr><td>Space</td><td>向下滚动</td></tr></tbody></table><h2 id="编辑模式快捷键（按Enter键启动）"><a href="#编辑模式快捷键（按Enter键启动）" class="headerlink" title="编辑模式快捷键（按Enter键启动）"></a>编辑模式快捷键（按Enter键启动）</h2><table><thead><tr><th>快捷键</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>快捷键</td><td>作用</td><td>说明</td></tr><tr><td>Tab</td><td>代码补全或缩进</td><td></td></tr><tr><td>Shift-Tab</td><td>提示</td><td>输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加 ? 再运行会显示更加详细的帮助</td></tr><tr><td>Ctrl-]</td><td>缩进向右缩进</td><td></td></tr><tr><td>Ctrl-[</td><td>解除缩进</td><td>向左缩进</td></tr><tr><td>Ctrl-A</td><td>全选</td><td></td></tr><tr><td>Ctrl-Z</td><td>撤销</td><td></td></tr><tr><td>Ctrl-D</td><td>删除整行</td><td></td></tr><tr><td>Ctrl-U</td><td>撤消选择</td><td></td></tr><tr><td>Insert</td><td>切换覆盖标志</td><td></td></tr><tr><td>Ctrl-Home</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-Up</td><td>跳到单元开头</td><td></td></tr><tr><td>Ctrl-End</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Down</td><td>跳到单元末尾</td><td></td></tr><tr><td>Ctrl-Left</td><td>跳到左边一个字首</td><td></td></tr><tr><td>Ctrl-Right</td><td>跳到右边一个字首</td><td></td></tr><tr><td>Ctrl-Backspace</td><td>删除前面一个字</td><td></td></tr><tr><td>Ctrl-Delete</td><td>删除后面一个字</td><td></td></tr><tr><td>Ctrl-Y</td><td>重做</td><td></td></tr><tr><td>Ctrl-Shift-Z</td><td>重做</td><td></td></tr><tr><td>Esc</td><td>切换到命令模式</td><td></td></tr><tr><td>Ctrl-M</td><td>切换到命令模式</td><td></td></tr><tr><td>Shift-Enter</td><td>运行本单元，选中下一单元</td><td>新单元默认为命令模式</td></tr><tr><td>Ctrl-Enter</td><td>运行本单元</td><td></td></tr><tr><td>Alt-Enter</td><td>运行本单元，在下面插入一单元</td><td>新单元默认为编辑模式</td></tr><tr><td>Ctrl-Shift–</td><td>分割单元</td><td>按光标所在行进行分割</td></tr><tr><td>Ctrl-Shift-Subtract</td><td>分割单元</td><td></td></tr><tr><td>Ctrl-S</td><td>保存当前 NoteBook</td><td></td></tr><tr><td>Shift</td><td>忽略</td><td></td></tr><tr><td>Up</td><td>光标上移或转入上一单元</td><td></td></tr><tr><td>Down</td><td>光标下移或转入下一单元</td><td></td></tr><tr><td>Ctrl-/</td><td>注释整行/撤销注释</td><td>仅代码状态有效</td></tr></tbody></table><h5 id="【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等"><a href="#【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等" class="headerlink" title="【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等"></a><strong>【注】快捷键可能会被系统中的其他应用占用，如：搜狗输入法等</strong></h5>]]></content>
      
      
    </entry>
    
    <entry>
      <title>WebSocket传输数据服务端的封包解包原理</title>
      <link href="/2018/04/09/websocket-data/"/>
      <url>/2018/04/09/websocket-data/</url>
      <content type="html"><![CDATA[<h1 id="WebSocket传输数据服务端的封包解包原理"><a href="#WebSocket传输数据服务端的封包解包原理" class="headerlink" title="WebSocket传输数据服务端的封包解包原理"></a>WebSocket传输数据服务端的封包解包原理</h1><p>  客户端和服务端传输数据时，需要对数据进行【封包】和【解包】。客户端的JavaScript类库已经封装【封包】和【解包】过程，但Socket服务端需要手动实现。</p><blockquote><p>获取客户端发送的数据【解包】</p></blockquote><ul><li>获取到的客户端的数据不能直接拿到，需要通过位运算，里面的东西都有代指的，第几位代表什么，</li><li>规则<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201849223212.png" alt="Untitled-1-201849223212"><ul><li>以客户端发送的hello为例，服务端接收到<code>info=&quot;b&#39;\x88\x82\x08j\xe8\x00\x0b\x83&#39;&quot;</code></li><li>服务端拿到的都是字节，那么info[0]就是第一个字节，也就是八位</li><li>通过规则图可以知道，我们要计算出来opcode的值</li><li>我们就需要计算出来第一个字节的后四位的值，那么怎么才能拿到后四位的值呢，就是和1111进行与运算，也就是和15进行与计算<code>opcode=info[0] &amp; 15</code>,那么这个值最大为15</li><li>我们需要计算出图中的fin，向右移7位就可以得到，同理得到其他的值</li><li>opcode及之前的fin等这两个字节是用来判断发送的内容是否发送完毕，如果没发完继续收，等全部内容发完，再统一的解码</li><li>同样的道理我们要计算出payload_len,payload_len需要得到第二个字节的八位，那么和11111111进行与运算可以得到<code>payload_len=info[1]&amp;127</code>,那么这个值最大为127</li><li>payload_len 的长度决定了它（数据头）再往后会占多少<ul><li>小于126，数据头到payload_len就结束了</li><li>等于126，数据头再往后延伸2个字节，头部总共占4个字节</li><li>大于126，数据头再往后延伸8个字节，头部总共占10个字节</li></ul></li><li>数据头部是数据部分，数据部分的前4个字节都是加密的masking key，我们需要解密才能拿到真正的数据</li></ul></li></ul><ul><li>代码部分：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">info = conn.recv(8096)</span><br><span class="line"></span><br><span class="line">payload_len = info[1] &amp; 127</span><br><span class="line">if payload_len == 126:</span><br><span class="line">    #数据头部延伸的长度</span><br><span class="line">    extend_payload_len = info[2:4]</span><br><span class="line">    #加密的4个字节</span><br><span class="line">    mask = info[4:8]</span><br><span class="line">    #数据</span><br><span class="line">    decoded = info[8:]</span><br><span class="line">elif payload_len == 127:</span><br><span class="line">    extend_payload_len = info[2:10]</span><br><span class="line">    mask = info[10:14]</span><br><span class="line">    decoded = info[14:]</span><br><span class="line">else:</span><br><span class="line">    extend_payload_len = None</span><br><span class="line">    mask = info[2:6]</span><br><span class="line">    decoded = info[6:]</span><br><span class="line"></span><br><span class="line">bytes_list = bytearray()</span><br><span class="line">for i in range(len(decoded)):</span><br><span class="line">    chunk = decoded[i] ^ mask[i % 4]</span><br><span class="line">    bytes_list.append(chunk)</span><br><span class="line">body = str(bytes_list, encoding=&apos;utf-8&apos;)</span><br><span class="line">print(body)</span><br></pre></td></tr></table></figure><ul><li>规则文档</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1\. (In fact, [section 5.1 of the spec](http://tools.ietf.org/html/rfc6455#section-5.1) says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We&apos;ll explain masking later. _Note: You have to mask messages even when using a secure socket._RSV1-3 can be ignored, they are for extensions.</span><br><span class="line"></span><br><span class="line">The opcode field defines how to interpret the payload data: 0x0 for continuation, `0x1` for text (which is always encoded in UTF-8), `0x2` for binary, and other so-called &quot;control codes&quot; that will be discussed later. In this version of WebSockets, `0x3` to `0x7` and `0xB` to `0xF` have no meaning.</span><br><span class="line"></span><br><span class="line">The FIN bit tells whether this is the last message in a series. If it&apos;s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later.</span><br><span class="line"></span><br><span class="line">**Decoding Payload Length**</span><br><span class="line"></span><br><span class="line">To read the payload data, you must know when to stop reading. That&apos;s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps:</span><br><span class="line"></span><br><span class="line">1.  Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it&apos;s 125 or less, then that&apos;s the length; you&apos;re **done**. If it&apos;s 126, go to step 2\. If it&apos;s 127, go to step 3.</span><br><span class="line">2.  Read the next 16 bits and interpret those as an unsigned integer. You&apos;re **done**.</span><br><span class="line">3.  Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You&apos;re **done**.</span><br><span class="line"></span><br><span class="line">**Reading and Unmasking the Data**</span><br><span class="line"></span><br><span class="line">If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let&apos;s call the data **ENCODED**, and the key **MASK**. To get **DECODED**, loop through the octets (bytes a.k.a. characters for text data) of **ENCODED** and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript):</span><br><span class="line"></span><br><span class="line">var DECODED = &quot;&quot;;</span><br><span class="line">for (var i = 0; i &lt; ENCODED.length; i++) &#123;</span><br><span class="line">    DECODED[i] = ENCODED[i] ^ MASK[i % 4];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Now you can figure out what **DECODED** means depending on your application.</span><br></pre></td></tr></table></figure><ul><li>解密<ul><li>使用masking key ，从后面一个一个的拿数据，然后一个一个的解</li><li>注意：如果有中文，直接解码为字节，然后全部的字节统一转化成字符串，否则使用一个一个解码放入字符中容易乱码</li></ul></li></ul><blockquote><p>向客户端发送数据【封包】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#msg_bytes这个是给用户返回的字节</span><br><span class="line">def send_msg(conn, msg_bytes):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    WebSocket服务端向客户端发送消息</span><br><span class="line">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()</span><br><span class="line">    :param msg_bytes: 向客户端发送的字节</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 封二进制包使用</span><br><span class="line">    import struct</span><br><span class="line"></span><br><span class="line">    token = b&quot;\x81&quot;</span><br><span class="line">    length = len(msg_bytes)</span><br><span class="line">    #打包规则</span><br><span class="line">    if length &lt; 126:</span><br><span class="line">        token += struct.pack(&quot;B&quot;, length)</span><br><span class="line">    elif length &lt;= 0xFFFF:</span><br><span class="line">        token += struct.pack(&quot;!BH&quot;, 126, length)</span><br><span class="line">    else:</span><br><span class="line">        token += struct.pack(&quot;!BQ&quot;, 127, length)</span><br><span class="line"></span><br><span class="line">    msg = token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><ul><li>位运算，右移动  &gt;&gt;<ul><li>10010001</li><li>右移4:00001001  前面补0</li><li>左移4：100100010000  后面补0</li></ul></li><li>异或运算，向异取1<ul><li>都是1： 0</li><li>0,1： 1</li><li>0,0:  0</li></ul></li><li>与运算<ul><li>一个字节八位，如果要后四位的值那么就设计一个值和原值进行与运算结果还是后四位</li><li>0 0 0 0 0 0 0 0 要取后四位的值，只需要和00001111进行与运算，前面的四位为0000忽略掉，即可得到后四位还是0000</li></ul></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>使用Tornado自定义Session组件</title>
      <link href="/2018/04/05/tornado-session/"/>
      <url>/2018/04/05/tornado-session/</url>
      <content type="html"><![CDATA[<p>最近又看了看tornado框架，写了一个自定义的组件。一直没时间上传，今天终于可以和大家见面了，对了，大家在和本文亲密之前需要先预热一下哦~:stuck_out_tongue::stuck_out_tongue::stuck_out_tongue:</p><p><a href="https://yuansuixin.github.io/2018/03/30/tornado-session-py/" title="预热">预热</a></p><h2 id="Tornado的自定义session组件"><a href="#Tornado的自定义session组件" class="headerlink" title="Tornado的自定义session组件"></a>Tornado的自定义session组件</h2><h4 id="1-session会话技术"><a href="#1-session会话技术" class="headerlink" title="1. session会话技术"></a>1. session会话技术</h4><ul><li><p>既然咱们要说一说session，那么必然要知道session是什么，接下来让我们一同了解一下session吧！</p><ul><li>Session 是服务器保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</li><li><p>Cookie 是客户端保存用户信息的一个机制，用来记录用户的一些信息，也是实现Session的一个方式，存储在用户的浏览器中</p><p><a href="https://yuansuixin.github.io/2018/02/12/cookie-session/" title="cookie和session会话技术详细讲解">cookie和session会话技术详细讲解</a></p></li></ul></li></ul><h4 id="2-自定义session原理解析"><a href="#2-自定义session原理解析" class="headerlink" title="2. 自定义session原理解析"></a>2. 自定义session原理解析</h4><p>我们先来看看tornado的基础程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br><span class="line"></span><br><span class="line">settings = &#123;</span><br><span class="line">    &apos;template_path&apos;: &apos;views&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&apos;/index&apos;, MainHandler),</span><br><span class="line">], **settings)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><ul><li><p>我们会发现当请求来的时候，就会调用get()方法，那么大家想一下，这个get()方法的调用是不是需要MainHandler对象来调用，如果没有对象，MainHandler里面的get()根本就调用不了，</p></li><li><p>所以肯定是要先创建对象，要创建对象那么一定要执行<code>__init__()</code>方法，然而我们没有写<code>__init__()</code>方法，那怎么办呢，这时候我们准备的知识点就用到啦，需要到父类中去查找，也就是RequestHandler类的<code>__init__()</code>,</p></li><li>我们可以看到RequestHandler类的<code>__init__()</code>，也就是说，在调用这个get（）方法之前肯定要调用<code>__init__()</code>方法，也就是说只要在<code>__init__()</code>方法中写入的东西都是get（）或者post（）方法之前的。</li><li><p>我们可以发现在<code>__init__()</code>方法的最后调用了 <code>self.initialize(**kwargs)</code>然而，这个方法什么都没写，也就是给我们预留的添加自己的操作的方法，我们将从这里入手</p></li><li><p>通过继承的机制我们可以知道要向给handler添加自己的东西，有两种写法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">第一种：多继承</span><br><span class="line">class Foo(object):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.A = 123</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line">class MainHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        print(self.A)</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br><span class="line">第二种：常规写法</span><br><span class="line">class Foo(tornado.web.RequestHandler):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.A = 123</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line">class MainHandler(Foo):</span><br><span class="line">    def get(self):</span><br><span class="line">        print(self.A)</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>因为Python是支持多继承的，所以我们将以多继承的这种方式进行解析</p></blockquote><ul><li>我们模拟Django的session来说，登录账号之后，session就自动的帮我们写到了服务器上了，我们要开源这个组件就需要让用户感知起来非常的方便，所以，我们以后就想让用户这样写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session[&apos;xxx&apos;] = &apos;dfdafdasfd&apos;</span><br></pre></td></tr></table></figure><ul><li><p>所以我们需要做这些事情，而且我们需要【】这样取值，我们首先想到的类型就是字典，没错，字典是这样取值，但是我们提前的知识点可不是白学的呦，使用<code>__setitem__()</code>魔法方法就可以呦，为了后面的额步骤,我们选择可以使用类。</p><ol><li>生成随机字符串</li><li>写到用户cookie</li><li>后台存储</li></ol></li><li><p>大家应该还记得MainHandler里面有self.set_cookie()函数，我们需要使用这个函数将session_id 写入cookie中，然而Foo类中的self就是MainHandler对象，所以我们只需要将self传入Bar就可以了</p></li><li><p>将session写入数据库，我们先使用一个字典充当数据库</p></li></ul><h4 id="3-写自定义的session代码"><a href="#3-写自定义的session代码" class="headerlink" title="3. 写自定义的session代码"></a>3. 写自定义的session代码</h4><ul><li>我们按照我们分析的原理将代码写出来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">import time</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"># 存储session数据</span><br><span class="line">container=&#123;</span><br><span class="line">    &apos;asdf&apos;:&#123;&apos;k&apos;:&apos;v&apos;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar():</span><br><span class="line">    # self，谁调用这个函数，self就是谁</span><br><span class="line">    #这个self就是MainHandler对象，可以将这个self传递给Bar（）</span><br><span class="line">    def __init__(self,handler):</span><br><span class="line">        self.handler = handler</span><br><span class="line">        self.random_str = None</span><br><span class="line">        # 去用户请求信息中获取session_id ，如果没有就是新用户或者是没有登陆</span><br><span class="line">        client_random_str = self.handler.get_cookie(&apos;session_id&apos;)</span><br><span class="line">        if not client_random_str:</span><br><span class="line">            # 新用户</span><br><span class="line">            self.random_str = self.create_random_str()</span><br><span class="line">            # 添加到数据库中一个数据</span><br><span class="line">            container[self.random_str]=&#123;&#125;</span><br><span class="line">        else:</span><br><span class="line">            # 判断是否是合法的session</span><br><span class="line">            if client_random_str in container:</span><br><span class="line">                # 老用户</span><br><span class="line">                self.random_str = client_random_str</span><br><span class="line">            else:</span><br><span class="line">                # 非法用户</span><br><span class="line">                self.random_str = self.create_random_str()</span><br><span class="line">        # 设置更新时间]</span><br><span class="line">        ctime = time.time()</span><br><span class="line">        self.handler.set_cookie(&apos;session_id&apos;,self.random_str,expires=ctime+1800) # 超时时间</span><br><span class="line"></span><br><span class="line"> # 生成随机的字符串,md5摘要</span><br><span class="line">    def create_random_str(self):</span><br><span class="line">        v = str(time.time())</span><br><span class="line">        m = hashlib.md5()</span><br><span class="line">        m.update(bytes(v,encoding=&apos;utf-8&apos;))</span><br><span class="line">        return m.hexdigest()</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        container[self.random_str][key] = value</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        return container[self.random_str].get(key)</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        del container[self.random_str][key]</span><br><span class="line"></span><br><span class="line">    #清空</span><br><span class="line">    def clear(self):</span><br><span class="line">        del container[self.random_str]</span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.session = Bar(self)</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line"></span><br><span class="line">class HomeHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        print(&apos;home&apos;)</span><br><span class="line">        user = self.session[&apos;uuuu&apos;]</span><br><span class="line">        if not user:</span><br><span class="line">            self.redirect(&apos;https://www.baidu.com&apos;)</span><br><span class="line">        else:</span><br><span class="line">            self.write(user)</span><br><span class="line"></span><br><span class="line">class LoginHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.session[&apos;uuuu&apos;] = &apos;root&apos;</span><br><span class="line">        self.redirect(&apos;/home&apos;)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&apos;/login&apos;, LoginHandler),</span><br><span class="line">    (r&apos;/home&apos;, HomeHandler),</span><br><span class="line">],)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><h4 id="4-存储session"><a href="#4-存储session" class="headerlink" title="4. 存储session"></a>4. 存储session</h4><ul><li>我们将session放到了一个字典里，只是放到了内存里，然而我们不想放内存里怎么办呢？为了提高用户的需求的灵活性，我们可以将存储使用类实现，使其可以放入缓存，内存，数据库等你想放的地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">import time</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">class Cache(object):</span><br><span class="line">    def __int__(self):</span><br><span class="line">        self.container = &#123;&#125;</span><br><span class="line">    def __contains__(self, item):</span><br><span class="line">        return  item in self.container</span><br><span class="line">    def open(self):</span><br><span class="line">        pass</span><br><span class="line">    def initial(self,random_str):</span><br><span class="line">        self.container[random_str] = &#123;&#125;</span><br><span class="line">    def close(self):</span><br><span class="line">        pass</span><br><span class="line">    def get(self,random_str,key):</span><br><span class="line">        self.container[random_str].get(key)</span><br><span class="line">    def set(self,random_str,key,value):</span><br><span class="line">        self.container[random_str][key] = value</span><br><span class="line">    def delete(self,random_str,key):</span><br><span class="line">        del self.container[random_str][key]</span><br><span class="line">    def clear(self,random_str,):</span><br><span class="line">        del self.container[random_str]</span><br><span class="line"></span><br><span class="line">class Memcache(object):</span><br><span class="line">    def __int__(self):</span><br><span class="line">        self.container = &#123;&#125;</span><br><span class="line">    # 适用性更广考虑才加上的open（）和close（）函数，更严谨</span><br><span class="line">    def open(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        pass</span><br><span class="line">    def get(self):</span><br><span class="line">        pass</span><br><span class="line">    def set(self):</span><br><span class="line">        pass</span><br><span class="line">    def delete(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"># 是为了方便更换，想放入什么里面直接更改这个引用就可以</span><br><span class="line">P = Cache</span><br><span class="line"></span><br><span class="line">class Session():</span><br><span class="line">    # self，谁调用这个函数，self就是谁</span><br><span class="line">    #这个self就是MainHandler对象，可以将这个self传递给Bar（）</span><br><span class="line">    def __init__(self,handler):</span><br><span class="line">        self.handler = handler</span><br><span class="line">        self.random_str = None</span><br><span class="line">        self.ppp = P()</span><br><span class="line">        self.ppp.open()</span><br><span class="line"></span><br><span class="line">        # 去用户请求信息中获取session_id ，如果没有就是新用户或者是没有登陆</span><br><span class="line">        client_random_str = self.handler.get_cookie(&apos;session_id&apos;)</span><br><span class="line">        if not client_random_str:</span><br><span class="line">            # 新用户</span><br><span class="line">            self.random_str = self.create_random_str()</span><br><span class="line">            # 添加到数据库中一个数据</span><br><span class="line">            self.ppp.initial(self.random_str)</span><br><span class="line">        else:</span><br><span class="line">            # 判断是否是合法的session</span><br><span class="line">            if client_random_str in self.ppp:</span><br><span class="line">                # 老用户</span><br><span class="line">                self.random_str = client_random_str</span><br><span class="line">            else:</span><br><span class="line">                # 非法用户</span><br><span class="line">                self.random_str = self.create_random_str()</span><br><span class="line">                # 添加一个数据</span><br><span class="line">                self.ppp.initial(self.random_str)</span><br><span class="line">        # 设置更新时间</span><br><span class="line">        ctime = time.time()</span><br><span class="line">        self.handler.set_cookie(&apos;session_id&apos;,self.random_str,expires=ctime+1800) # 超时时间</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> # 生成随机的字符串,md5摘要</span><br><span class="line">    def create_random_str(self):</span><br><span class="line">        v = str(time.time())</span><br><span class="line">        m = hashlib.md5()</span><br><span class="line">        m.update(bytes(v,encoding=&apos;utf-8&apos;))</span><br><span class="line">        return m.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        self.ppp.set(self.random_str,key,value)</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        v = self.ppp.get(self.random_str,key)</span><br><span class="line">        self.ppp.close()</span><br><span class="line">        return v</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        self.ppp.delete(self.random_str,key)</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line">    #清空</span><br><span class="line">    def clear(self):</span><br><span class="line">        self.ppp.open()</span><br><span class="line">        self.ppp.clear(self.random_str,)</span><br><span class="line">        self.ppp.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    def initialize(self):</span><br><span class="line">        self.session = Session(self)</span><br><span class="line">        super(Foo,self).initialize()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HomeHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self, *args, **kwargs):</span><br><span class="line">        print(&apos;home&apos;)</span><br><span class="line">        user = self.session[&apos;uuuu&apos;]</span><br><span class="line">        if not user:</span><br><span class="line">            self.redirect(&apos;https://www.baidu.com&apos;)</span><br><span class="line">        else:</span><br><span class="line">            self.write(user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LoginHandler(Foo,tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.session[&apos;uuuu&apos;] = &apos;root&apos;</span><br><span class="line">        self.redirect(&apos;/home&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (r&apos;/login&apos;, LoginHandler),</span><br><span class="line">    (r&apos;/home&apos;, HomeHandler),</span><br><span class="line">],)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><ul><li>这样我们的自定义session会话就完成啦，快快使用一下吧！:yum:</li></ul><blockquote><p>有什么不正确的地方欢迎指点哟！:kissing_heart:<br>邮箱：<a href="mailto:cyss428@163.com" target="_blank" rel="noopener">cyss428@163.com</a></p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Python零散的小知识点</title>
      <link href="/2018/03/30/tornado-session-py/"/>
      <url>/2018/03/30/tornado-session-py/</url>
      <content type="html"><![CDATA[<ul><li><p>注意：本节小知识点都是为tornado自定义session准备的！</p></li><li><p>多继承是先执行左边的，再依次向右，继承的一些知识点，太过基础了，这里我就不赘述了</p></li><li>super是按照顺序查找，也可以不让他按顺序查找，就是使用<code>类名.方法名（self）</code></li><li><p>对象调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = Foo()</span><br><span class="line">obj.f1()</span><br><span class="line">上面是对象自动将对象本身传递给方法，我们也可以手动的传递，就相当于</span><br><span class="line">obj = Foo()</span><br><span class="line">Foo.f1(obj)</span><br></pre></td></tr></table></figure></li><li><p>self是什么？self永远是调用这个方法的对象，</p></li></ul><ul><li><p>使用session[‘xx’]=’fdas’这种键值方式的语法，Python就会自动调用<code>__setitem（）__</code>魔法方法，也就是说并不是只有字典可以使用键值的方式调用，所有类都可以，只是加上这个对应的魔法方法即可</p></li><li><p>Python中的in操作符的时候会自动调用<code>__contains__()</code>魔法方法</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>github可以添加表情啦~</title>
      <link href="/2018/03/22/github/"/>
      <url>/2018/03/22/github/</url>
      <content type="html"><![CDATA[<h3 id="提升github的逼格"><a href="#提升github的逼格" class="headerlink" title="提升github的逼格"></a>提升github的逼格</h3><h5 id="github上可以添加表情啦，"><a href="#github上可以添加表情啦，" class="headerlink" title="github上可以添加表情啦，"></a>github上可以添加表情啦，</h5><ul><li><p>在github上插入表情的使用方法：</p><ul><li>使用方法为前后冒号包围表情代号的句法。<figure class="highlight plain"><figcaption><span>会显示成对应的表情，所以你在提交代码的时候可以这样写提交信息：`</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git commit –m ‘commit some changes :blush:’</span><br><span class="line">\</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表情列表</p></li></ul><p><a href="https://github.com/yuansuixin/emoji-list" target="_blank" rel="noopener">表情大全</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>会话技术cookie和session的区别和联系</title>
      <link href="/2018/02/12/cookie-session/"/>
      <url>/2018/02/12/cookie-session/</url>
      <content type="html"><![CDATA[<h1 id="COOKIE-和-SESSION-有什么区别和联系"><a href="#COOKIE-和-SESSION-有什么区别和联系" class="headerlink" title="COOKIE 和 SESSION 有什么区别和联系"></a>COOKIE 和 SESSION 有什么区别和联系</h1><ul><li><p>存储位置</p><ul><li>cookie 保存在客户端中</li><li>session 保存在服务器端</li></ul></li><li><p>Session 是服务器保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</p></li><li>Cookie 是客户端保存用户信息的一个机制，用来记录用户的一些信息，也是实现Session的一个方式，用于存储session_id ,存储在用户的浏览器中</li></ul><h2 id="不要混淆-cookie-和-session-实现"><a href="#不要混淆-cookie-和-session-实现" class="headerlink" title="不要混淆 cookie 和 session 实现"></a>不要混淆 cookie 和 session 实现</h2><ul><li>本身 session 是一个抽象的概念，将user agent 和server 之前一对一的交互，抽象为’会话‘，进而衍生出’会话状态‘，也就是session的概念</li><li>而 cookie 是一个实际存在的东西，http 协议中定义在header中的字段，可以认为是 session 的后端无状态实现</li><li>现在的 session ，是为了绕开 cookie 的各种限制，通常借助与cookie本身和后端存储实现的，一种更高级的状态实现</li></ul><ul><li>session、cookie、token会话技术</li></ul><p><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-201833011500.png" alt="会话"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jupyter（IPython）相关知识点</title>
      <link href="/2018/02/03/ipython/"/>
      <url>/2018/02/03/ipython/</url>
      <content type="html"><![CDATA[<h2 id="一、启动程序"><a href="#一、启动程序" class="headerlink" title="一、启动程序"></a>一、启动程序</h2><p>执行以下命令：</p><blockquote><p>jupyter notebook</p></blockquote><p>[NotebookApp] Serving notebooks from local directory: /home/nanfengpo</p><p>[NotebookApp] 0 active kernels </p><p>[NotebookApp] The IPython Notebook is running at: <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p><p>[NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</p><p>注意以下几点：</p><ul><li>打开地址为当前bash的目录，默认的根目录</li><li>浏览器地址为<a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></li><li>通过control -C终止jupyter程序</li></ul><p>几个基本操作：</p><ul><li>双击D：删除当前cell</li><li>单击M：转为markdown文档</li><li>markdown文档下运行变为预览模式</li></ul><h2 id="二、IPython的帮助文档"><a href="#二、IPython的帮助文档" class="headerlink" title="二、IPython的帮助文档"></a>二、IPython的帮助文档</h2><h4 id="1-使用help（）"><a href="#1-使用help（）" class="headerlink" title="1.使用help（）"></a>1.使用help（）</h4><p>通过以下命令来获得帮助文档：</p><blockquote><p>help(len)</p></blockquote><p>Help on built-in function len in module builtins:</p><p>len(obj, /)<br>    Return the number of items in a container.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(len)</span><br></pre></td></tr></table></figure></p><h4 id="2-使用？"><a href="#2-使用？" class="headerlink" title="2.使用？"></a>2.使用？</h4><blockquote><p>len？</p></blockquote><p>还可以应用到自定义的变量和自定义的函数上来返回帮助文档</p><p>此外，使用两个??可以把函数的源代码显示出来</p><h4 id="3-tab自动补全"><a href="#3-tab自动补全" class="headerlink" title="3.tab自动补全"></a>3.tab自动补全</h4><h2 id="三、IPython魔法命令"><a href="#三、IPython魔法命令" class="headerlink" title="三、IPython魔法命令"></a>三、IPython魔法命令</h2><h4 id="1-运行外部的Python文件"><a href="#1-运行外部的Python文件" class="headerlink" title="1. 运行外部的Python文件"></a>1. 运行外部的Python文件</h4><p>使用下面命令运行外部python文件（默认是当前目录，最好加上绝对路径）</p><blockquote><p>%run *.py</p></blockquote><p>例如在当前目录下有一个myscript.py文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    &quot;&quot;&quot;square a number&quot;&quot;&quot;</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line">for N in range(1, 4):</span><br><span class="line">    print(N, &quot;squared is&quot;, square(N))</span><br></pre></td></tr></table></figure></p><p>我们可以通过下面命令执行它：</p><blockquote><p>%run myscript.py</p></blockquote><p>尤其要注意的是，当我们使用魔法命令执行了一个外部文件时，该文件的函数就能在当前会话中使用</p><blockquote><p>square(5)</p></blockquote><h4 id="2-运行计时"><a href="#2-运行计时" class="headerlink" title="2.运行计时"></a>2.运行计时</h4><p>用下面命令计算statement的运行时间：</p><blockquote><p>%time statement</p></blockquote><p>用下面命令计算statement的平均运行时间：   </p><blockquote><p>%timeit statement</p></blockquote><p>timeit会多次运行statement，最后得到一个更为精准的预期运行时间</p><p>可以使用两个百分号来测试多行代码的平均运行时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">statement1</span><br><span class="line">statement2</span><br><span class="line">statement3</span><br></pre></td></tr></table></figure></p><p>记住：</p><ul><li>%time一般用于耗时长的代码段</li><li>%timeit一般用于耗时短的代码段</li></ul><h4 id="3-查看当前会话中的所有变量和函数"><a href="#3-查看当前会话中的所有变量和函数" class="headerlink" title="3. 查看当前会话中的所有变量和函数"></a>3. 查看当前会话中的所有变量和函数</h4><p>快速查看当前会话的所有变量与函数名称：</p><blockquote><p>%who</p></blockquote><p>查看当前会话的所有变量与函数名称的详细信息：</p><blockquote><p>%whos</p></blockquote><p>返回一个字符串列表，里面元素是当前会话的所有变量与函数名称：</p><blockquote><p>%who_ls</p></blockquote><h4 id="4-执行Linux指令"><a href="#4-执行Linux指令" class="headerlink" title="4.执行Linux指令"></a>4.执行Linux指令</h4><p>在Linux指令之前加上  <font size="5" color="green">!</font>，即可在ipython当中执行Linux指令。<br>注意，会将标准输出以字符串形式返回</p><h4 id="5-更多的魔法命令"><a href="#5-更多的魔法命令" class="headerlink" title="5. 更多的魔法命令"></a>5. 更多的魔法命令</h4><p>列出所有魔法命令</p><blockquote><p>lsmagic</p></blockquote><h2 id="四、IPython输入输出历史"><a href="#四、IPython输入输出历史" class="headerlink" title="四、IPython输入输出历史"></a>四、IPython输入输出历史</h2><h4 id="1-使用in、out调用输入输出历史"><a href="#1-使用in、out调用输入输出历史" class="headerlink" title="1. 使用in、out调用输入输出历史"></a>1. 使用in、out调用输入输出历史</h4><p>In返回一个字符串列表，里面是所有输入命令的字符串<br>Out返回一个含有输出的命令的序号及其输出组成的字典<br>两者皆可以通过索引获取元素</p><h4 id="2-使用下划线表示输出"><a href="#2-使用下划线表示输出" class="headerlink" title="2. 使用下划线表示输出"></a>2. 使用下划线表示输出</h4><p>“_”表示上一个输出<br>“_2”表示Out[2]</p><h2 id="五、jupyter-notebook的快捷键"><a href="#五、jupyter-notebook的快捷键" class="headerlink" title="五、jupyter-notebook的快捷键"></a>五、jupyter-notebook的快捷键</h2><p><a href="https://yuansuixin.github.io/archives/2018/04/" title="快捷键">jupyter-notebook快捷键</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>基于Tornado的异步非阻塞自定义Web框架</title>
      <link href="/2018/01/13/tornado-asynchronous/"/>
      <url>/2018/01/13/tornado-asynchronous/</url>
      <content type="html"><![CDATA[<h1 id="自定义异步非阻塞Web框架"><a href="#自定义异步非阻塞Web框架" class="headerlink" title="自定义异步非阻塞Web框架"></a>自定义异步非阻塞Web框架</h1><h3 id="支持异步非阻塞Web框架–-Tornado，Nodejs"><a href="#支持异步非阻塞Web框架–-Tornado，Nodejs" class="headerlink" title="支持异步非阻塞Web框架– Tornado，Nodejs"></a>支持异步非阻塞Web框架– Tornado，Nodejs</h3><ul><li><p>异步IO模块：<br>  我们作为客户端向服务端发起“并发”请求，select监听socket是否已经有变化<br>  future= Future（）主要的</p><ol><li>挂起当前请求，线程可以处理其他请求</li><li>future设置值，当前挂起的请求返回</li></ol></li><li><p>IO请求不占CPU，计算型需要使用CPU</p></li></ul><ul><li>自定义web框架<ul><li>同步<ul><li>从Socket开始</li><li>使用IO多路复用，当不发请求的时候，其他的可以过来，只是监听有没有变化</li><li>步骤：<ul><li>请求头中获取url，将其处理为字典格式</li><li>去路由中匹配，获取指定的函数</li><li>执行函数，获取返回值</li><li>将返回值send回去</li></ul></li></ul></li><li>异步<ul><li>使用Future（）对象，只要是future对象，来一个请求，只要future的result里面还没有给值，就可以将该请求挂起，仍然可以执行其他的请求，当future对象设置了值的时候，表示该请求结束，断开连接</li><li>使用Future()对象，通过设置超时时间来判断请求是否断开，当请求到来时，不用管它，可以处理其他的请求，当连接的时间超过了预先设定的超时时间的时候，主动断开连接，结束请求，将socket移除</li></ul></li></ul></li></ul><p>说明：<a href="https://yuansuixin.github.io/" title="详细的WebSocket讲解地址">详细的WebSocket讲解地址</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.基本使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from snow import Snow</span><br><span class="line">from snow import HttpResponse</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&apos;OK&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">routes = [</span><br><span class="line">    (r&apos;/index/&apos;, index),</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">app = Snow(routes)</span><br><span class="line">app.run(port=8012)</span><br></pre></td></tr></table></figure><ol><li>异步非阻塞：超时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from snow import Snow</span><br><span class="line">from snow import HttpResponse</span><br><span class="line">from snow import TimeoutFuture</span><br><span class="line"> </span><br><span class="line">request_list = []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def async(request):</span><br><span class="line">    obj = TimeoutFuture(5)</span><br><span class="line">    yield obj</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def home(request):</span><br><span class="line">    return HttpResponse(&apos;home&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">routes = [</span><br><span class="line">    (r&apos;/home/&apos;, home),</span><br><span class="line">    (r&apos;/async/&apos;, async),</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">app = Snow(routes)</span><br><span class="line">app.run(port=8012)</span><br></pre></td></tr></table></figure><ol><li>异步非阻塞，等待<br>基于等待模式可以完成自定制操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from snow import Snow</span><br><span class="line">from snow import HttpResponse</span><br><span class="line">from snow import Future</span><br><span class="line"> </span><br><span class="line">request_list = []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def callback(request, future):</span><br><span class="line">    return HttpResponse(future.value)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def req(request):</span><br><span class="line">    obj = Future(callback=callback)</span><br><span class="line">    request_list.append(obj)</span><br><span class="line">    yield obj</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def stop(request):</span><br><span class="line">    obj = request_list[0]</span><br><span class="line">    del request_list[0]</span><br><span class="line">    obj.set_result(&apos;done&apos;)</span><br><span class="line">    return HttpResponse(&apos;stop&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">routes = [</span><br><span class="line">    (r&apos;/req/&apos;, req),</span><br><span class="line">    (r&apos;/stop/&apos;, stop),</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">app = Snow(routes)</span><br><span class="line">app.run(port=8012)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/yuansuixin/Tornado-Asynchronous-non-blocking" title="源码下载" target="_blank" rel="noopener">源码下载</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import re</span><br><span class="line">import socket</span><br><span class="line">import select</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HttpResponse(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    封装响应信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, content=&apos;&apos;):</span><br><span class="line">        self.content = content</span><br><span class="line"></span><br><span class="line">        self.headers = &#123;&#125;</span><br><span class="line">        self.cookies = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def response(self):</span><br><span class="line">        return bytes(self.content, encoding=&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HttpNotFound(HttpResponse):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    404时的错误提示</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(HttpNotFound, self).__init__(&apos;404 Not Found&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HttpRequest(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户封装用户请求信息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, conn):</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">        self.header_bytes = bytes()</span><br><span class="line">        self.header_dict = &#123;&#125;</span><br><span class="line">        self.body_bytes = bytes()</span><br><span class="line"></span><br><span class="line">        self.method = &quot;&quot;</span><br><span class="line">        self.url = &quot;&quot;</span><br><span class="line">        self.protocol = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        self.initialize()</span><br><span class="line">        self.initialize_headers()</span><br><span class="line"></span><br><span class="line">    def initialize(self):</span><br><span class="line"></span><br><span class="line">        header_flag = False</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                received = self.conn.recv(8096)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                received = None</span><br><span class="line">            if not received:</span><br><span class="line">                break</span><br><span class="line">            if header_flag:</span><br><span class="line">                self.body_bytes += received</span><br><span class="line">                continue</span><br><span class="line">            temp = received.split(b&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">            if len(temp) == 1:</span><br><span class="line">                self.header_bytes += temp</span><br><span class="line">            else:</span><br><span class="line">                h, b = temp</span><br><span class="line">                self.header_bytes += h</span><br><span class="line">                self.body_bytes += b</span><br><span class="line">                header_flag = True</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def header_str(self):</span><br><span class="line">        return str(self.header_bytes, encoding=&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">    def initialize_headers(self):</span><br><span class="line">        headers = self.header_str.split(&apos;\r\n&apos;)</span><br><span class="line">        first_line = headers[0].split(&apos; &apos;)</span><br><span class="line">        if len(first_line) == 3:</span><br><span class="line">            self.method, self.url, self.protocol = headers[0].split(&apos; &apos;)</span><br><span class="line">            for line in headers:</span><br><span class="line">                kv = line.split(&apos;:&apos;)</span><br><span class="line">                if len(kv) == 2:</span><br><span class="line">                    k, v = kv</span><br><span class="line">                    self.header_dict[k] = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Future(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    异步非阻塞模式时封装回调函数以及是否准备就绪</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, callback):</span><br><span class="line">        self.callback = callback</span><br><span class="line">        self._ready = False</span><br><span class="line">        self.value = None</span><br><span class="line"></span><br><span class="line">    def set_result(self, value=None):</span><br><span class="line">        self.value = value</span><br><span class="line">        self._ready = True</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def ready(self):</span><br><span class="line">        return self._ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TimeoutFuture(Future):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    异步非阻塞超时</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, timeout):</span><br><span class="line">        super(TimeoutFuture, self).__init__(callback=None)</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.start_time = time.time()</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def ready(self):</span><br><span class="line">        current_time = time.time()</span><br><span class="line">        if current_time &gt; self.start_time + self.timeout:</span><br><span class="line">            self._ready = True</span><br><span class="line">        return self._ready</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Snow(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    微型Web框架类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, routes):</span><br><span class="line">        self.routes = routes</span><br><span class="line">        self.inputs = set()</span><br><span class="line">        self.request = None</span><br><span class="line">        self.async_request_handler = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def run(self, host=&apos;localhost&apos;, port=9999):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        事件循环</span><br><span class="line">        :param host:</span><br><span class="line">        :param port:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        sock.bind((host, port,))</span><br><span class="line">        sock.setblocking(False)</span><br><span class="line">        sock.listen(128)</span><br><span class="line">        sock.setblocking(0)</span><br><span class="line">        self.inputs.add(sock)</span><br><span class="line">        try:</span><br><span class="line">            while True:</span><br><span class="line">                readable_list, writeable_list, error_list = select.select(self.inputs, [], self.inputs,0.005)</span><br><span class="line">                for conn in readable_list:</span><br><span class="line">                    if sock == conn:</span><br><span class="line">                        client, address = conn.accept()</span><br><span class="line">                        client.setblocking(False)</span><br><span class="line">                        self.inputs.add(client)</span><br><span class="line">                    else:</span><br><span class="line">                        gen = self.process(conn)</span><br><span class="line">                        if isinstance(gen, HttpResponse):</span><br><span class="line">                            conn.sendall(gen.response())</span><br><span class="line">                            self.inputs.remove(conn)</span><br><span class="line">                            conn.close()</span><br><span class="line">                        else:</span><br><span class="line">                            yielded = next(gen)</span><br><span class="line">                            self.async_request_handler[conn] = yielded</span><br><span class="line">                self.polling_callback()</span><br><span class="line"></span><br><span class="line">        except Exception as e:</span><br><span class="line">            pass</span><br><span class="line">        finally:</span><br><span class="line">            sock.close()</span><br><span class="line"></span><br><span class="line">    def polling_callback(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        遍历触发异步非阻塞的回调函数</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for conn in list(self.async_request_handler.keys()):</span><br><span class="line">            yielded = self.async_request_handler[conn]</span><br><span class="line">            if not yielded.ready:</span><br><span class="line">                continue</span><br><span class="line">            if yielded.callback:</span><br><span class="line">                ret = yielded.callback(self.request, yielded)</span><br><span class="line">                conn.sendall(ret.response())</span><br><span class="line">            self.inputs.remove(conn)</span><br><span class="line">            del self.async_request_handler[conn]</span><br><span class="line">            conn.close()</span><br><span class="line"></span><br><span class="line">    def process(self, conn):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        处理路由系统以及执行函数</span><br><span class="line">        :param conn:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.request = HttpRequest(conn)</span><br><span class="line">        func = None</span><br><span class="line">        for route in self.routes:</span><br><span class="line">            if re.match(route[0], self.request.url):</span><br><span class="line">                func = route[1]</span><br><span class="line">                break</span><br><span class="line">        if not func:</span><br><span class="line">            return HttpNotFound()</span><br><span class="line">        else:</span><br><span class="line">            return func(self.request)</span><br><span class="line"></span><br><span class="line">snow.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>hello~</title>
      <link href="/2018/01/02/hello/"/>
      <url>/2018/01/02/hello/</url>
      <content type="html"><![CDATA[<blockquote><p>因为很多原因，一直没能进行博客的更新，今天终于又和大家见面了。</p></blockquote><ul><li>nice to meet you !</li><li>欢迎来到我的博客，希望和大家一同进步，一同分享知识。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的注解（Annotation)详细解析</title>
      <link href="/2017/12/15/annotation/"/>
      <url>/2017/12/15/annotation/</url>
      <content type="html"><![CDATA[<h6 id="Annotation工作方式："><a href="#Annotation工作方式：" class="headerlink" title="Annotation工作方式："></a>Annotation工作方式：</h6><p>从java5.0以来，提供了一个真实的annotation功能：允许开发者定义、使用自己的额annotation类型，此功能由一个定义annotation类型的语法和一个描述annotation声明的语法，读取annotation的API，一个使用annotation修饰的Class文件，一个annotation处理工具apt组成。</p><p>annotation<strong>并不会直接影响代码语义</strong>，但是它能够工作的方式被看做类似程序的工具或者类库，他会反过来对正在运行的程序语义有所影响。annotation可以从源文件，class文件或者以在运行时反射的多种方式被读取。</p><p>注解可以用在方法，类，变量等上面，注解的使用范围很广。</p><p><strong>Override注解表示子类要重写（override）父类方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OverrideTest &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;This is OverrideTest&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">OverrideTest overrideTest = new OverrideTest();</span><br><span class="line">System.out.println(overrideTest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is OverrideTest</span><br></pre></td></tr></table></figure><p><strong>Deprecate注解表示方法是不建议被使用的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DeprecatedTest &#123;</span><br><span class="line">@Deprecated</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">System.out.println(&quot;do something &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">DeprecatedTest deprecatedTest= new DeprecatedTest();</span><br><span class="line">//不建议被使用的</span><br><span class="line">deprecatedTest.doSomething();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Date d= new Date();</span><br><span class="line">//System.out.println(d.toLocaleString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SuppressWarnings注解表示抑制警告。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningsTest &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)//不检查</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map=new TreeMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;hello&quot;, new Date());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class SuppressWarningsTest &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;,&quot;deprecation&quot;&#125;)//不检查，不推荐使用的</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Map map=new TreeMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;hello&quot;, new Date());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">Date date=new Date();</span><br><span class="line">System.out.println(date.toLocaleString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解跟着值的时候可以使用大括号，也可以省略。@SuppressWarnings({“unchecked”,”deprecation”})</strong></p><p>以上就是注解的使用方式，我们也可以自己定义注解，下面来介绍一下自定义注解。</p><p>当注解中的属性名为value时，在对其赋值时可以不指定属性的名称而直接写上属性值即可，除了value以外的其他值都需要使用name=value这种赋值方式，即明确指定给谁赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public @interface AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">//定义属性</span><br><span class="line">String value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@AnnotationTest(value=&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">public class AnnoationUsage &#123;</span><br><span class="line"></span><br><span class="line">@AnnotationTest(value=&quot;world&quot;)</span><br><span class="line">public void method() &#123;</span><br><span class="line">System.out.println(&quot;usage of annoation&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AnnoationUsage annoationUsage = new AnnoationUsage();</span><br><span class="line">annoationUsage.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的值可以默认的具体赋值，使用@interface自行定义Annotation形态时，实际上是自动继承了java.lang.annotation.Annotation接口由编译程序自动为您完成其他产生的细节，<strong>在定义Annotation形态时，不能继承其他的Annotation形态或是接口。</strong></p><p>当我们使用@interface关键字定义一个注解时，该注解隐含地继承了java.lang.annotation.Annotation接口；如果我们定义了一个接口，并且让该接口继承自Annotation，那么我们所定义的接口依然还是接口而不是注解；Annotation本身是接口而不是注解。可以与Enum类比。</p><p>定义annotation类型时也可以使用包来管理类别，方式同于类的导入功能</p><h6 id="告知编译器如何处理-Retention"><a href="#告知编译器如何处理-Retention" class="headerlink" title="告知编译器如何处理@Retention"></a>告知编译器如何处理@Retention</h6><p>使用java.lang.annotation.Retention，在定义时要指定java.lang.annotation.RetentionPolicy的枚举值之一</p><p>java.lang.annotation.Retention形态可以在你定义Annotation时，指示编译程序该如何对待您的自定义的Annotation。预设上编译程序会将Annotation信息留在.class档案中，但不被虚拟机读取，而仅用于编译程序或工具程序运行时提供信息。</p><p>Retention和RetentionPolicy总是成对出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line"></span><br><span class="line">SOURCE,//编译程序处理完annotation信息后就完成任务</span><br><span class="line">CLASS,//编译程序将annotation储存于Class档中，默认就是这个</span><br><span class="line">RUNTIME//编译程序将annotation储存于Class文档中，可以由VM读入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为SOURSE的例子是<br>@SuppressWarnings仅在编译时期告知编译程序来抑制警告，所以不必将这个信息储存于class文档<br>为RUNTIME的时机，可以像是你使用java设计一个程序代码分析工具，你必须让vm能读出Annotation信息，以便在分析程序时使用，<strong>搭配反射机制就可以达到这个目的</strong></p><p>定义annotation时必须设定RetentionPolicy为RUNTIME，也就是可以在vm中读取Annotation信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line">//自定义一个注解</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">String hello() default &quot;zhangsan&quot;;</span><br><span class="line">String world();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation(hello=&quot;beijing&quot;,world=&quot;shanghai&quot;)</span><br><span class="line">public class MyTest &#123;</span><br><span class="line"></span><br><span class="line">//一个方法可以由多个注解修饰</span><br><span class="line">@MyAnnotation(hello=&quot;tianjin&quot;,world=&quot;shangdi&quot;)</span><br><span class="line">@Deprecated</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void output() &#123;</span><br><span class="line">System.out.println(&quot;output method&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyReflaction &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)throws Exception &#123;</span><br><span class="line"></span><br><span class="line">MyTest myTest = new MyTest();</span><br><span class="line"></span><br><span class="line">Class&lt;MyTest&gt; class1= MyTest.class;</span><br><span class="line"></span><br><span class="line">Method method =class1.getMethod(&quot;output&quot;, new Class[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//判断是否存在这样也一个Annotation</span><br><span class="line">if(method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">method.invoke(myTest, new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//得到一个Annotation，返回这个Annotation的一个实例</span><br><span class="line">MyAnnotation myAnnotation =method.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">//获得这个Annotation的属性值</span><br><span class="line">String hello=myAnnotation.hello();</span><br><span class="line">String world=myAnnotation.world();</span><br><span class="line"></span><br><span class="line">System.out.println(hello+&quot; ,&quot;+world);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果完全是由RetentionPolicy决定的，只有RUNTIME的可以读取到</span><br><span class="line">Annotation[] annotations=method.getAnnotations();</span><br><span class="line"></span><br><span class="line">//必须RetentionPolicy为RUNTIME才可以读取到</span><br><span class="line">for(Annotation annotation: annotations) &#123;</span><br><span class="line">System.out.println(annotation.annotationType().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output method</span><br><span class="line">tianjin ,shangdi</span><br><span class="line">MyAnnotation</span><br><span class="line">java.lang.Deprecated</span><br></pre></td></tr></table></figure><p>这个例子主要练习了几个和反射、注解有关的方法。只要理解了反射机制就很容易理解了，我再注释中都已经详细的介绍了，这里就不过多的描述了。</p><h6 id="限定annotation使用对象-Target"><a href="#限定annotation使用对象-Target" class="headerlink" title="限定annotation使用对象@Target"></a>限定annotation使用对象@Target</h6><p>使用java.lang.annotation.Target可以定义其使用之时机，在定义时要指定java.lang.annotation.ElementType的枚举值之一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line"></span><br><span class="line">TYPE,//适用Class,interface ,enum</span><br><span class="line">FIELD,//适用文件</span><br><span class="line">METHOD,//适用于方法</span><br><span class="line">PARAMETER,//适用method上之parameter</span><br><span class="line">CONSTRUCTOR,//适用constructor</span><br><span class="line">LOCAL_VARIABLE,//适用局部变量</span><br><span class="line">ANNOTATION_TYPE,//适用annotation形态</span><br><span class="line">PACKAGE//适用package</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="要求为API文件-Documented"><a href="#要求为API文件-Documented" class="headerlink" title="要求为API文件@Documented"></a>要求为API文件@Documented</h6><p>想要在使用者制作javaDoc文件的同时，也一并将Annotation的信息加入至API文档中使用。</p><h6 id="子类是否继承父类-Inherited"><a href="#子类是否继承父类-Inherited" class="headerlink" title="子类是否继承父类@Inherited"></a>子类是否继承父类@Inherited</h6><p>预设上父类中的annotation并不会被继承至子类中，可以在定义Annotation形态时加上java.lang.annotation.Inherited形态的Annotation。</p><p>注解在实际中的应用，注解主要应用在单元测试中，我来简单的说一下。</p><p>Junit有两个经典的版本，Junit3和Junit4。</p><p>Junit3继承TestCase,方法必须以test开头。keep the bar green to keep the code clean.这些底层都是通过反射机制实现的。</p><p>Junit3是基于反射的，Junit4是基于反射和注解的</p><p>JUnit4的执行的一般流程：</p><ol><li>首先获得待测试类所对应的Class对象。</li><li>然后通过该Class对象获得当前类中所有public方法所对应的Method数组。</li><li>遍历该Method数组，取得每一个Method对象</li><li>调用每个Method对象的isAnnotationPresent(Test.class)方法，判断该方法是否被Test注解所修饰。</li><li>如果该方法返回true，那么调用method.invoke()方法去执行该方法，否则不执行。</li></ol><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式---代理模式（Proxy）（动态代理）</title>
      <link href="/2017/11/05/proxy2/"/>
      <url>/2017/11/05/proxy2/</url>
      <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p> Java动态代理类位于java.lang.reflect包下，一般主要 涉及到以下两个类： </p><p> (1)<strong>Interface InvocationHandler接口</strong>：该接口中仅定义了 一个方法 </p><ul><li><p>public object invoke(Object obj,Method method, Object[] args) </p></li><li><p>在实际使用时，第一个参数obj一般是指代理类，代理实例的方法被调用 第二个参数method是被代理的方法，如上例中的request()，第三个参数args 为该方法的参数数组。 这个抽象方法在代理类中动态实现。</p></li></ul><p>这个接口是由一个代理实例的调用处理器来实现的。</p><p>每一个代理实例都会有一个与之关联的调用处理器。当我们调用一个代理实例的某一个方法的时候，这个方法调用就会被编码并且被派发到与之关联的他的调用处理器的invoke方法上，被调用。</p><p>invoke方法会处理代理实例上的一个方法调用，并且将真正的调用结果返回回来。当一个调用处理器关联到这个处理器的某个代理实例，我们调用这个代理实例上的某个方法的时候，这个方法就会转移到与这个实例所关联的那个调用处理器的invoke方法，由它帮我们完成调用。</p><p>(2)<strong>Proxy</strong>：该类即为动态代理类，作用类似于上例中的</p><p>Proxy提供了一些静态方法用于创建动态代理类和实例，他也是由这些方法所创建的动态代理类的一个父类。</p><p>ProxySubject，其中主要包含以下内容</p><ul><li><p>protected Proxy(InvocationHandler h)：构造函数， 用于给内部的h赋值。</p></li><li><p>static Class getProxyClass (ClassLoader loader, Class[] interfaces)：获得一个代理类，其中loader是 类装载器，interfaces是真实类所拥有的全部接口的数组 。</p></li><li><p>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)： <strong>返回代理类的一个实例</strong>，返回后的代理类可以当作被代理 类使用(可使用被代理类的在Subject接口中声明过的方法 )</p></li><li><p>所谓Dynamic Proxy是这样一种class： 它是在<strong>运行时生成</strong>的class，<strong>在生成它时你 必须提供一组interface给它，然后该class 就宣称它实现了这些 interface</strong>。你当然可 以把该class的实例当作这些interface中的 任何一个来用(多态)。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作 实质性的工作，在生成它的实例时你必须 提供一个handler，由它接管实际的工作</p></li><li><p>在使用动态代理类时，我们必须实现 InvocationHandler接口 </p></li></ul><h6 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">System.out.println(&quot;from real subject&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该代理类的内部属性是Object类型，实际使用的时候通过该类的构造方法传递进来一个对象</span><br><span class="line"> * 此外，该类还实现了invoke方法，该方法中的method.invoke其实就是调用被代理对象的将要</span><br><span class="line"> * 执行的方法，方法参数是sub，表示该方法从属于sub，通过动态代理类，我们可以在执行真实对象的方法前后</span><br><span class="line"> * 加入自己的一些额外方法。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DynamicSubject implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">//真实对象的引用，因为是动态代理，他可以代理任意一个对象，所以就要定义为Object类型。如果是RealSubject就很受限制了。</span><br><span class="line">private Object sub;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public  DynamicSubject(Object object) &#123;</span><br><span class="line">   this.sub=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;before calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">//使用的是反射，进行的调用</span><br><span class="line">method.invoke(sub, args);</span><br><span class="line"></span><br><span class="line">System.out.println(args==null);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">//这个例子没有返回值，直接返回空就可以</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">RealSubject realSubject = new RealSubject();</span><br><span class="line"></span><br><span class="line">//多态</span><br><span class="line">//代理谁就传谁</span><br><span class="line">InvocationHandler handler = new DynamicSubject(realSubject);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=handler.getClass();</span><br><span class="line"></span><br><span class="line">     //下面的代码一次性生成代理</span><br><span class="line">//第一个参数为类装载器，通过Class类可以获得，我们现在要动态的生成类了，这个类是由哪个类装载器装载的呢</span><br><span class="line">//代理类返回的是一个Object类型的，需要转换类型</span><br><span class="line">//运行的时候生成一个class，然后生成class类的一个对象</span><br><span class="line">Subject subject=(Subject)Proxy.newProxyInstance(classType.getClassLoader(),</span><br><span class="line">realSubject.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">subject.request();</span><br><span class="line"></span><br><span class="line">System.out.println(subject.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before calling:public abstract void com.suixin.pattern.dynamicsubject.Subject.request()</span><br><span class="line">from real subject</span><br><span class="line">null</span><br><span class="line">after calling:public abstract void com.suixin.pattern.dynamicsubject.Subject.request()</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br></pre></td></tr></table></figure><p><strong>只要使用动态代理类，有一个动态代理类就会有一个InvocationHandler，他们总是相互关联的。</strong>代理类并不会真正的完成方法的调用，而都是由与之关联的InvocationHandler的invoke方法真正完成目标方法的调用。</p><p>下面通过这个例子，我来给大家详细的介绍一下执行的流程和注意事项，详细步骤解读：</p><ol><li><p>首先进行实例化，实例化已经知道的我们需要用到的类，也就是说实例化RealSubject和DynamicSubject，这里用到了多态的知识点，这里我给大家补充一下， <strong>多态：所谓多态，就是父类型的引用可以指向子类型的对象，或者接口类型的引用可以指向实现该接口的类的实例。关于接口与实现接口的类之间的强制类型转换方式与父类和子类之间的强制类型转换方式完全一样。</strong></p><pre><code> RealSubject realSubject = new RealSubject();//多态//因为这里是动态代理，代理的对象不能指定为一个，所以代理谁就传谁InvocationHandler handler = new DynamicSubject(realSubject);</code></pre></li><li><p>获得调用处理器的Class对象，这里使用的是getClass（）方法。获得这个Class对象是为了生成代理的时候使用。</p></li></ol><p>3.一次性生成代理实例，这里的生成实例，既不是真实对象的实例也不是代理对象DynamicSubject的实例，而是java在运行的时候生成的一个Class类，然后生成这个Class类的一个对象。</p><pre><code>Subject subject=(Subject)Proxy.newProxyInstance(classType.getClassLoader(),realSubject.getClass().getInterfaces(), handler);</code></pre><p>第一个参数为类加载器，通过Class类可以获得，我们现在要动态的生成类了，这个类是由哪个类装载器装载的呢，因为我们要动态的生成一个代理角色的类，而代理角色类的方法都是由调用处理器来实现的，所以这个类加载器就是调用处理器也就是代理角色的类加载器，classType.getClassLoader()。这个类的实例宣称实现了真实角色实现的所有的接口，也就是realSubject.getClass().getInterfaces()这些接口，所以生成出来的那个对象我们可以将其转换成Subject类型，（不要装换为对应的具体的实现类类型，因为并不知道他对应了那些实现类），装换之后正常的调用方法就可以了。</p><p><strong>生成动态代理类，而与之关联的调用处理器就是DynamicSubject</strong></p><p>4.调用方法的时候，就会转而由InvocationHandler的invoke方法来执行，并且将参数也分别传递过去。就会执行invoke（）方法，执行完之后再回到Client继续执行下面的代码。这就实现了动态代理，over。</p><hr><p>通过这种方式，被代理的对象 (RealSubject)可以在运行时动态改变，需 要控制的接口(Subject接口)可以在运行时 改变，控制的方式(DynamicSubject类) 也可以动态改变，从而实现了非常灵活的 动态代理关系</p><ul><li>动态代理是指客户通过代理类来调用其它 对象的方法</li><li><p>动态代理使用场合:</p><p> 调试 </p><p> 远程方法调用(RMI)</p></li></ul><p><img src="http://img.blog.csdn.net/20171113172042542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>实现动态代理的步骤：</p><ol><li>创建一个实现接口InvocationHandler的 类，它必须实现invoke方法</li><li>创建被代理的类以及接口</li><li>通过Proxy的静态方法 newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个代理 </li><li>通过代理调用方法</li></ol><p>我想大家对于代理模式已经有了一个了解了，但是我们为了更好的掌握它，还是得再巩固一下，我们练习一下带有参数传递的动态代理模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Vector;</span><br><span class="line"></span><br><span class="line">public class VectorProxy implements InvocationHandler&#123;</span><br><span class="line">private Object proxyObj;</span><br><span class="line"></span><br><span class="line">public VectorProxy(Object object) &#123;</span><br><span class="line">this.proxyObj=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Object factory(Object object) &#123;</span><br><span class="line">Class&lt;?&gt; classType=object.getClass();</span><br><span class="line"></span><br><span class="line">return Proxy.newProxyInstance(classType.getClassLoader(), </span><br><span class="line">classType.getInterfaces(), new VectorProxy(object));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(&quot;before calling:&quot;+method);</span><br><span class="line"></span><br><span class="line">if(null!=args) &#123;</span><br><span class="line">for(Object object:args) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object=method.invoke(proxyObj, args);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;after calling :&quot;+method);</span><br><span class="line">return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//vList是运行时动态生成的类的实例</span><br><span class="line">List vList=(List) factory(new Vector());</span><br><span class="line"></span><br><span class="line">//我们把这个动态生成的实例的名字打印出来</span><br><span class="line">System.out.println(vList.getClass().getName());</span><br><span class="line"></span><br><span class="line">vList.add(&quot;new&quot;);</span><br><span class="line">vList.add(&quot;York&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(vList);</span><br><span class="line"></span><br><span class="line">vList.remove(0);</span><br><span class="line">System.out.println(vList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">before calling:public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">new</span><br><span class="line">after calling :public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">before calling:public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line">York</span><br><span class="line">after calling :public abstract boolean java.util.List.add(java.lang.Object)</span><br><span class="line"></span><br><span class="line">before calling:public java.lang.String java.lang.Object.toString()</span><br><span class="line">after calling :public java.lang.String java.lang.Object.toString()</span><br><span class="line">[new, York]</span><br><span class="line">before calling:public abstract java.lang.Object java.util.List.remove(int)</span><br><span class="line">0</span><br><span class="line">after calling :public abstract java.lang.Object java.util.List.remove(int)</span><br><span class="line">before calling:public java.lang.String java.lang.Object.toString()</span><br><span class="line">after calling :public java.lang.String java.lang.Object.toString()</span><br><span class="line">[York]</span><br></pre></td></tr></table></figure><p>我们一起来分析一下这个程序，其实原理都是一样的。我把所有的内容写到了一个类里面。</p><ol><li>首先从入口开始说起吧，定义了List，vList是运行时动态生成的类的实例。也就是factory方法的返回值。factory方法有一个参数object代表着传入的要代理的对象。factory返回的值是Object，但是newProxyInstance生成的类是实现了传入的参数所实现的所有的方法，new Vector（）实现了List的接口，那么动态代理也肯定实现了这个接口，可以通过强制类型转换为List类型。</li><li>然后调用add方法，传入一个“new”进去，当你调用生成代理对象的任何一个方法，都会立刻转由invoke方法执行。将参数传给invoke方法，我们遍历参数的数组args就会打印出来。继续执行invoke方法，执行完之后，再回来执行add（“york”）;再重复上面的执行过程。</li><li>我们打印出来vList看看是什么，其实和上面的过程是一样的，打印vList相当于调用了vList.toString();方法，过程和上面调用方法的步骤一致，只是没有传参数而已。<br>4.调用remove方法也是同样的道理，我就不再重复了。</li></ol><p>动态代理是能够用一个动态代理类，代理多个真实对象，那么我们举例来看一下，这里我就不详细的介绍了。</p><p>公共的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Foo &#123;</span><br><span class="line">void doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个真实的角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FoolImp1 implements Foo&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doAction() &#123;</span><br><span class="line">System.out.println(&quot;in FooImpl doAction&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个真实角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class FooImpl2 implements Foo &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doAction() &#123;</span><br><span class="line">System.out.println(&quot;in FooImp2 doAction&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class CommonInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">private Object object;</span><br><span class="line"> public CommonInvocationHandler(Object object) &#123;</span><br><span class="line">this.object=object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public CommonInvocationHandler() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> public void setObject(Object object) &#123;</span><br><span class="line">this.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代理角色</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">return method.invoke(object, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.logging.Handler;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">CommonInvocationHandler cHandler=new CommonInvocationHandler();</span><br><span class="line"></span><br><span class="line">Foo foo=null;</span><br><span class="line"></span><br><span class="line">cHandler.setObject(new FoolImp1());</span><br><span class="line"></span><br><span class="line">foo=(Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(), </span><br><span class="line">new Class[] &#123;Foo.class&#125;, cHandler);</span><br><span class="line"></span><br><span class="line">foo.doAction();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;==================================================&quot;);</span><br><span class="line"></span><br><span class="line">cHandler.setObject(new FooImpl2());</span><br><span class="line"></span><br><span class="line">foo=(Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">new Class[] &#123;Foo.class&#125;, cHandler);</span><br><span class="line"></span><br><span class="line">foo.doAction();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in FooImpl doAction</span><br><span class="line">==================================================</span><br><span class="line">in FooImp2 doAction</span><br></pre></td></tr></table></figure><p>这个例子中FoolImp1、FoolImp2是两个真实的角色，用一个代理Proxy代理他们两个，通过在运行时期生成动态代理实例来代理，完成真实角色要实现的方法，其实，方法都是在invoke方法中得到真实调用的，代理实例不会真正的真实角色的方法，最终还是由真实角色里实现的。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式----代理模式（Proxy）（静态代理模式）</title>
      <link href="/2017/10/22/proxy/"/>
      <url>/2017/10/22/proxy/</url>
      <content type="html"><![CDATA[<h1 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h1><p>代理模式分为静态代理和动态代理，有代理对象叫做静态代理，没有代理对象叫做动态代理</p><p>代理模式的作用是：为其他对象提供一个代理以控制对这个对象的访问。<br>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>代理模式一般涉及到的角色：</p><ul><li>抽象角色：声明真实对象和代理对象的<strong>共同接口</strong></li><li>代理对象：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时代理对象可以在执行真实对象操作时，附加其他操作，相当于对真实对象进行封装</li><li>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>代理模式比较抽象，我们利用代码例子来理解。</p><h6 id="抽象角色"><a href="#抽象角色" class="headerlink" title="抽象角色"></a>抽象角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//抽象角色</span><br><span class="line">public abstract class Subject &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public abstract void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="真实角色"><a href="#真实角色" class="headerlink" title="真实角色"></a>真实角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;form real subject&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代理角色"><a href="#代理角色" class="headerlink" title="代理角色"></a>代理角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ProxySubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">private RealSubject realsubject; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void proRequest() &#123;</span><br><span class="line">System.out.println(&quot;pro request&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">this.proRequest();</span><br><span class="line"></span><br><span class="line">if(realsubject==null) &#123;</span><br><span class="line">realsubject = new RealSubject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">realsubject.request();</span><br><span class="line"></span><br><span class="line">this.postRequest();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void postRequest() &#123;</span><br><span class="line">System.out.println(&quot;post quest&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ProxySubject proxySubject = new ProxySubject();</span><br><span class="line">proxySubject.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pro request</span><br><span class="line">form real subject</span><br><span class="line">post quest</span><br></pre></td></tr></table></figure><ul><li>由以上代码可以看出，客户实际需要调用的是 RealSubject类的request()方法，现在用ProxySubject 来代理 RealSubject类，同样达到目的，同时还封装了 其他方法(preRequest(),postRequest())，可以处理一 些其他问题。 </li><li>另外，<strong>如果要按照上述的方法使用代理模式，那么真实角 色必须是事先已经存在的，并将其作为代理对象的内部属性。</strong>但是实际使用时，一个真实角色必须对应一个代理 角色，如果大量使用会导致类的急剧膨胀；此外，如果事 先并不知道真实角色，该如何使用代理呢？这个问题可以 通过Java的动态代理类来解决</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式----装饰模式</title>
      <link href="/2017/09/07/wrapper/"/>
      <url>/2017/09/07/wrapper/</url>
      <content type="html"><![CDATA[<p>装饰模式又名包装（Wrapper）模式 </p><p>• 装饰模式以对客户端透明的方式扩展对象 的功能，是继承关系的一个替代方案 </p><p>• 装饰模式以对客户透明的方式动态的给一 个对象附加上更多的责任。换言之，客户 端并不会觉得对象在装饰前和装饰后有什么不同。</p><p>• 装饰模式可以在不创造更多子类的情况下， 将对象的功能加以扩展。</p><p>• 装饰模式把客户端的调用委派到被装饰类。 装饰模式的关键在于这种扩展完全是透明的。</p><p>• 装饰模式是在不必改变原类文件和使用继 承的情况下，动态的扩展一个对象的功能。 它是通过创建一个包装对象，也就是装饰 来包裹真实的对象。</p><p><strong>装饰模式的角色：</strong> </p><ul><li>抽象构件角色（Component）：给出一个抽 象接口，以规范准备接收附加责任的对象。 </li><li>具体构件角色（Concrete Component）： 定义一个将要接收附加责任的类。 </li><li>装饰角色（Decorator）：持有一个构件 （Component）对象的引用，并定义一个与 抽象构件接口一致的接口 </li><li>具体装饰角色（Concrete  Decorator）：负责给构件对象“贴上”附加的责任。</li></ul><p><strong>装饰模式的特点：</strong></p><ul><li>装饰对象和真实对象有相同的接口。这样客户端对象 就可以以和真实对象相同的方式和装饰对象交互。</li><li>装饰对象包含一个真实对象的引用（reference）</li><li>装饰对象接收所有来自客户端的请求。它把这些请求 转发给真实的对象。 </li><li><p>装饰对象可以在转发这些请求以前或以后增加一些附 加功能。这样就确保了在运行时，不用修改给定对象 的结构就可以在外部增加附加的功能。在面向对象的 设计中，通常是通过继承来实现对给定类的功能扩展。</p><p><strong>装饰模式</strong> </p></li><li>用来扩展特定对象的功能 </li><li>不需要子类 </li><li>动态 </li><li>运行时分配职责</li><li>防止由于子类而导致的复杂和混乱</li><li>更多的灵活性</li><li>对于一个给定的对象，同时可能有不同的装饰 对象，客户端可以通过它的需要选择合适的装 饰对象发送消息。</li></ul><p><strong>继承</strong></p><ul><li>用来扩展一类对象的功能 </li><li>需要子类 </li><li>静态 </li><li>编译时分派职责</li><li>导致很多子类产生 </li><li><p>缺乏灵活性</p><p>实现自己的装饰模式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象构件角色</span><br><span class="line">public interface  Component &#123;</span><br><span class="line">public void doSomthing() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//具体的构件角色</span><br><span class="line">public class ConcreteComponent implements Component&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;功能A&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//装饰角色</span><br><span class="line">public class Decorator implements Component&#123;</span><br><span class="line"></span><br><span class="line">//持有接口的引用</span><br><span class="line">private Component component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Decorator(Component component ) &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">this.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Decorator() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line"></span><br><span class="line">component.doSomthing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//具体的装饰角色</span><br><span class="line">public class ConcreteDecorator extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecorator(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line">super.doSomthing();</span><br><span class="line"></span><br><span class="line">this.doAnotherThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAnotherThing() &#123;</span><br><span class="line">System.out.println(&quot;功能B&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteDectator2 extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDectator2(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSomthing() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">super.doSomthing();</span><br><span class="line">this.doAnotherThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAnotherThing() &#123;</span><br><span class="line">System.out.println(&quot;功能C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">////节点流</span><br><span class="line">//Component component = new ConcreteComponent();</span><br><span class="line">//</span><br><span class="line">////过滤流</span><br><span class="line">//Component component2 = new ConcreteDecorator(component);</span><br><span class="line">//</span><br><span class="line">////过滤流</span><br><span class="line">//Component component3 = new ConcreteDectator2(component2);</span><br><span class="line">//</span><br><span class="line">//component2.doSomthing();</span><br><span class="line">//System.out.println(&quot;=======================&quot;);</span><br><span class="line">//component3.doSomthing();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Component component = new ConcreteDecorator(new ConcreteDectator2(new ConcreteComponent()));</span><br><span class="line">component.doSomthing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里我用了两种方式来测试，作用是一样的，只是与io流更相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能A</span><br><span class="line">功能C</span><br><span class="line">功能B</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射机制深入剖析（二）</title>
      <link href="/2017/06/02/reflection2/"/>
      <url>/2017/06/02/reflection2/</url>
      <content type="html"><![CDATA[<p>继续来谈谈反射机制</p><ol><li>要想使用反射，首先需要获得待处理类或对象所对应的Class对象。</li></ol><p><strong>2. 获取某个类或某个对象所对应的Class对象的常用的3种方式：</strong></p><ul><li><strong>使用Class类的静态方法forName，Class.forName(“java.lang.String”);</strong></li><li><strong>使用类的.class语法：String.class;</strong></li><li><strong>使用对象的getClass()方法： String s=”aa”;Class&lt;?&gt; class=s.getClass();</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">public class ReflactTester &#123;</span><br><span class="line"></span><br><span class="line">//该方法实现对Customer对象的拷贝操作</span><br><span class="line">public Object copy(Object object) throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; classType=object.getClass();</span><br><span class="line"></span><br><span class="line">//System.out.println(classType.getName());</span><br><span class="line"></span><br><span class="line">Constructor constructor = classType.getConstructor(new Class[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">Object object2= constructor.newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以上两行代码等价于下面一行</span><br><span class="line">//Object object2=classType.newInstance();</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//Constructor constructor3 = classType.getConstructor(new Class[] &#123;String.class,int.class&#125;);</span><br><span class="line">//</span><br><span class="line">//Object object3= constructor3.newInstance(new Object[] &#123;&quot;hello&quot;,4&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(object2);</span><br><span class="line">//System.out.println(object3);</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">ReflactTester tester= new ReflactTester();</span><br><span class="line">tester.copy(new Customer());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Customer&#123;</span><br><span class="line"></span><br><span class="line">private Long id;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public Customer() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Customer (String name, int age) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Long getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(Long id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Customer@15db9742</span><br></pre></td></tr></table></figure><p>3.若想通过类的不带参数的构造方法来生成对象，我们有两种方式：</p><ul><li><p>先获得 Class 对象，然后通过该 Class 对象的 newInstance()方法直接生成即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = String.class; </span><br><span class="line">Object obj = classType.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>先获得 Class 对象，然后通过该对象获得对应的 Constructor 对象，再通过该 Constructor 对象的 newInstance()方法生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = Customer.class; </span><br><span class="line">Constructor cons = classType.getConstructor(new Class[]&#123;&#125;);</span><br><span class="line">Object obj = cons.newInstance(new Object[]&#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>4.若想通过类的带参数的构造方法生成对象，只能使用下面这一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; classType = Customer.class; </span><br><span class="line">Constructor cons = classType.getConstructor(new Class[]&#123;String.class, int.class&#125;); </span><br><span class="line">Object obj = cons.newInstance(new Object[]&#123;“hello”, 3&#125;);</span><br></pre></td></tr></table></figure><hr><p>我们再来看一个例子,ReflectTester类有一个 copy(Object object)方法，这个方法能够创建 一个和参数object 同样类型的对象，然后把 object对象中的所有属性拷贝到新建的对象中， 并将它返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflactTester2 &#123;</span><br><span class="line"></span><br><span class="line">public Object copy(Object object )throws Exception &#123;</span><br><span class="line">    //获得对象的类型</span><br><span class="line">Class&lt;?&gt; classType = object.getClass();</span><br><span class="line">//System.out.println(&quot;Class:&quot;+classType.getName());</span><br><span class="line"></span><br><span class="line">//通过无参数的构造方法构造出来类并且实例化</span><br><span class="line">Object objectCopy=classType.getConstructor(new Class[] &#123;&#125;).newInstance(new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//获得对象的所有成员变量</span><br><span class="line"></span><br><span class="line">Field[] fields= classType.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">for(Field field:fields) &#123;</span><br><span class="line">//获得属性的名称</span><br><span class="line">String name=field.getName();</span><br><span class="line"></span><br><span class="line">//变量名称首字母大写</span><br><span class="line">String firstLetter=name.substring(0,1).toUpperCase();</span><br><span class="line"></span><br><span class="line">//获取到get、set方法的名称</span><br><span class="line">String getMethodName=&quot;get&quot;+firstLetter+name.substring(1);</span><br><span class="line">String setMethodName=&quot;set&quot;+firstLetter+name.substring(1);</span><br><span class="line"></span><br><span class="line">//获取到get、set方法</span><br><span class="line">Method getMethod=classType.getMethod(getMethodName, new Class[] &#123;&#125;);</span><br><span class="line">Method setMethod=classType.getMethod(setMethodName, new Class[] &#123;field.getType()&#125;);</span><br><span class="line"></span><br><span class="line">//set方法没有参数</span><br><span class="line">Object value=getMethod.invoke(object, new Object[] &#123;&#125;);</span><br><span class="line"></span><br><span class="line">//将get到的属性值传入</span><br><span class="line">setMethod.invoke(objectCopy, new Object[] &#123;value&#125;);</span><br><span class="line">&#125;</span><br><span class="line">return objectCopy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Customer customer = new Customer(&quot;Tom&quot;,20);</span><br><span class="line">//注意是long类型的哟</span><br><span class="line">customer.setId(1L);</span><br><span class="line"></span><br><span class="line">ReflactTester tester = new ReflactTester();</span><br><span class="line"></span><br><span class="line">Customer customer2 = (Customer) tester.copy(customer);</span><br><span class="line"></span><br><span class="line">//System.out.println(customer2.getId()+&quot;,&quot;+customer2.getName()+&quot;,&quot;+customer2.getAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,Tom,20</span><br></pre></td></tr></table></figure><p>Class类是Reflection API 中的核心类，它有以下方法 :</p><ul><li><p>getName()：获得类的完整名字。</p></li><li><p>getFields()：获得类的public类型的属性。</p></li><li><p>getDeclaredFields()：获得类的所有属性。</p></li><li><p>getMethods()：获得类的<strong>public类型</strong>的方法。</p></li><li><p>getDeclaredMethods()：获得类的所有方法。</p><p>Method类的invoke(Object obj,Object args[])方法<strong>接 收的参数必须为对象</strong>，如果参数为基本类型数据，必须转 换为相应的包装类型的对象。<strong>invoke()方法的返回值总是 对象</strong>，如果实际被调用的方法的返回类型是基本类型数据 ，那么invoke()方法会把它转换为相应的包装类型的对象 ，再将其返回.</p></li></ul><p>下面我们来看看数组，java.lang.Array 类提供了动态创建和访 问数组元素的各种静态方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">public class ArrayTester1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">Object array = Array.newInstance(classType, 10);</span><br><span class="line"></span><br><span class="line">Array.set(array, 5, &quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">String str = (String)Array.get(array, 5);</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>hello</p><hr><p>创建 了一个 5 x 10 x 15 的整型数组，并把索 引位置为[3][5][10] 的元素的值为设37</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line">public class ArrayTester2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int[] dims = new int[] &#123; 5, 10, 15 &#125;;</span><br><span class="line"></span><br><span class="line">Object array = Array.newInstance(Integer.TYPE, dims);</span><br><span class="line"></span><br><span class="line">System.out.println(array instanceof int[][][]);</span><br><span class="line"></span><br><span class="line">//二维数组</span><br><span class="line">Object arrayObj = Array.get(array, 3);</span><br><span class="line"></span><br><span class="line">//Class&lt;?&gt; classType=arrayObj.getClass().getComponentType();</span><br><span class="line">//System.out.println(classType);</span><br><span class="line"></span><br><span class="line">//一维数组</span><br><span class="line">arrayObj = Array.get(arrayObj, 5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array.setInt(arrayObj, 10, 37);</span><br><span class="line"></span><br><span class="line">int[][][] arrayCast = (int[][][]) array;</span><br><span class="line"></span><br><span class="line">System.out.println(arrayCast[3][5][10]);</span><br><span class="line"></span><br><span class="line">// System.out.println(Integer.TYPE);</span><br><span class="line">// System.out.println(Integer.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">37</span><br></pre></td></tr></table></figure><ol><li>Integer.TYPE 返回的是 int，而 Integer.class 返回的是 Integer 类所对应的 Class 对象。</li></ol><p>反射破坏了类的封装性，可以调用私有的方法，变量，接下来我们一起来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PivateTest &#123;</span><br><span class="line"></span><br><span class="line">private String sayHello(String name) &#123;</span><br><span class="line">return &quot;hello&quot;+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Private &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">PivateTest private1 = new PivateTest();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=private1.getClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Method  method = classType.getDeclaredMethod(&quot;sayHello&quot;, new Class[] &#123;String.class&#125;);</span><br><span class="line"></span><br><span class="line">method.setAccessible(true);//压制java的访问权限的内部检查</span><br><span class="line"></span><br><span class="line">String string = (String)method.invoke(private1, new Object[] &#123;&quot;  zhangsan&quot;&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello  zhangsan</span><br></pre></td></tr></table></figure><p>用反射更改私有的成员变量的值，怎么实现呢，我们来看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class Private2 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private String name=&quot;zhangsan&quot;;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">Private2 private2 = new Private2();</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType=Private.class;</span><br><span class="line"></span><br><span class="line">Field field=classType.getDeclaredField(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">//压制java对访问修饰符的检查</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//对于属性的操作，直接使用get或是set方法就可以了</span><br><span class="line">field.set(private2, &quot;lisi&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(private2.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lisi</span><br></pre></td></tr></table></figure><p>众所周知Java有个Object class，是所有 Java classes的继承根源，其内声明了数 个应该在所有Java class中被改写的 methods：hashCode()、equals()、 clone()、toString()、getClass()等。其 中getClass()返回一个Class object。</p><ul><li>Class class十分特殊。它和一般classes一样继承自 Object，其实体用以表达Java程序运行时的classes和 interfaces，也用来表达enum、array、primitive Java types</li><li>（boolean, byte, char, short, int, long, float, double）以及关键词void。当一个class被加载，或当加 载器（class loader）的defineClass()被JVM调用， JVM 便自动产生一个Class object。如果您想借由“修 改Java标准库源码”来观察Class object的实际生成时 机（例如在Class的constructor内添加一个println()） ，不能够！因为Class并没有public constructor<br>只有java虚拟机可以创建一个Class</li></ul><ul><li>Class是Reflection起源。针对任何您想探 勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十 多个的Reflection APIs</li></ul><p><strong>为什么获得Method object时不需指定回返类型？</strong></p><ul><li>因为method overloading机制要求 signature必须唯一，而回返类型并非 signature的一个成份。换句话说，只要指定了method名称和参数列，就一定指出了 一个独一无二的method。（在方法重载的那个地方也是这样）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ClassTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Class&lt;?&gt; classType = Child.class;</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line"></span><br><span class="line">classType = classType.getSuperclass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Parent&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Child</span><br><span class="line">class Parent</span><br><span class="line">class java.lang.Object</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>什么时候能用到反射呢？</p><p>实际开发中一般是用不到反射的，除非自己去写框架肯定会用到反射，掌握了反射机制，对于以后学框架有利，理解更深入。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的反射机制深入剖析（一）</title>
      <link href="/2017/05/24/reflection1/"/>
      <url>/2017/05/24/reflection1/</url>
      <content type="html"><![CDATA[<p>我们来谈谈反射，这个知识点有些难度，不好理解，我介绍的详细一些，尽量细致，不对的地方往大家指正。</p><p>我们平时编的代码和接触到的都是在java编译环境中的，而在java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是<strong>肯定的</strong> 这种动态获取类的信息以及动态调用对象的方法的功能来自于java语言的反射机制。</p><p>java反射机制的功能</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ul><p>编程语言分为动态语言和静态语言</p><p>动态语言：程序运行时，允许改变程序结构或变量类型。Perl,Python,Ruby是动态语言，而C++，java，C#不是动态语言。</p><p>而反射机制是java被视为动态语言的一个关键性质。这个机制允许程序在运行时透过Reflaction APIs取得任何一个已知名称的class的内部信息。包括其 modifiers（诸如public, static 等等）、superclass（ 例如Object）、实现之interfaces（例如Serializable） ，也包括fields和methods的所有信息，并可于运行时改 变fields内容或调用methods</p><p>尽管在这样的定义与分类下Java不是动态语言， 它却有着一个非常突出的动态相关机制： Reflection。这个字的意思是“反射、映象、倒 影”，用在Java身上指的是我们可以于运行时加 载、探知、使用编译期间完全未知的classes。换 句话说，Java程序可以加载一个运行时才得知名 称的class，获悉其完整构造（但不包括 methods定义），并生成其对象实体、或对其 fields设值、或唤起其methods。这种“看透 class”的能力（the ability of the program to examine itself）被称为introspection（内省、 内观、反省）。Reflection和introspection是常 被并提的两个术语。</p><p>在JDK中，主要由以下类来实现Java反射机制，这些类都 位于java.lang.reflect包中</p><ul><li>Class类：代表一个类。</li><li>Field 类：代表类的成员变量（成员变量也称为类的属性）。</li><li>Method类：代表类的方法。</li><li>Constructor 类：代表类的构造方法。</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li></ul><p>了解了这么多理论，大家也晕了吧，让我们来看看反射在程序中怎么使用的。。。</p><p>来介绍一下基本的作用<br><strong>java中，无论生成某各类的多少个对象，这些对象都会对应于同一个Class对象。这个Class对象是在没有生成任何类之前由jvm帮我们生成好的，在类被装载的时候Class对象就已经生成好了。这个Class对象生成好之后就会获悉我们当前类所有的成员变量以及所有的方法。</strong></p><p>首先要获得class类，这里不止一种方式，我会陆续介绍给大家。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DumpMehtod &#123;</span><br><span class="line"></span><br><span class="line">//这里我们主要是学习反射，对于异常的问题就直接抛出了</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得class类的第一种方式</span><br><span class="line">Class&lt;?&gt; class1 = Class.forName(&quot;java.lang.Object&quot;); </span><br><span class="line"></span><br><span class="line">Method[] methods = class1.getDeclaredMethods();</span><br><span class="line">//增强的for循环</span><br><span class="line">for(Method method: methods) &#123;</span><br><span class="line">System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果将获得Object类的所有方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void java.lang.Object.finalize() throws java.lang.Throwable</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public java.lang.String java.lang.Object.toString()</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">private static native void java.lang.Object.registerNatives()</span><br></pre></td></tr></table></figure><p>接下来再深入了解通过反射调用自己定义的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class InvokeTest &#123;</span><br><span class="line"></span><br><span class="line">public int  add(int a, int b) &#123;</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String echo(String string) &#123;</span><br><span class="line">return &quot;hello&quot;+string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">    </span><br><span class="line">    //平时的调用步骤</span><br><span class="line">    // InvokeTester test = new InvokeTester();</span><br><span class="line">// System.out.println(test.add(1, 2));</span><br><span class="line">// System.out.println(test.echo(&quot;tom&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获得class类的第二种方法，泛型中的？表示继承Object</span><br><span class="line">Class&lt;?&gt; classType = InvokeTest.class; </span><br><span class="line">//将类进行实例</span><br><span class="line">Object incokeTest=classType.newInstance();</span><br><span class="line">//获得类的方法，</span><br><span class="line">//使用class类调用getMethod（）方法</span><br><span class="line">//第一个参数是类的名称，第二个参数为方法的形式参数所对应的class对象构成的数组</span><br><span class="line">Method addMethod = classType.getMethod(&quot;add&quot;, new Class[] &#123;int.class,int.class&#125;);</span><br><span class="line">//调用方法的invoke（）方法，执行此方法，</span><br><span class="line">//第一个参数为此类的实例，第二个参数是为这个方法传递的参数组成的数组</span><br><span class="line">//自动装箱</span><br><span class="line">Object result=addMethod.invoke(incokeTest, new Object[]&#123;1,2&#125;);</span><br><span class="line">//返回的肯定是一个Integer类型，这里是自动拆箱</span><br><span class="line">System.out.println((Integer)result);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">Method echoMethod=classType.getMethod(&quot;echo&quot;, new Class[] &#123;String.class&#125;);</span><br><span class="line"></span><br><span class="line">Object result2=echoMethod.invoke(incokeTest, new Object[] &#123;&quot;  world&quot;&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println((String)result2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">--------------------------------------------------</span><br><span class="line">hello  world</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中的内部类详细解析</title>
      <link href="/2017/03/02/inner-class/"/>
      <url>/2017/03/02/inner-class/</url>
      <content type="html"><![CDATA[<p>来说一说内部类，内部类一共分为四种，分别是</p><ol><li>静态内部类</li><li>局部内部类</li><li>成员内部类</li><li>匿名内部类</li></ol><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>类的成员</p><ol><li>成员变量</li><li>成员方法</li><li>构造方法</li><li>代码块</li><li>静态代码块</li><li>内部类</li></ol><p>按照内部类声明方式</p><ol><li>静态内部类<ul><li>static</li><li>属于类：类比于静态变量 静态方法，没有外部类的引用（不需要对象）（直接使用外部类的this也就是意味着不能直接访问外部类的非静态属性</li></ul></li></ol><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li><strong>静态内部类可以直接访问外部类的静态成员变量，静态内部类不可以直接 访问外部类的非静态成员变量</strong></li><li>调用方式：</li></ol><ul><li><p>导包的时候倒到外部类名为止<br>外部类类名.内部类类名 内部类对象名=new 外部类类名.内部类类名（）；</p></li><li><p>导包的时候倒到内部类的类名为止</p><p>内部类类名 内部类的对象名 =new 内部类类名 （）；</p><ul><li>内部类的对象名.内部类方法名（）；</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClass &#123;</span><br><span class="line"> static  int a=12;</span><br><span class="line"> //静态内部类</span><br><span class="line">     public static class Moo&#123;</span><br><span class="line">     int b=13;</span><br><span class="line">     public void add()&#123;</span><br><span class="line">     int c=14;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">Moo m=new Moo();</span><br><span class="line">m.add();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import com.qf.oop.innerclass.StaticInnerClass;</span><br><span class="line">import com.qf.oop.innerclass.StaticInnerClass.Moo;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*StaticInnerClass.Moo m=new StaticInnerClass.Moo();</span><br><span class="line">m.add();*/</span><br><span class="line">Moo m=new Moo();</span><br><span class="line">m.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>方法中<br>外部方法中的内部类，访问外部类局部变量</p><p>注意：</p><ol><li>局部内部类随方法的调用而被加载</li><li>也可以访问外部类的私有属性 持有外部类应用可以使用this</li><li>局部内部类的对象只能在该类中创建</li><li>局部内部类当中，如果访问外部类的局部变量（方法中的变量）一定是常量（使用final修饰）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class LocInnerClass &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">  final int a=12;</span><br><span class="line">  class Moo&#123;</span><br><span class="line">  int b=13;</span><br><span class="line">  public void add()&#123;</span><br><span class="line">  int c=14;</span><br><span class="line"> // a++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Moo m=new Moo();</span><br><span class="line">  m.add();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  LocInnerClass l=new LocInnerClass();</span><br><span class="line">  l.test();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void test()&#123;</span><br><span class="line">   final int a=12;</span><br><span class="line">  class Moo&#123;</span><br><span class="line">  int b=13;</span><br><span class="line">  public void add()&#123;</span><br><span class="line">  int c=14;</span><br><span class="line"> // a++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  System.out.println(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Moo m=new Moo();</span><br><span class="line">  m.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 2.成员内部类 可以使用4种访问权限符修饰</span><br><span class="line"> *   调用方式</span><br><span class="line"> *     第一种方式：</span><br><span class="line"> *       外部类类名 外部类对象名=new 外部类类名（）；</span><br><span class="line"> *       外部类类名.内部类类名 内部类对象名= 外部类对象名.new 内部类类名();</span><br><span class="line"> *       内部类对象名.方法名（）；</span><br><span class="line"> *      第二种方式：</span><br><span class="line"> *        外部类类名.内部类类名 内部类对象名=new 外部类类名（）.new 内部类类名（）；</span><br><span class="line"> *        内部类对象名.方法名（）；</span><br><span class="line"> * </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class InnerClass &#123;</span><br><span class="line">int a=12;</span><br><span class="line">   //成员内部类</span><br><span class="line">   public class Moo&#123;</span><br><span class="line">   int b=13;</span><br><span class="line">   public void add()&#123;</span><br><span class="line">   int c=14;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   /*InnerClass in=new InnerClass();</span><br><span class="line">   System.out.println(in.a);*/</span><br><span class="line">   //第一种方式</span><br><span class="line">   InnerClass in=new InnerClass();</span><br><span class="line">   InnerClass.Moo m=in.new Moo();</span><br><span class="line">   m.add();</span><br><span class="line">   InnerClass.Moo m1=in.new Moo();</span><br><span class="line">   m1.add();</span><br><span class="line">   </span><br><span class="line">   //第二种方式</span><br><span class="line">   InnerClass.Moo m3=new InnerClass().new Moo();</span><br><span class="line">   m3.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类变量名称一致的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InnerClass2 &#123;</span><br><span class="line">int a=12;</span><br><span class="line">   //成员内部类</span><br><span class="line">   public class Moo&#123;</span><br><span class="line">   int a=13;</span><br><span class="line">   public void add()&#123;</span><br><span class="line">   int a=14;</span><br><span class="line">   System.out.println(a);</span><br><span class="line">   System.out.println(&quot;内部类成员变量a=&quot;+new Moo().a);</span><br><span class="line">   System.out.println(&quot;内部类成员变量a=&quot;+this.a);</span><br><span class="line">   System.out.println(&quot;外部类的成员变量a=&quot;+new InnerClass2().a);</span><br><span class="line">   System.out.println(&quot;外部类的成员变量a=&quot;+InnerClass2.this.a);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">   //第二种方式</span><br><span class="line">   InnerClass2.Moo m3=new InnerClass2().new Moo();</span><br><span class="line">   m3.add();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>语法：</p><p>类名 对象名 = new 类名（）{<br>实现抽象方法<br>}</p><p>注意：</p><p>匿名内部类没有构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 匿名内部类：没有名字</span><br><span class="line"> * 语法：</span><br><span class="line"> *   类名 对象名=new 类名()&#123;</span><br><span class="line"> *      实现抽象方法</span><br><span class="line"> *   &#125;;</span><br><span class="line"> * 注意：</span><br><span class="line"> *   匿名内部类没有构造方法</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class NoNameInnerClass &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">    //AA a=new AA();</span><br><span class="line">    AA a=new BB();</span><br><span class="line">    a.add();</span><br><span class="line">    AA a1=new BB();</span><br><span class="line">    a1.add();</span><br><span class="line">    </span><br><span class="line">    //Animal an=new Animal();</span><br><span class="line">    Cat c=new Cat()&#123;</span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;猫咪正在和老鼠玩耍&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">    </span><br><span class="line">    Cat c1=new Cat()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;小猫咪抓老鼠&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    &#125;;</span><br><span class="line">    c1.catchMouse();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Cat c3=new MImi();</span><br><span class="line">    c3.catchMouse();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class AA&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;奔跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public abstract void add();</span><br><span class="line">&#125;</span><br><span class="line">class BB extends AA&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add() &#123;</span><br><span class="line">System.out.println(12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Animal&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">interface Cat extends Animal&#123;</span><br><span class="line">void catchMouse();</span><br><span class="line">&#125;</span><br><span class="line">class MImi implements Cat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void catchMouse() &#123;</span><br><span class="line">System.out.println(&quot;小猫咪抓老鼠&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java小项目----DVD管理系统</title>
      <link href="/2017/02/07/dvd/"/>
      <url>/2017/02/07/dvd/</url>
      <content type="html"><![CDATA[<p>做了一个DVD的管理系统，包含了增删改查\借出和归还等功能和日期与字符串的装换问题，使用了最简单的java基础知识，封装了方法，属性，实现了基本的功能。这个系统同样适用于图书馆管理系统，里面也实现了借出和归还的功能。</p><p>下面给大家分析一下这个系统：</p><ul><li>用例1：数据初始化</li><li>用例2：实现菜单切换</li><li>用例3：实现查看DVD信息</li><li>用例4：实现新增DVD信息</li><li>用例5：实现删除DVD信息</li><li>用例6：实现借出DVD业务处理</li><li>用例7：实现归还DVD业务处理</li></ul><p><img src="http://img.blog.csdn.net/20171120101502937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171120101517209?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171120101539244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="4"></p><p><img src="http://img.blog.csdn.net/20171120101554328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="5"></p><p><img src="http://img.blog.csdn.net/20171120101638591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="6"></p><p><img src="http://img.blog.csdn.net/20171120101651943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="7"></p><p><img src="http://img.blog.csdn.net/20171120101709822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="8"></p><p><img src="http://img.blog.csdn.net/20171120101719262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="9"></p><p><img src="http://img.blog.csdn.net/20171120101756945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="10"></p><p><img src="http://img.blog.csdn.net/20171120101822847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="11"></p><p><img src="http://img.blog.csdn.net/20171120101832412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="12"></p><p><img src="http://img.blog.csdn.net/20171120101843800?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="13"></p><p><img src="http://img.blog.csdn.net/20171120101854670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="14"></p><p><img src="http://img.blog.csdn.net/20171120101907654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="15"></p><p>下面是源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class DVDSet &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line">int state;</span><br><span class="line">String date;</span><br><span class="line"></span><br><span class="line">public DVDSet() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DVDSet(String name, int state, String date) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.state = state;</span><br><span class="line">this.date = date;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">if(state==0) &#123;</span><br><span class="line">return  name + &quot;\t  &quot; + &quot;已借出&quot; + &quot;\t&quot; + date ;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return  name + &quot;\t  &quot; + &quot;可借&quot; + &quot;\t&quot; + date ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getState() &#123;</span><br><span class="line">return state;</span><br><span class="line">&#125;</span><br><span class="line">public void setState(int state) &#123;</span><br><span class="line">this.state = state;</span><br><span class="line">&#125;</span><br><span class="line">public String getDate() &#123;</span><br><span class="line">return date;</span><br><span class="line">&#125;</span><br><span class="line">public void setDate(String date) &#123;</span><br><span class="line">this.date = date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class DVDMgr &#123;</span><br><span class="line"></span><br><span class="line">final int LENGTH = 20;</span><br><span class="line"></span><br><span class="line">DVDSet[] dvd = new DVDSet[LENGTH];</span><br><span class="line"></span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">// 在构造器中传入日期样式</span><br><span class="line">// SimpleDateFormat sdf=new SimpleDateFormat(</span><br><span class="line">// &quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot;);</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">public void startMenu() &#123;</span><br><span class="line">printMain();</span><br><span class="line">// 初始化</span><br><span class="line">initial();</span><br><span class="line"></span><br><span class="line">int key = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">// 菜单切换</span><br><span class="line">switch (key) &#123;</span><br><span class="line">case 1:</span><br><span class="line">System.out.print(&quot;请输入新增的DVD名称：&quot;);</span><br><span class="line"></span><br><span class="line">String dName = scanner.next();</span><br><span class="line">System.out.println(&quot;您要增加的DVD名字是《&quot; + dName + &quot;》&quot;);</span><br><span class="line"></span><br><span class="line">add(dName);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">System.out.println(&quot;DVD信息如下：&quot;);</span><br><span class="line">System.out.println(&quot;name\tstate\tdate&quot;);</span><br><span class="line">search();</span><br><span class="line"></span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">System.out.print(&quot;请输入要删除的DVD名称：&quot;);</span><br><span class="line">String deleteN = scanner.next();</span><br><span class="line">System.out.println(&quot;您要删除的DVD名称为《&quot; + deleteN + &quot;》&quot;);</span><br><span class="line"></span><br><span class="line">delete(deleteN);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 4:</span><br><span class="line">System.out.print(&quot;请输入你要借的DVD的名称：&quot;);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"></span><br><span class="line">loan(name);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 5:</span><br><span class="line">System.out.print(&quot;请输入你要归还的DVD的名称：&quot;);</span><br><span class="line">String guihuan = scanner.next();</span><br><span class="line"></span><br><span class="line">returnDvd(guihuan);</span><br><span class="line">returnMain();</span><br><span class="line">break;</span><br><span class="line">case 6:</span><br><span class="line">System.exit(0);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;您输入的有误，请重新输入！&quot;);</span><br><span class="line">startMenu();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printMain() &#123;</span><br><span class="line">// 主菜单显示</span><br><span class="line">System.out.println(&quot;欢迎使用迷你DVD管理器&quot;);</span><br><span class="line">System.out.println(&quot;========================================================&quot;);</span><br><span class="line">System.out.println(&quot;1. 新增DVD&quot;);</span><br><span class="line">System.out.println(&quot;2. 查看DVD&quot;);</span><br><span class="line">System.out.println(&quot;3. 删除DVD&quot;);</span><br><span class="line">System.out.println(&quot;4. 借出 DVD&quot;);</span><br><span class="line">System.out.println(&quot;5. 归还DVD&quot;);</span><br><span class="line">System.out.println(&quot;6. 退       出&quot;);</span><br><span class="line">System.out.println(&quot;========================================================&quot;);</span><br><span class="line">System.out.print(&quot;请选择：&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void returnMain() &#123;</span><br><span class="line">System.out.print(&quot;输入0返回：&quot;);</span><br><span class="line">int reStep = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">if (reStep == 0) &#123;</span><br><span class="line">startMenu();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;您输入的有误，请重新输入!&quot;);</span><br><span class="line">returnMain();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void initial() &#123;</span><br><span class="line">dvd[0] = new DVDSet(&quot;罗马假日&quot;, 0, &quot;2013-7-1&quot;);</span><br><span class="line">dvd[1] = new DVDSet(&quot;风声鹤唳&quot;, 1, &quot;&quot;);</span><br><span class="line">dvd[2] = new DVDSet(&quot;浪漫满屋&quot;, 1, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void search() &#123;</span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] != null) &#123;</span><br><span class="line">System.out.println(dvd[i]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(String string) &#123;</span><br><span class="line"></span><br><span class="line">String formatDate = dvdDate();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">dvd[i] = new DVDSet();</span><br><span class="line">dvd[i].setName(string);</span><br><span class="line">dvd[i].setState(1);</span><br><span class="line">dvd[i].setDate(formatDate);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void delete(String string) &#123;</span><br><span class="line">boolean b = false;</span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (string.equals(dvd[i].getName())) &#123;</span><br><span class="line">System.out.println(dvd[i]);</span><br><span class="line">if (dvd[i].getState() == 0) &#123;</span><br><span class="line">System.out.println(&quot;你要删除的DVD已借出，不可以删除！&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; dvd.length - 1) &#123;</span><br><span class="line">dvd[i] = dvd[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">dvd[dvd.length - 1] = null;</span><br><span class="line">System.out.println(&quot;您删除的《&quot; + string + &quot;》&quot; + &quot;删除成功&quot;);</span><br><span class="line">b = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!b) &#123;</span><br><span class="line">System.out.println(&quot;你输入的DVD不存在。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// returnMain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void loan(String string) &#123;</span><br><span class="line">boolean b = false;</span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (string.equals(dvd[i].getName())) &#123;</span><br><span class="line">if (dvd[i].getState() != 0) &#123;</span><br><span class="line">b = true;</span><br><span class="line">dvd[i].setState(0);</span><br><span class="line">System.out.println(&quot;你成功借出了《&quot; + string + &quot;》&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;此书已经借出&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!b) &#123;</span><br><span class="line">System.out.println(&quot;你要借的DVD不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void returnDvd(String string) &#123;</span><br><span class="line">boolean b = false;</span><br><span class="line">String date = dvdDate();</span><br><span class="line">DecimalFormat df = new DecimalFormat(&quot;######0.00&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; dvd.length; i++) &#123;</span><br><span class="line">if (dvd[i] == null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (string.equals(dvd[i].getName())) &#123;</span><br><span class="line">if (dvd[i].getState() != 1) &#123;</span><br><span class="line">b = true;</span><br><span class="line">dvd[i].setState(1);</span><br><span class="line">System.out.println(&quot;你成功归还了《&quot; + string + &quot;》&quot;);</span><br><span class="line">System.out.println(&quot;借出日期为：&quot; + dvd[i].getDate());</span><br><span class="line">System.out.println(&quot;归还日期为：&quot; + date);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">long a = sdf.parse(date).getTime() - sdf.parse(dvd[i].getDate()).getTime();</span><br><span class="line">double d = a * 0.0000000001;</span><br><span class="line"></span><br><span class="line">df.format(d);</span><br><span class="line">System.out.println(&quot;应付租金（元）：&quot; + d);</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;此书未借出&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!b) &#123;</span><br><span class="line">System.out.println(&quot;你要归还的DVD不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String dvdDate() &#123;</span><br><span class="line">// sdf=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);</span><br><span class="line">// 当前系统时间</span><br><span class="line">Date date = new Date();</span><br><span class="line">// 调用format(Date date)对象传入的日期参数进行格式化</span><br><span class="line">// format(Date date)将日期转化成字符串</span><br><span class="line">String formatDate = sdf.format(date);</span><br><span class="line">// System.out.println(&quot;格式化后的日期为:&quot; + formatDate);</span><br><span class="line"></span><br><span class="line">return formatDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">DVDMgr dvdMgr = new DVDMgr();</span><br><span class="line">dvdMgr.startMenu();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中abstract详解</title>
      <link href="/2017/01/28/abstract/"/>
      <url>/2017/01/28/abstract/</url>
      <content type="html"><![CDATA[<p>今天来介绍一下抽象类。我们用动物类来看，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal= new Animal();</span><br><span class="line">animal.name=&quot;动物&quot;;</span><br><span class="line">animal.shout();</span><br><span class="line">animal.sleep();</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.name= &quot;旺财&quot;;</span><br><span class="line">System.out.print(&quot;狗狗&quot;+dog.name);</span><br><span class="line">dog.shout();</span><br><span class="line">dog.sleep();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.name=&quot;小花&quot;;</span><br><span class="line">System.out.print(&quot;猫咪&quot;+cat.name);</span><br><span class="line">cat.shout();</span><br><span class="line">cat.sleep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">狗狗旺财汪汪叫</span><br><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">猫咪小花喵喵叫</span><br><span class="line">闭上眼睛就睡觉</span><br></pre></td></tr></table></figure><p>从上面的类中我们可以发现animal类中的shout（）方法在生活中几乎是不可能用到的，于是我们为了代码的简洁，shout（）方法不需要方法体，但是会报错误This method requires a body instead of a semicolon。于是我们便引入了abstract关键字。当我们加上abstract之后，还是会报错误The abstract method shout in type Animal can only be defined by an abstract class。那么怎么办呢？抽象方法需要在抽象类中定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void shout() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动物类</span><br><span class="line"> * shout(); 这个方法里的方法体没有用 但这个方法不能注释 让子类重写</span><br><span class="line"> * 1.abstract抽象的</span><br><span class="line"> *   The abstract method shout in type Animal can only be defined by an abstract class</span><br><span class="line"> * 2.如何定义一个抽象方法</span><br><span class="line"> *   语法：</span><br><span class="line"> *     【访问权限符】 abstract 返回值 方法名();</span><br><span class="line"> *   eg：</span><br><span class="line"> *      public abstract void shout();</span><br><span class="line"> * 3.如何定义一个抽象类</span><br><span class="line"> *   语法：</span><br><span class="line"> *    【访问权限符】  abstract class 类名&#123;&#125;</span><br><span class="line"> *   eg:</span><br><span class="line"> *    public abstract class Animal &#123;</span><br><span class="line"> *    &#125;</span><br><span class="line"> * 4.总结</span><br><span class="line"> *     A.抽象方法一定要在抽象类中</span><br><span class="line"> *     B.抽象类中可以有   0 1 多个 抽象方法</span><br><span class="line"> *     C.抽象类不能直接实例对象 只能创建子类对象 抽象类一定要被继承</span><br><span class="line"> *       Cannot instantiate the type Animal</span><br><span class="line"> *     D.子类继承父类 如果父类是抽象类 子类一定要实现父类里所有的抽象方法 除非子类也是抽象类</span><br><span class="line"> *     E.abstract可以修饰   类  方法</span><br><span class="line"> *               不能修饰   成员变量 构造方法</span><br><span class="line"> *     F.抽象类中的成员</span><br><span class="line"> *               成员变量   成员方法  构造方法       </span><br><span class="line"> *        </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>总结一下知识点：</p><ol><li><p>语法</p><p>A.抽象类和抽象方法必须使用 abstract修饰<br>B.抽象类不能直接实例 只能被继承<br>C.抽象类必须有构造方法 创建子类对象时候需要<br>D.抽象类可以有至少0个抽象方法<br>E.抽象方法只有声明没有实现（名字 没有方法体）<br>F.public abstract void shout(){} 不是抽象方法<br>G.子类必须重写抽象方法，如果不重写，自己也得是抽象类</p></li></ol><p>2.意义<br>A.抽象类为所有子类提供了一个通用模板,子类可以在此模板上进行扩展<br>B.通过抽象类，可以避免子类设计随意性<br>C.通过抽象类，可以严格限制子类的设计，使得子类更加通用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类就是用来作父类的用来被继承的</span><br></pre></td></tr></table></figure><p>问题1：<br>Animal an=new Animal(); 没有一种生物叫Animal 创建Animal没有意义<br>拒绝实例<br>解决方法：<br>Animal类 定义为抽象类<br>抽象类不能直接实例但可以被继承</p><p>问题2:<br>dog可以重写shout也可以不重写 如果希望dog必须重写shout方法 不重写就有编译错误</p><p>解决方法：<br>Animal类 里的shout方法定义为抽象方法<br>抽象方法只有声明，没有实现</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--策略模式（strategy-pattern）解析</title>
      <link href="/2016/11/08/strategy/"/>
      <url>/2016/11/08/strategy/</url>
      <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）中体现了两个非常基本的面相对象设计的原则：</p><ol><li>封装变化的概念</li><li>编程中使用接口，而不是对接口的实现</li></ol><p>策略模式的定义 ：</p><ul><li>定义一组算法，将每个算法都封装起来，并且 使它们之间可以互换。</li><li>策略模式使这些算法在客户端调用它们的时候 能够互不影响地变化</li></ul><p>策略模式的意义</p><ul><li><p>策略模式使开发人员能够开发出由许多可替换 的部分组成的软件，并且各个部分之间是弱连 接的关系。</p></li><li><p>弱连接的特性使软件具有更强的可扩展性，易 于维护；更重要的是，它大大提高了软件的可 重用性</p><p>策略模式的组成</p></li><li><p>抽象策略角色：策略类，通常由一个接口或者 抽象类实现</p></li><li><p>具体策略角色：包装了相关的算法和行为</p></li><li><p>环境角色：持有一个策略类的引用，最终给客 户端调用的。</p><p>策略模式的实现</p></li><li><p>策略模式的用意是针对一组算法，将每一个算 法封装到具有共同接口的独立的类中，从而使 得它们可以相互替换。</p></li><li><p>策略模式使得算法可以在不影响到客户端的情 况下发生变化。使用策略模式可以把行为和环 境分割开来。</p></li><li><p>环境类负责维持和查询行为类，各种算法则在 具体策略中提供。由于算法和环境独立开来， 算法的修改都不会影响环境和客户端</p></li></ul><p>策略模式的编写步骤 ：</p><ol><li>对策略对象定义一个公共接口。</li></ol><p>2．编写策略类，该类实现了上面的公共接口</p><p>3．在使用策略对象的类中保存一个对策略对 象的引用。</p><p>4．在使用策略对象的类中，实现对策略对象 的set和get方法（注入）或者使用构造方法完 成赋值</p><p>小提示：在eclipse里面Ctrl+t 进入到实现类的代码中去。</p><p>下面我们以计算器为例实现我们的策略模式：</p><h6 id="抽象策略角色"><a href="#抽象策略角色" class="headerlink" title="抽象策略角色"></a>抽象策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="具体策略角色"><a href="#具体策略角色" class="headerlink" title="具体策略角色"></a>具体策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AddStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SubtractStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MultiplyStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class DivideStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Environment &#123;</span><br><span class="line"></span><br><span class="line">private Strategy strategy;</span><br><span class="line"></span><br><span class="line">public Environment (Strategy strategy) &#123;</span><br><span class="line">this.strategy= strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Strategy getStrategy() &#123;</span><br><span class="line">return strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b) &#123;</span><br><span class="line">return strategy.calculate(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AddStrategy addStrategy = new AddStrategy();</span><br><span class="line">Environment environment = new Environment(addStrategy);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;3+4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">SubtractStrategy strategy = new SubtractStrategy();</span><br><span class="line">environment.setStrategy(strategy);</span><br><span class="line">System.out.println(&quot;3-4=&quot;+environment.calculate(3, 4));</span><br><span class="line"></span><br><span class="line">MultiplyStrategy multiplyStrategy = new MultiplyStrategy();</span><br><span class="line">environment.setStrategy(multiplyStrategy);</span><br><span class="line">System.out.println(&quot;3*4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">DivideStrategy divideStrategy = new DivideStrategy();</span><br><span class="line">environment.setStrategy(divideStrategy);</span><br><span class="line">System.out.println(&quot;3/4=&quot;+environment.calculate(3,4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3+4=7</span><br><span class="line">3-4=-1</span><br><span class="line">3*4=12</span><br><span class="line">3/4=0</span><br></pre></td></tr></table></figure><p>策略模式的缺点</p><ul><li>客户端必须知道所有的策略类，并自行决定 使用哪一个策略类。</li><li>造成很多的策略类。</li></ul><p>解决方案</p><ul><li>采用工厂方法</li></ul><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中String类详细解析</title>
      <link href="/2016/04/24/string/"/>
      <url>/2016/04/24/string/</url>
      <content type="html"><![CDATA[<p>1.相等性的比较（==）<br>(1)对于原生数据类型来说，比较的是左右两边的值是否相等<br>（2）对于引用类型来说，比较左右两边的引用是否指向同一个对象，或者说左右两边的引用地址是否相同。</p><p>2.Object 类的tostring方法返回的是一个哈希code值，而string类重写了tostring方法，默认调用tostring方法。<br>API （Application Programming Interface），应用编程接口。<br>当打印引用时，实际上会打印出引用所指对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，而Object类中定义了toString()，因此每个类都有toString()这个方法。</p><p>3.equals方法<br>对于object类的equals方法来说，是用来判断两个对象是不是同一个对象。<br>对于继承了object类的其他类来说，如果重写了equals方法，才是判断内容是否一致，，如果没有重写equals方法，是判断地址是否一致。<br>对于String类的equals()方法来说，它是判断当前字符串与传进来的字符串的内容是否一致。</p><p>4.字符串是一个常量，创建之后值是不能被改变的。</p><p>5.String是常量，其对象一旦创建完毕就无法改变。当使用+拼接字符串时，会生成新的String对象，而不是向原有的String对象追加内容。</p><p>6、 String Pool（字符串池）</p><p>7、 String s = “aaa”;（采用字面值方式赋值）<br>1) 查找String Pool中是否存在“aaa”这个对象，如果不存在，则在String Pool中创建一个“aaa”对象，然后将String Pool中的这个“aaa”对象的地址返回来，赋给引用变量s，这样s会指向String Pool中的这个“aaa”字符串对象<br>2) 如果存在，则不创建任何对象，直接将String Pool中的这个“aaa”对象地址返回来，赋给s引用。</p><p>8、 String s = new String(“aaa”);<br>1) 首先在String Pool中查找有没有“aaa”这个字符串对象，如果有，则不在String Pool中再去创建“aaa”这个对象了，直接在堆中（heap）中创建一个“aaa”字符串对象，然后将堆中的这个“aaa”对象的地址返回来，赋给s引用，导致s指向了堆中创建的这个“aaa”字符串对象。<br>2) 如果没有，则首先在String Pool中创建一个“aaa“对象，然后再在堆中（heap）创建一个”aaa“对象，然后将堆中的这个”aaa“对象的地址返回来，赋给s引用，导致s指向了堆中所创建的这个”aaa“对象。</p><p>9.new出来的对象都是在堆里面</p><p>10.intern（）方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Object object = new Object();</span><br><span class="line">Object object2 = new Object();</span><br><span class="line"></span><br><span class="line">//object类中的equals方法是使用==判断的</span><br><span class="line">System.out.println(object == object2);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line">String str = new String(&quot;aaa&quot;);</span><br><span class="line">String str2 = new String(&quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(str == str2);//false两个对象</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">//StringPool字符串池在栈中，当字符串被赋予字面值的时候，首先检查字符串池里面有没有该对象&quot;bbb&quot;</span><br><span class="line">//如果没有，就将该字符串放入字符串池里面，字符串变量便指向这个对象</span><br><span class="line">//如果有，就不会在字符串池里面创建新的对象，而是在已有的字符串池里面的对象直接返回来赋给字符串变量str4</span><br><span class="line">//所以str4并没有创建对象</span><br><span class="line">//new出来的对象都是在堆里面</span><br><span class="line">String str3 = &quot;bbb&quot;;//创建一个对象</span><br><span class="line">String str4 = &quot;bbb&quot;;//并没有创建对象</span><br><span class="line"></span><br><span class="line">System.out.println(str3 == str4);//true指向同一个对象</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">String str5 = new String(&quot;ccc&quot;);</span><br><span class="line">String str6 = &quot;ccc&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(str5 == str6);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">//字符串的拼接并不是将字符串拼接到后面。字符串是常量，创建后就不能改变了，</span><br><span class="line">//加法操作实际上是生成了一个新的对象，而不是往原有的对象追加内容。</span><br><span class="line">String s = &quot;hello&quot;;//</span><br><span class="line">String s1 = &quot;hel&quot;;</span><br><span class="line">String s2 = &quot;lo&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s == s1 + s2);//false</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------------&quot;);</span><br><span class="line">System.out.println(s == &quot;hel&quot; + &quot;lo&quot;);//true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package testPackage;</span><br><span class="line">class Test &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                String hello = &quot;Hello&quot;, lo = &quot;lo&quot;;</span><br><span class="line">                System.out.print((hello == &quot;Hello&quot;) + &quot; &quot;);</span><br><span class="line">                System.out.print((Other.hello == hello) + &quot; &quot;);</span><br><span class="line">                System.out.print((other.Other.hello == hello) + &quot; &quot;);</span><br><span class="line">                System.out.print((hello == (&quot;Hel&quot;+&quot;lo&quot;)) + &quot; &quot;);</span><br><span class="line">                System.out.print((hello == (&quot;Hel&quot;+lo)) + &quot; &quot;);</span><br><span class="line">                System.out.println(hello == (&quot;Hel&quot;+lo).intern());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other &#123; static String hello = &quot;Hello&quot;; &#125;</span><br></pre></td></tr></table></figure><h6 id="and-the-compilation-unit"><a href="#and-the-compilation-unit" class="headerlink" title="and the compilation unit:"></a>and the compilation unit:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">public class Other &#123; static String hello = &quot;Hello&quot;; &#125;</span><br></pre></td></tr></table></figure><h6 id="produces-the-output"><a href="#produces-the-output" class="headerlink" title="produces the output:"></a>produces the output:</h6><p>true true true true false true</p><h6 id="This-example-illustrates-six-points"><a href="#This-example-illustrates-six-points" class="headerlink" title="This example illustrates six points:"></a>This example illustrates six points:</h6><p>1.Literal strings within the same class (§8) in the same package (§7) represent references to the same String object (§4.3.1).<br>2.Literal strings within different classes in the same package represent references to the same String object.<br>3.Literal strings within different classes in different packages likewise represent references to the same String object.<br>4.Strings computed by constant expressions (§15.28) are computed at compile time and then treated as if they were literals.<br>5.Strings computed by concatenation at run time are newly created and therefore distinct.</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中TreeSet底层解析和collections解析</title>
      <link href="/2016/03/27/treeset-collections/"/>
      <url>/2016/03/27/treeset-collections/</url>
      <content type="html"><![CDATA[<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>下图是集合框架中的接口<br><img src="http://img.blog.csdn.net/20171107204219357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>今天我来谈谈SortedSet接口。</p><p>TreeSet实现了SortedSet接口，如果有自然的顺序，TreeSet具有排序的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">set.add(&quot;C&quot;);</span><br><span class="line">set.add(&quot;A&quot;);</span><br><span class="line">set.add(&quot;B&quot;);</span><br><span class="line">set.add(&quot;E&quot;);</span><br><span class="line">set.add(&quot;F&quot;);</span><br><span class="line">set.add(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A,B,C,D,E,F]</span><br></pre></td></tr></table></figure><p>但是如果没有自然顺序的值还有正常的排序吗？我们一起来看看。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出现了，报错误了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other.Person cannot be cast to java.lang.Comparable</span><br></pre></td></tr></table></figure><p>不要慌张，去底层寻找解决办法。</p><p><img src="http://img.blog.csdn.net/20171107210401006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>遇到错误通过文档去查找，大部分都是可以解决的哦，一定要有耐心哟!<br>TreeSet是带有排序的，我们刚才没有给程序说按照什么规则比较，所以我们要向往TreeSet放置对象，我们必须要告诉TreeSet排序的规则，制定好排序的规则，但是在哪里指定呢？和我一起来查看TreeSet的构造方法吧。</p><p><img src="http://img.blog.csdn.net/20171107210824004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>改bug：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan2;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet(new PersonComparator());</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonComparator implements Comparator</span><br><span class="line">&#123;</span><br><span class="line">public int compare(Object arg0, Object arg1)</span><br><span class="line">&#123;</span><br><span class="line">Person p1 = (Person) arg0;</span><br><span class="line">Person p2 = (Person) arg1;</span><br><span class="line"></span><br><span class="line">return p2.score - p1.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">40</span><br><span class="line">30</span><br><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections的一些方法用起来还是很方便的，分享给大家，Collections里面的方法都是静态的，可以直接调用。<br>sort（）；排序<br>reverseOrder()；反序<br>shuffle（）;乱序<br>min();最小<br>max();最大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">LinkedList list = new LinkedList();</span><br><span class="line"></span><br><span class="line">list.add(new Integer(-8));</span><br><span class="line">list.add(new Integer(20));</span><br><span class="line">list.add(new Integer(-20));</span><br><span class="line">list.add(new Integer(8));</span><br><span class="line">//自然顺序的反序操作</span><br><span class="line">Comparator r = Collections.reverseOrder();</span><br><span class="line">//排序</span><br><span class="line">Collections.sort(list, r);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">//乱序</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;minimum value: &quot; + Collections.min(list));</span><br><span class="line">System.out.println(&quot;maximum value: &quot; + Collections.max(list));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">20 8 -8 -20 </span><br><span class="line">-20 20 -8 8 </span><br><span class="line">minimum value: -20</span><br><span class="line">maximum value: 20</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--单例模式</title>
      <link href="/2016/01/23/singleton/"/>
      <url>/2016/01/23/singleton/</url>
      <content type="html"><![CDATA[<p>单例模式分为两种：饿汉式、懒汉式</p><p>既然是单例模式，那么就只有一个实例，那么构造方法就是私有的，就需要创建一个对象，而且也需要是私有的，但是需要调用所以要设置成静态的，然后提供一个方法拿到这个私有的对象。<br>一个类只会生成唯一的一个对象。</p><p>单例模式：饿汉式</p><p>1.私有构造方法<br>2.创建私有的静态对象<br>3.创建一个公共公开的方法，返回该私有对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Single1 &#123;</span><br><span class="line">  private static Single1 s1=new Single1();</span><br><span class="line">  private Single1()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static  Single1 getInstance()&#123;</span><br><span class="line">  return s1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">/*Single1 s1=new Single1();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=new Single1();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);*/</span><br><span class="line">Single1 s1=Single1.getInstance();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=Single1.getInstance();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>饿汉式就是更急切的new出来了对象，而懒汉式就不这样了，其实，本质是一样的，让我们来看看懒汉吧。</p><p>单例模式：懒汉式</p><p>1.私有构造方法</p><ol><li>创建私有静态对象<br>3.创建公开公共的静态方法返回该私有对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Single2 &#123;</span><br><span class="line">  private static Single2 s2=null;</span><br><span class="line">  private Single2()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  s2=new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;</span><br><span class="line">  &#125;</span><br><span class="line">  /*public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  return new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;  错误的</span><br><span class="line">  &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Single2 s1=Single2.getInstance();</span><br><span class="line">  System.out.println(s1);</span><br><span class="line">  Single2 s2=Single2.getInstance();</span><br><span class="line">  System.out.println(s2);</span><br><span class="line">  System.out.println(s1==s2);</span><br><span class="line">  //Object</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式的单例模式有一种错误的方法，我已经在代码中写出来了，大家一定要注意，仔细一点哦。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式--工厂模式解析</title>
      <link href="/2015/10/02/factory/"/>
      <url>/2015/10/02/factory/</url>
      <content type="html"><![CDATA[<p>在看工厂模式之前我们先了解一下面相对象的原则。</p><p>面向对象设计的基本原则</p><ul><li>OCP开闭原则：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP依赖倒转原则：要针对接口编程，不要针对实现编程</li><li>LOD迪米特法则：只与你直接的朋友通信，而避免和陌生人通话。</li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>实现了创建者和调用者的分离，下面我用汽车类的例子来介绍。</p><p>详细分类</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>也称之为静态工厂模式，项目开发中通常使用</p><p>(下面的例子对比了使用工厂模式和不适用工厂模式的情况)<br>工厂类：两种方式都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂类用来创建汽车，这个类里的方法需要是static的</span><br><span class="line">public class CarFactory &#123;</span><br><span class="line"></span><br><span class="line">public static Car createCar(String type) &#123;</span><br><span class="line">if(&quot;奥迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;else if (&quot;比亚迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return null;///违反了开闭原则</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CarFactory2 &#123;</span><br><span class="line"></span><br><span class="line">public static Car createAudi() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line">public static  Car  createByd() &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个车的接口，供各种类型的汽车实现</span><br><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不使用工厂模式的情况</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new Audi();</span><br><span class="line">Car car2 = new Byd();</span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单工厂情况下</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Client02 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car = CarFactory.createCar(&quot;奥迪&quot;);</span><br><span class="line">Car car2 = CarFactory.createCar(&quot;比亚迪&quot;);</span><br><span class="line"></span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure><p>简单工厂模式违背了面向对象编程的开闭原则，所以进一步发展就有了咱们下面要介绍的工厂方法模式，其实工厂方法模式在理论上是符合面相编程设计的原则的，但是实用性不如简单工厂模式大，他定义了太多的类和接口，每个具体的车类都需要有一个对应的车工厂，没有简单工厂模式简洁。在实际的开发中，简单工厂模式较为实用。</p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>根据设计理论上工厂方法模式占优势，实际上比简单工厂模式要复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂的接口，来供其他的具体车类实现</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line"></span><br><span class="line">Car createCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AudiFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;奔驰在跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BenzFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Benz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BydFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new AudiFactory().createCar();</span><br><span class="line">car.run();</span><br><span class="line"></span><br><span class="line">Car car2 = new BydFactory().createCar();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure><p>工厂方法模式不修改已有类的前提下，通过增加新的工厂类实现扩展。工厂方法模式在理论上符合面向对象设计的原则，但是带来了类的冗余和拓展，所以实际中不大使用。</p><p>下面来看一下最后一种抽象工厂模式，也是最复杂的一种</p><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>用来生产不同产品族的全部产品（对于增加新的产品，无能为力，支持增加产品族）</p><p><img src="http://img.blog.csdn.net/20171110182731351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建车工厂</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line">Engine createEngine();</span><br><span class="line">Seat createSeat();</span><br><span class="line">Tyre createTyre();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建发动机接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">public interface Engine &#123;</span><br><span class="line">void run();</span><br><span class="line">void start();</span><br><span class="line">&#125;</span><br><span class="line">//高端发动机</span><br><span class="line">class LuxuryEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得快&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动快，可以自动启停&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//高端发动机</span><br><span class="line">class LowEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得慢&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动慢&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建座椅接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface Seat &#123;</span><br><span class="line"></span><br><span class="line">void massage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxurySeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowSeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;不可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建轮胎接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface Tyre &#123;</span><br><span class="line"></span><br><span class="line">void revolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxuryTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;旋转不磨损&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;磨损快&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低端类工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LowCarFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowSeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowTyre();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高端类工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class LuxuryCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxurySeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说一下工厂模式的应用场景<br><img src="http://img.blog.csdn.net/20171110182745587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中Map和Set的底层分析</title>
      <link href="/2015/06/12/map-set/"/>
      <url>/2015/06/12/map-set/</url>
      <content type="html"><![CDATA[<p>1.HashSet底层是使用HashMap实现的。当使用add方法将对象添加到Set当中时，实际上是将该对象作为底层所维护的Map对象的key，而value则都是同一个Object对象（该对象我们用不上）；其他的都是通过定义的HashMap对象实现的。</p><p>2.HashMap的底层，</p><p>loadFactor负载因子为0.75，数据结构中的哈希表有关。通过散列函数也就是哈希函数计算。<br>table是一个Entry类型的数组，当需要的时候回重新调整大小，他的长度必须为2的指数。默认生成一个长度为16的Entry类型的数组。</p><p>3.Entry是HashMap的内部类，实现了Map.Entry接口，实现了他的方法。</p><p>4.HashMap底层维护一个数组，我们向HashMap中所放置的对象实际上是存放在该数组中。</p><p>5.当向HashMap中put一对键值时，它会根据key的hashCode值计算出一个位置，该位置就是此对象准备往数组中存放的位置。<br>6.如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找（Entry类有一个Entry类型的next成员变量，指向了该对象的下一个对象），如果此链上有对象的话，再去使用equals方法进行比较，如果对此链上的某个对象的equals方法比较为false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。</p><p>7.HashMap的内存实现布局：<br><img src="http://p693ase25.bkt.clouddn.com/Untitled-1-20184222441.png" alt="Untitled-1-20184222441"></p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中Map接口实现类HashMap、Map.Entry接口</title>
      <link href="/2015/05/20/map-hashmap/"/>
      <url>/2015/05/20/map-hashmap/</url>
      <content type="html"><![CDATA[<p>来谈谈集合中的Map接口，它常用的实现类为HashMap。<br><img src="http://img.blog.csdn.net/20171108170056226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><hr><ul><li>除了类集，Java 2还在java.util中增加了映射。 映射（map）是一个存储关键字和值的关联 或者说是关键字/值对的对象。给定一个关 键字，可以得到它的值。关键字和值都是 对象。关键字必须是唯一的。但值是可以 重复的。有些映射可以接收null关键字和 null值。而有的则不行</li><li>Map接口映射唯一关键字到值。关键字（key）是 以后用于检索值的对象。给定一个关键字和一个 值，可以存储这个值到一个Map对象中。当这个 值被存储以后，就可以使用它的关键字来检索它。 当调用的映射中没有项存在时，其中的几种方法 会引发一个NoSuchElementException异常。而当对 象与映射中的元素不兼容时，引发一个 ClassCastException异常。如果试图使用映射不允 许使用的null对象时，则引发一个 NullPointerException异常。当试图改变一个不允 许修改的映射时，则引发一个 UnsupportedOperationException异常</li><li>映射循环使用两个基本操作：get( )和put( )。使用 put( )方法可以将一个指定了关键字和值的值加入 映射。为了得到值，可以通过将关键字作为参数 来调用get( )方法。调用返回该值。</li><li>映射不是类集，但可以获得映射的类集“视图”。 为了实现这种功能，可以使用entrySet( )方法，它 返回一个包含了映射中元素的集合（Set）。为了 得到关键字的类集“视图”，可以使用keySet( ) 方法，返回一个Set集合不可以重复。为了得到值的类集“视图”，可以使用 values( )方法，返回一个Collection集合，可以重复。类集“视图”是将映射集成到类集 框架内的手段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line">map.put(&quot;e&quot;, &quot;ee&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">String key = (String)iter.next();</span><br><span class="line">String value = (String)map.get(key);</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot;=&quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=aa</span><br><span class="line">b=bb</span><br><span class="line">c=cc</span><br><span class="line">d=dd</span><br><span class="line">e=ee</span><br></pre></td></tr></table></figure><p>遍历Map的两种方式，一种是直接打印输出，另一种是利用Set集合中的iterator（）；方法，首先调用Map的keySet（）方法返回一个Set集合，通过Set集合中key的值可以得到value的值。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><hr><p>HashMap类使用散列表实现Map接口。这允 许一些基本操作如get( )和put( )的运行时间 保持恒定，即便对大型集合，也是这样的 下面的构造函数定义为：</p><ul><li><p>HashMap( )</p></li><li><p>HashMap(Map m)</p></li><li><p>HashMap(int capacity)</p></li><li><p>HashMap(int capacity, float fillRatio)</p><p>第一种形式构造一个默认的散列映射。<br>第二种形式用m的元素初始化散列映射。<br>第三种形式将散列映射的容量初始化为 capacity。<br>第四种形式用它的参数同时初始化散列映 射的容量和填充比。容量和填充比的含义 与前面介绍的HashSet中的容量和填充比相同。<br>HashMap实现Map并扩展AbstractMap。它 本身并没有增加任何新的方法<br>应该注意的是散列映射并不保证它的元素 的顺序。因此，元素加入散列映射的顺序 并不一定是它们被迭代函数读出的顺序</p></li></ul><h1 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h1><hr><p>Map.Entry接口使得可以操作映射的输入。 回想由Map接口说明的entrySet( )方法，调 用该方法返回一个包含映射输入的集合 （Set）。这些集合元素的每一个都是一个 Map.Entry对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line"></span><br><span class="line">Set set = map.entrySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line"></span><br><span class="line">String key = (String)entry.getKey();</span><br><span class="line">String value = (String)entry.getValue();</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot; : &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a : aa</span><br><span class="line">b : bb</span><br><span class="line">c : cc</span><br><span class="line">d : dd</span><br></pre></td></tr></table></figure><p>Entry对象里面封装了key和value。</p><p>Map是key和value的映射，在Map里面key和value并不是单独存放的，在底层会生成一个entry对象，entry对象里面封装了value和key，所以获得了entry对象就可以同时获得key和value。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java三大特性</title>
      <link href="/2015/03/02/java-base/"/>
      <url>/2015/03/02/java-base/</url>
      <content type="html"><![CDATA[<p>java最大的特点就是面向对象、可跨平台。Java的三大特性分别是继承（Inheritance）、封装（encapsulation ）、多态。（polymorphism ）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>继承就是子类继承父类的属性和方法。就是生活中的儿子继承了父亲，是现实生活中的例子在java语言中的一个抽象。java是单继承的，表示一个类智能从另一个类继承，（被继承的类叫做父类（基类base class），继承的类叫做子类），java中的继承使用extends关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">public Parent() &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当生成子类对象时，Java默认首先调用父类的不带参数的构造方法，然后执行该构造方法，生成父类的对象。接下来，再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象。比如说：没有父亲，就没有孩子】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">super(1);</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">//public Parent() &#123;</span><br><span class="line">//System.out.println(&quot;parent&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">public Parent(int i) &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super关键字表示对父类对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果子类使用super（）显式调用父类的某个构造方法，那么在执行的时候就会寻找与super（）所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Apple apple = new Apple();</span><br><span class="line"></span><br><span class="line">System.out.println(apple.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">//String name = &quot;fruit&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">String name = &quot;apple&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于继承的3点：</p><ul><li>父类有的，子类也有</li><li>父类没有的，子类可以增加</li><li>父类有的，子类可以改变</li></ul><p>关于继承的注意事项</p><ul><li>构造方法不能被继承<ul><li>方法和属性可以被继承</li><li>子类的构造方法隐式地调用父类的不带参数的构造方法</li><li>当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用</li><li>super关键字必须是构造方法中的第一行语句。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is running&quot;);</span><br><span class="line">super.run(); //调用父类的run方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重写（override）：又叫做覆写，子类与父类的方法返回类型一样、方法名称一样、参数一样，这样我们说子类与父类的方法构成了重写方法。</p><p>当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run()不必放在第一行语句，因此此时父类对象已经构造完毕，先调用父类的run()方法还是先调用子类的run()方法是根据程序的逻辑决定的。</p><p>在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是Java中所有类的直接或间接父类）。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><hr><p>多态（Polymorphism）：我们说子类就是父类（菊花是花，女人是人），因此多态的意思是：父类型的引用可以指向子类的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Flower rose = new Rose(); //多态</span><br><span class="line">rose.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Flower</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;flower is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rose extends Flower</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>方法重载不是面向对象的特征，如果不是晚绑定，就不是多态，而方法重载不是晚绑定而是早绑定。（参考Thinking in java）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Parent parent = new Parent();</span><br><span class="line">//parent.sing();</span><br><span class="line"></span><br><span class="line">//Child child = new Child();</span><br><span class="line">//child.sing();</span><br><span class="line"></span><br><span class="line">Parent p = new Child();</span><br><span class="line">p.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;parent is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;child is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parent p = new Child();当使用多态方式调用方法时，首先检查父类中是否有sing()方法，如果没有则编译错误；如果有，再去调用子类的sing()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest2</span><br><span class="line">&#123;</span><br><span class="line">public static  void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal2 = animal;</span><br><span class="line">animal2.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal = animal2;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">Animal animal = cat;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Animal();</span><br><span class="line">Cat cat = (Cat)animal;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//向上类型转换</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line"></span><br><span class="line">Animal animal = cat;</span><br><span class="line"></span><br><span class="line">animal.sing();</span><br><span class="line"></span><br><span class="line">//向下类型转换</span><br><span class="line">Animal a = new Cat();</span><br><span class="line"></span><br><span class="line">Cat c = (Cat)a;</span><br><span class="line"></span><br><span class="line">c.sing();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;cat is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有两种类型的强制类型转换：</p><ol><li>向上类型转换（upcast）：比如说将Cat类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显式指定。<ol><li>向下类型转换（downcast）：比如将Animal类型转换为Cat类型。即将父类型转换为子类型。对于向下类型转换，必须要显式指定（必须要使用强制类型转换）。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.run();</span><br><span class="line"></span><br><span class="line">//Pear p = (Pear)f;</span><br><span class="line">//p.run();</span><br><span class="line">//是不可以的，父类中没有grow（），强制类型转换后可以</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.grow();</span><br><span class="line"></span><br><span class="line">Fruit f = new Pear();</span><br><span class="line"></span><br><span class="line">Pear p = (Pear)f;</span><br><span class="line"></span><br><span class="line">p.grow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;fruit is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pear extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void grow()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is growing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想使用子类特有的方法，而此方法没有在父类中出现的时候可以使用强制类型转换（向下类型转换）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest4</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A a = null;</span><br><span class="line"></span><br><span class="line">if(args[0].equals(&quot;1&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new B();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;2&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new C();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;3&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;D&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>晚绑定，编译的时候不知道，等到执行的时候才能确定下来具体的子类。</p><p>Connecting a function call to a function body is called binding.（将函数体和函数调用关联起来，就叫绑定）</p><p>早绑定（Early binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When binding is performed before the program is run (by the compiler and linker), it&apos; s called early binding</span><br><span class="line">在程序运行之前（也就是编译和链接时），执行的绑定是早绑定。</span><br></pre></td></tr></table></figure><p>晚绑定（late binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">late binding, which means the binding occurs at runtime, based on the type of the object. When a language implements late binding, there must be some mechanism to determine the  type of the object at runtime and call the appropriate member function.</span><br></pre></td></tr></table></figure><p>早绑定的优点是:</p><ul><li>编译效率</li><li>代码提示(代码智能感知)</li><li>编译时类型检查</li></ul><p>晚绑定的优点是:</p><ul><li>不用申明类型</li><li>对象类型可以随时更改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest5</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void run(BMW bmw)</span><br><span class="line">&#123;</span><br><span class="line">bmw.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(QQ qq)</span><br><span class="line">&#123;</span><br><span class="line">qq.run();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public void run(Car car)</span><br><span class="line">&#123;</span><br><span class="line">car.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">BMW bmw = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(bmw);</span><br><span class="line"></span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">Car car = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(car);</span><br><span class="line">//向上类型转换</span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;car is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BMW extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;BMW is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class QQ extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;QQ is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态屏蔽掉了子类给我们带来的差异性</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><hr><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问，其实前面用到了封装。</p><p>访问权限符：<br><img src="http://img.blog.csdn.net/20171108110832150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>封装的优点：</p><ol><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ol><p>修改属性的可见性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个值属性提供对外的公共方法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class EncapTest&#123;</span><br><span class="line"> </span><br><span class="line">   private String name;</span><br><span class="line">   private String idNum;</span><br><span class="line">   private int age;</span><br><span class="line"> </span><br><span class="line">   public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getIdNum()&#123;</span><br><span class="line">      return idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setAge( int newAge)&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String newName)&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setIdNum( String newId)&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用封装解决非法赋值问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">import other.Other;</span><br><span class="line"></span><br><span class="line">class Test2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(200);</span><br><span class="line">student.setId(1001);</span><br><span class="line">student.setName(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">student.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">private int id;</span><br><span class="line">private int age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Student(int id, int age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.id = id;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">if(age&lt;0||age&gt;150) &#123;</span><br><span class="line">this.age=0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;Student:id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:id=1001,name=张三,age=0</span><br></pre></td></tr></table></figure><p>近期系统的学习了java，做了一些知识的总结和思考，以博客的形式展示了出来，希望大家指点。我的第一篇博客完成，希望自己今后能够坚持下来，认真的反思与思考，总结博客，对各方面的知识能够更深入的研究学习。</p><p><a href="https://blog.csdn.net/prairie97" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
