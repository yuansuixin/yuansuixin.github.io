<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>github可以添加表情啦~</title>
      <link href="/2018/03/27/github%E6%B7%BB%E5%8A%A0%E8%A1%A8%E6%83%85/"/>
      <url>/2018/03/27/github%E6%B7%BB%E5%8A%A0%E8%A1%A8%E6%83%85/</url>
      <content type="html"><![CDATA[<h3 id="提升github的逼格"><a href="#提升github的逼格" class="headerlink" title="提升github的逼格"></a>提升github的逼格</h3><h5 id="github上可以添加表情啦，"><a href="#github上可以添加表情啦，" class="headerlink" title="github上可以添加表情啦，"></a>github上可以添加表情啦，</h5><ul><li>在github上插入表情的使用方法：<ul><li>使用方法为前后冒号包围表情代号的句法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```:blush:``` 会显示成对应的表情，所以你在提交代码的时候可以这样写提交信息：</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>git commit –m ‘commit some changes :blush:’<br><code>`</code></p><ul><li>表情列表</li></ul><p><a href="https://github.com/yuansuixin/emoji-list" title="表情大全" target="_blank" rel="noopener">表情大全</a></p><hr>]]></content>
      
      
    </entry>
    
    <entry>
      <title>hello</title>
      <link href="/2018/02/22/hello/"/>
      <url>/2018/02/22/hello/</url>
      <content type="html"><![CDATA[<ul><li>welcome to my-blog.</li><li>nice to meet you.</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中abstract详解</title>
      <link href="/2017/01/31/java-abstract/"/>
      <url>/2017/01/31/java-abstract/</url>
      <content type="html"><![CDATA[<p>今天来介绍一下抽象类。我们用动物类来看，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">System.out.println(&quot;喵喵叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shout() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;汪汪叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Animal animal= new Animal();</span><br><span class="line">animal.name=&quot;动物&quot;;</span><br><span class="line">animal.shout();</span><br><span class="line">animal.sleep();</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.name= &quot;旺财&quot;;</span><br><span class="line">System.out.print(&quot;狗狗&quot;+dog.name);</span><br><span class="line">dog.shout();</span><br><span class="line">dog.sleep();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.name=&quot;小花&quot;;</span><br><span class="line">System.out.print(&quot;猫咪&quot;+cat.name);</span><br><span class="line">cat.shout();</span><br><span class="line">cat.sleep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">狗狗旺财汪汪叫</span><br><span class="line">闭上眼睛就睡觉</span><br><span class="line"></span><br><span class="line">猫咪小花喵喵叫</span><br><span class="line">闭上眼睛就睡觉</span><br></pre></td></tr></table></figure></p><p>从上面的类中我们可以发现animal类中的shout（）方法在生活中几乎是不可能用到的，于是我们为了代码的简洁，shout（）方法不需要方法体，但是会报错误This method requires a body instead of a semicolon。于是我们便引入了abstract关键字。当我们加上abstract之后，还是会报错误The abstract method shout in type Animal can only be defined by an abstract class。那么怎么办呢？抽象方法需要在抽象类中定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">public Animal() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep() &#123;</span><br><span class="line">System.out.println(&quot;闭上眼睛就睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void shout() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动物类</span><br><span class="line"> * shout(); 这个方法里的方法体没有用 但这个方法不能注释 让子类重写</span><br><span class="line"> * 1.abstract抽象的</span><br><span class="line"> *   The abstract method shout in type Animal can only be defined by an abstract class</span><br><span class="line"> * 2.如何定义一个抽象方法</span><br><span class="line"> *   语法：</span><br><span class="line"> *     【访问权限符】 abstract 返回值 方法名();</span><br><span class="line"> *   eg：</span><br><span class="line"> *      public abstract void shout();</span><br><span class="line"> * 3.如何定义一个抽象类</span><br><span class="line"> *   语法：</span><br><span class="line"> *    【访问权限符】  abstract class 类名&#123;&#125;</span><br><span class="line"> *   eg:</span><br><span class="line"> *    public abstract class Animal &#123;</span><br><span class="line"> *    &#125;</span><br><span class="line"> * 4.总结</span><br><span class="line"> *     A.抽象方法一定要在抽象类中</span><br><span class="line"> *     B.抽象类中可以有   0 1 多个 抽象方法</span><br><span class="line"> *     C.抽象类不能直接实例对象 只能创建子类对象 抽象类一定要被继承</span><br><span class="line"> *       Cannot instantiate the type Animal</span><br><span class="line"> *     D.子类继承父类 如果父类是抽象类 子类一定要实现父类里所有的抽象方法 除非子类也是抽象类</span><br><span class="line"> *     E.abstract可以修饰   类  方法</span><br><span class="line"> *               不能修饰   成员变量 构造方法</span><br><span class="line"> *     F.抽象类中的成员</span><br><span class="line"> *               成员变量   成员方法  构造方法       </span><br><span class="line"> *        </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>总结一下知识点：</p><ol><li><p>语法</p><p>  A.抽象类和抽象方法必须使用 abstract修饰<br>  B.抽象类不能直接实例 只能被继承<br>  C.抽象类必须有构造方法 创建子类对象时候需要<br>  D.抽象类可以有至少0个抽象方法<br>  E.抽象方法只有声明没有实现（名字  没有方法体）<br>  F.public abstract void shout(){} 不是抽象方法<br>  G.子类必须重写抽象方法，如果不重写，自己也得是抽象类  </p></li></ol><p>2.意义<br>    A.抽象类为所有子类提供了一个通用模板,子类可以在此模板上进行扩展<br>    B.通过抽象类，可以避免子类设计随意性<br>    C.通过抽象类，可以严格限制子类的设计，使得子类更加通用</p><pre><code>抽象类就是用来作父类的用来被继承的</code></pre><p>  问题1：<br>      Animal an=new Animal(); 没有一种生物叫Animal 创建Animal没有意义<br>      拒绝实例<br>  解决方法：<br>      Animal类 定义为抽象类<br>      抽象类不能直接实例但可以被继承</p><p>  问题2:<br>     dog可以重写shout也可以不重写 如果希望dog必须重写shout方法 不重写就有编译错误</p><p>  解决方法：<br>       Animal类 里的shout方法定义为抽象方法<br>       抽象方法只有声明，没有实现</p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>设计模式---策略模式（strategy-pattern）</title>
      <link href="/2016/11/01/strategy-pattern/"/>
      <url>/2016/11/01/strategy-pattern/</url>
      <content type="html"><![CDATA[<p>策略模式（Strategy Pattern）中体现了两个非常基本的面相对象设计的原则：</p><ol><li>封装变化的概念</li><li>编程中使用接口，而不是对接口的实现</li></ol><p>策略模式的定义 ：</p><ul><li>定义一组算法，将每个算法都封装起来，并且 使它们之间可以互换。</li><li>策略模式使这些算法在客户端调用它们的时候 能够互不影响地变化</li></ul><p>策略模式的意义 </p><ul><li>策略模式使开发人员能够开发出由许多可替换 的部分组成的软件，并且各个部分之间是弱连 接的关系。 </li><li><p>弱连接的特性使软件具有更强的可扩展性，易 于维护；更重要的是，它大大提高了软件的可 重用性</p><p>策略模式的组成 </p></li><li>抽象策略角色：策略类，通常由一个接口或者 抽象类实现 </li><li>具体策略角色：包装了相关的算法和行为 </li><li><p>环境角色：持有一个策略类的引用，最终给客 户端调用的。</p><p>策略模式的实现 </p></li><li>策略模式的用意是针对一组算法，将每一个算 法封装到具有共同接口的独立的类中，从而使 得它们可以相互替换。 </li><li>策略模式使得算法可以在不影响到客户端的情 况下发生变化。使用策略模式可以把行为和环 境分割开来。</li><li>环境类负责维持和查询行为类，各种算法则在 具体策略中提供。由于算法和环境独立开来， 算法的修改都不会影响环境和客户端</li></ul><p>策略模式的编写步骤 ：</p><ol><li>对策略对象定义一个公共接口。 </li></ol><p>2．编写策略类，该类实现了上面的公共接口 </p><p>3．在使用策略对象的类中保存一个对策略对 象的引用。</p><p> 4．在使用策略对象的类中，实现对策略对象 的set和get方法（注入）或者使用构造方法完 成赋值</p><p>小提示：在eclipse里面Ctrl+t 进入到实现类的代码中去。</p><p>下面我们以计算器为例实现我们的策略模式：</p><h6 id="抽象策略角色"><a href="#抽象策略角色" class="headerlink" title="抽象策略角色"></a>抽象策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="具体策略角色"><a href="#具体策略角色" class="headerlink" title="具体策略角色"></a>具体策略角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AddStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SubtractStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MultiplyStrategy implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class DivideStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int calculate(int a, int b) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Environment &#123;</span><br><span class="line"></span><br><span class="line">private Strategy strategy;</span><br><span class="line"></span><br><span class="line">public Environment (Strategy strategy) &#123;</span><br><span class="line">this.strategy= strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">this.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Strategy getStrategy() &#123;</span><br><span class="line">return strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int calculate(int a,int b) &#123;</span><br><span class="line">return strategy.calculate(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">AddStrategy addStrategy = new AddStrategy();</span><br><span class="line">Environment environment = new Environment(addStrategy);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;3+4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">SubtractStrategy strategy = new SubtractStrategy();</span><br><span class="line">environment.setStrategy(strategy);</span><br><span class="line">System.out.println(&quot;3-4=&quot;+environment.calculate(3, 4));</span><br><span class="line"></span><br><span class="line">MultiplyStrategy multiplyStrategy = new MultiplyStrategy();</span><br><span class="line">environment.setStrategy(multiplyStrategy);</span><br><span class="line">System.out.println(&quot;3*4=&quot;+environment.calculate(3,4));</span><br><span class="line"></span><br><span class="line">DivideStrategy divideStrategy = new DivideStrategy();</span><br><span class="line">environment.setStrategy(divideStrategy);</span><br><span class="line">System.out.println(&quot;3/4=&quot;+environment.calculate(3,4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3+4=7</span><br><span class="line">3-4=-1</span><br><span class="line">3*4=12</span><br><span class="line">3/4=0</span><br></pre></td></tr></table></figure><p> 策略模式的缺点</p><ul><li>客户端必须知道所有的策略类，并自行决定 使用哪一个策略类。</li><li>造成很多的策略类。</li></ul><p>解决方案</p><ul><li>采用工厂方法</li></ul><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中String类解析</title>
      <link href="/2016/04/28/java-string/"/>
      <url>/2016/04/28/java-string/</url>
      <content type="html"><![CDATA[<p>1.相等性的比较（==）<br>(1)对于原生数据类型来说，比较的是左右两边的值是否相等<br>（2）对于引用类型来说，比较左右两边的引用是否指向同一个对象，或者说左右两边的引用地址是否相同。</p><p>2.Object 类的tostring方法返回的是一个哈希code值，而string类重写了tostring方法，默认调用tostring方法。<br>    API （Application Programming Interface），应用编程接口。<br>    当打印引用时，实际上会打印出引用所指对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，而Object类中定义了toString()，因此每个类都有toString()这个方法。</p><p>3.equals方法<br>对于object类的equals方法来说，是用来判断两个对象是不是同一个对象。<br>对于继承了object类的其他类来说，如果重写了equals方法，才是判断内容是否一致，，如果没有重写equals方法，是判断地址是否一致。<br>    对于String类的equals()方法来说，它是判断当前字符串与传进来的字符串的内容是否一致。</p><p>4.字符串是一个常量，创建之后值是不能被改变的。</p><p>5.String是常量，其对象一旦创建完毕就无法改变。当使用+拼接字符串时，会生成新的String对象，而不是向原有的String对象追加内容。</p><p>6、    String Pool（字符串池）</p><p>7、    String s = “aaa”;（采用字面值方式赋值）<br>1)    查找String Pool中是否存在“aaa”这个对象，如果不存在，则在String Pool中创建一个“aaa”对象，然后将String Pool中的这个“aaa”对象的地址返回来，赋给引用变量s，这样s会指向String Pool中的这个“aaa”字符串对象<br>2)    如果存在，则不创建任何对象，直接将String Pool中的这个“aaa”对象地址返回来，赋给s引用。</p><p>8、    String s = new String(“aaa”);<br>1)    首先在String Pool中查找有没有“aaa”这个字符串对象，如果有，则不在String Pool中再去创建“aaa”这个对象了，直接在堆中（heap）中创建一个“aaa”字符串对象，然后将堆中的这个“aaa”对象的地址返回来，赋给s引用，导致s指向了堆中创建的这个“aaa”字符串对象。<br>2)    如果没有，则首先在String Pool中创建一个“aaa“对象，然后再在堆中（heap）创建一个”aaa“对象，然后将堆中的这个”aaa“对象的地址返回来，赋给s引用，导致s指向了堆中所创建的这个”aaa“对象。</p><p>9.new出来的对象都是在堆里面</p><p>10.intern（）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//object类中的equals方法是使用==判断的</span></span><br><span class="line">System.out.println(object == object2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str == str2);<span class="comment">//false两个对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringPool字符串池在栈中，当字符串被赋予字面值的时候，首先检查字符串池里面有没有该对象"bbb"</span></span><br><span class="line"><span class="comment">//如果没有，就将该字符串放入字符串池里面，字符串变量便指向这个对象</span></span><br><span class="line"><span class="comment">//如果有，就不会在字符串池里面创建新的对象，而是在已有的字符串池里面的对象直接返回来赋给字符串变量str4</span></span><br><span class="line"><span class="comment">//所以str4并没有创建对象</span></span><br><span class="line"><span class="comment">//new出来的对象都是在堆里面</span></span><br><span class="line">String str3 = <span class="string">"bbb"</span>;<span class="comment">//创建一个对象</span></span><br><span class="line">String str4 = <span class="string">"bbb"</span>;<span class="comment">//并没有创建对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//true指向同一个对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line">String str5 = <span class="keyword">new</span> String(<span class="string">"ccc"</span>);</span><br><span class="line">String str6 = <span class="string">"ccc"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str5 == str6);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的拼接并不是将字符串拼接到后面。字符串是常量，创建后就不能改变了，</span></span><br><span class="line"><span class="comment">//加法操作实际上是生成了一个新的对象，而不是往原有的对象追加内容。</span></span><br><span class="line">String s = <span class="string">"hello"</span>;<span class="comment">//</span></span><br><span class="line">String s1 = <span class="string">"hel"</span>;</span><br><span class="line">String s2 = <span class="string">"lo"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s == s1 + s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">System.out.println(s == <span class="string">"hel"</span> + <span class="string">"lo"</span>);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testPackage;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                String hello = <span class="string">"Hello"</span>, lo = <span class="string">"lo"</span>;</span><br><span class="line">                System.out.print((hello == <span class="string">"Hello"</span>) + <span class="string">" "</span>);</span><br><span class="line">                System.out.print((Other.hello == hello) + <span class="string">" "</span>);</span><br><span class="line">                System.out.print((other.Other.hello == hello) + <span class="string">" "</span>);</span><br><span class="line">                System.out.print((hello == (<span class="string">"Hel"</span>+<span class="string">"lo"</span>)) + <span class="string">" "</span>);</span><br><span class="line">                System.out.print((hello == (<span class="string">"Hel"</span>+lo)) + <span class="string">" "</span>);</span><br><span class="line">                System.out.println(hello == (<span class="string">"Hel"</span>+lo).intern());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123; <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>; &#125;</span><br></pre></td></tr></table></figure><h6 id="and-the-compilation-unit"><a href="#and-the-compilation-unit" class="headerlink" title="and the compilation unit:"></a>and the compilation unit:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123; <span class="keyword">static</span> String hello = <span class="string">"Hello"</span>; &#125;</span><br></pre></td></tr></table></figure><h6 id="produces-the-output"><a href="#produces-the-output" class="headerlink" title="produces the output:"></a>produces the output:</h6><p>true true true true false true</p><h6 id="This-example-illustrates-six-points"><a href="#This-example-illustrates-six-points" class="headerlink" title="This example illustrates six points:"></a>This example illustrates six points:</h6><p>1.Literal strings within the same class (§8) in the same package (§7) represent references to the same String object (§4.3.1).<br>2.Literal strings within different classes in the same package represent references to the same String object.<br>3.Literal strings within different classes in different packages likewise represent references to the same String object.<br>4.Strings computed by constant expressions (§15.28) are computed at compile time and then treated as if they were literals.<br>5.Strings computed by concatenation at run time are newly created and therefore distinct. </p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>TreeSet底层解析和collections解析</title>
      <link href="/2016/03/28/TreeSet-collections/"/>
      <url>/2016/03/28/TreeSet-collections/</url>
      <content type="html"><![CDATA[<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>下图是集合框架中的接口<br><img src="http://img.blog.csdn.net/20171107204219357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>今天我来谈谈SortedSet接口。</p><p>TreeSet实现了SortedSet接口，如果有自然的顺序，TreeSet具有排序的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">set.add(&quot;C&quot;);</span><br><span class="line">set.add(&quot;A&quot;);</span><br><span class="line">set.add(&quot;B&quot;);</span><br><span class="line">set.add(&quot;E&quot;);</span><br><span class="line">set.add(&quot;F&quot;);</span><br><span class="line">set.add(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A,B,C,D,E,F]</span><br></pre></td></tr></table></figure><p>但是如果没有自然顺序的值还有正常的排序吗？我们一起来看看。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet();</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题出现了，报错误了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other.Person cannot be cast to java.lang.Comparable</span><br></pre></td></tr></table></figure></p><p>不要慌张，去底层寻找解决办法。</p><p><img src="http://img.blog.csdn.net/20171107210401006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>遇到错误通过文档去查找，大部分都是可以解决的哦，一定要有耐心哟!<br>TreeSet是带有排序的，我们刚才没有给程序说按照什么规则比较，所以我们要向往TreeSet放置对象，我们必须要告诉TreeSet排序的规则，制定好排序的规则，但是在哪里指定呢？和我一起来查看TreeSet的构造方法吧。</p><p><img src="http://img.blog.csdn.net/20171107210824004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>改bug：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.shengsiyuan2;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">TreeSet set = new TreeSet(new PersonComparator());</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(10);</span><br><span class="line">Person p2 = new Person(20);</span><br><span class="line">Person p3 = new Person(30);</span><br><span class="line">Person p4 = new Person(40);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">set.add(p3);</span><br><span class="line">set.add(p4);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Person p = (Person)iter.next();</span><br><span class="line">System.out.println(p.score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">int score;</span><br><span class="line"></span><br><span class="line">public Person(int score)</span><br><span class="line">&#123;</span><br><span class="line">this.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return String.valueOf(this.score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonComparator implements Comparator</span><br><span class="line">&#123;</span><br><span class="line">public int compare(Object arg0, Object arg1)</span><br><span class="line">&#123;</span><br><span class="line">Person p1 = (Person) arg0;</span><br><span class="line">Person p2 = (Person) arg1;</span><br><span class="line"></span><br><span class="line">return p2.score - p1.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">40</span><br><span class="line">30</span><br><span class="line">20</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections的一些方法用起来还是很方便的，分享给大家，Collections里面的方法都是静态的，可以直接调用。<br>sort（）；排序<br>reverseOrder()；反序<br>shuffle（）;乱序<br>min();最小<br>max();最大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class CollectionsTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">LinkedList list = new LinkedList();</span><br><span class="line"></span><br><span class="line">list.add(new Integer(-8));</span><br><span class="line">list.add(new Integer(20));</span><br><span class="line">list.add(new Integer(-20));</span><br><span class="line">list.add(new Integer(8));</span><br><span class="line">//自然顺序的反序操作</span><br><span class="line">Comparator r = Collections.reverseOrder();</span><br><span class="line">//排序</span><br><span class="line">Collections.sort(list, r);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">//乱序</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">for(Iterator iter = list.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(iter.next() + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;minimum value: &quot; + Collections.min(list));</span><br><span class="line">System.out.println(&quot;maximum value: &quot; + Collections.max(list));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">20 8 -8 -20 </span><br><span class="line">-20 20 -8 8 </span><br><span class="line">minimum value: -20</span><br><span class="line">maximum value: 20</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>singleton</title>
      <link href="/2016/01/24/singleton/"/>
      <url>/2016/01/24/singleton/</url>
      <content type="html"><![CDATA[<p>单例模式分为两种：饿汉式、懒汉式</p><p>既然是单例模式，那么就只有一个实例，那么构造方法就是私有的，就需要创建一个对象，而且也需要是私有的，但是需要调用所以要设置成静态的，然后提供一个方法拿到这个私有的对象。<br>一个类只会生成唯一的一个对象。</p><p>单例模式：饿汉式</p><p>1.私有构造方法<br>2.创建私有的静态对象<br>3.创建一个公共公开的方法，返回该私有对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Single1 &#123;</span><br><span class="line">  private static Single1 s1=new Single1();</span><br><span class="line">  private Single1()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static  Single1 getInstance()&#123;</span><br><span class="line">  return s1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">/*Single1 s1=new Single1();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=new Single1();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);*/</span><br><span class="line">Single1 s1=Single1.getInstance();</span><br><span class="line">System.out.println(s1);</span><br><span class="line">Single1 s2=Single1.getInstance();</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">com.qf.oop.innerclass.Single1@15db9742</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>饿汉式就是更急切的new出来了对象，而懒汉式就不这样了，其实，本质是一样的，让我们来看看懒汉吧。</p><p>单例模式：懒汉式</p><p>1.私有构造方法</p><ol><li>创建私有静态对象<br>3.创建公开公共的静态方法返回该私有对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Single2 &#123;</span><br><span class="line">  private static Single2 s2=null;</span><br><span class="line">  private Single2()&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  s2=new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;</span><br><span class="line">  &#125;</span><br><span class="line">  /*public static Single2 getInstance()&#123;</span><br><span class="line">  if(s2==null)&#123;</span><br><span class="line">  return new Single2();</span><br><span class="line">  &#125;</span><br><span class="line">  return s2;  错误的</span><br><span class="line">  &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingle2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  Single2 s1=Single2.getInstance();</span><br><span class="line">  System.out.println(s1);</span><br><span class="line">  Single2 s2=Single2.getInstance();</span><br><span class="line">  System.out.println(s2);</span><br><span class="line">  System.out.println(s1==s2);</span><br><span class="line">  //Object</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式的单例模式有一种错误的方法，我已经在代码中写出来了，大家一定要注意，仔细一点哦。</p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>factory</title>
      <link href="/2015/10/01/factory/"/>
      <url>/2015/10/01/factory/</url>
      <content type="html"><![CDATA[<p>在看工厂模式之前我们先了解一下面相对象的原则。</p><p>面向对象设计的基本原则</p><ul><li>OCP开闭原则：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP依赖倒转原则：要针对接口编程，不要针对实现编程</li><li>LOD迪米特法则：只与你直接的朋友通信，而避免和陌生人通话。</li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>实现了创建者和调用者的分离，下面我用汽车类的例子来介绍。</p><p>详细分类</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>也称之为静态工厂模式，项目开发中通常使用</p><p>(下面的例子对比了使用工厂模式和不适用工厂模式的情况)<br>工厂类：两种方式都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂类用来创建汽车，这个类里的方法需要是static的</span><br><span class="line">public class CarFactory &#123;</span><br><span class="line"></span><br><span class="line">public static Car createCar(String type) &#123;</span><br><span class="line">if(&quot;奥迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;else if (&quot;比亚迪&quot;.equals(type)) &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return null;///违反了开闭原则</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CarFactory2 &#123;</span><br><span class="line"></span><br><span class="line">public static Car createAudi() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line">public static  Car  createByd() &#123;</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个车的接口，供各种类型的汽车实现</span><br><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不使用工厂模式的情况</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client01 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new Audi();</span><br><span class="line">Car car2 = new Byd();</span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单工厂情况下</span><br><span class="line"> * @author yuan</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Client02 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car = CarFactory.createCar(&quot;奥迪&quot;);</span><br><span class="line">Car car2 = CarFactory.createCar(&quot;比亚迪&quot;);</span><br><span class="line"></span><br><span class="line">car.run();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure></p><p>简单工厂模式违背了面向对象编程的开闭原则，所以进一步发展就有了咱们下面要介绍的工厂方法模式，其实工厂方法模式在理论上是符合面相编程设计的原则的，但是实用性不如简单工厂模式大，他定义了太多的类和接口，每个具体的车类都需要有一个对应的车工厂，没有简单工厂模式简洁。在实际的开发中，简单工厂模式较为实用。</p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>根据设计理论上工厂方法模式占优势，实际上比简单工厂模式要复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个车工厂的接口，来供其他的具体车类实现</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line"></span><br><span class="line">Car createCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Car &#123;</span><br><span class="line"></span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Audi implements Car &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;奥迪再跑&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AudiFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">return new Audi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Benz implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;奔驰在跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BenzFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Benz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Byd implements Car&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;byd再跑&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BydFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Car createCar() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Byd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car= new AudiFactory().createCar();</span><br><span class="line">car.run();</span><br><span class="line"></span><br><span class="line">Car car2 = new BydFactory().createCar();</span><br><span class="line">car2.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奥迪再跑</span><br><span class="line">byd再跑</span><br></pre></td></tr></table></figure></p><p>工厂方法模式不修改已有类的前提下，通过增加新的工厂类实现扩展。工厂方法模式在理论上符合面向对象设计的原则，但是带来了类的冗余和拓展，所以实际中不大使用。</p><p>下面来看一下最后一种抽象工厂模式，也是最复杂的一种</p><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>用来生产不同产品族的全部产品（对于增加新的产品，无能为力，支持增加产品族）</p><p><img src="http://img.blog.csdn.net/20171110182731351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建车工厂</span><br><span class="line">public interface CarFactory &#123;</span><br><span class="line">Engine createEngine();</span><br><span class="line">Seat createSeat();</span><br><span class="line">Tyre createTyre();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建发动机接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">public interface Engine &#123;</span><br><span class="line">void run();</span><br><span class="line">void start();</span><br><span class="line">&#125;</span><br><span class="line">//高端发动机</span><br><span class="line">class LuxuryEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得快&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动快，可以自动启停&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//高端发动机</span><br><span class="line">class LowEngine implements Engine&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;z转得慢&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;启动慢&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建座椅接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Seat &#123;</span><br><span class="line"></span><br><span class="line">void massage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxurySeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowSeat implements Seat&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void massage() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;不可以自动按摩&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建轮胎接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface Tyre &#123;</span><br><span class="line"></span><br><span class="line">void revolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxuryTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;旋转不磨损&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowTyre implements Tyre&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void revolve() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;磨损快&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>低端类工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LowCarFactory implements CarFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowSeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LowTyre();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>高端类工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LuxuryCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryEngine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Seat createSeat() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxurySeat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new LuxuryTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说一下工厂模式的应用场景<br><img src="http://img.blog.csdn.net/20171110182745587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java中Map和Set的底层分析</title>
      <link href="/2015/06/29/Map-Set/"/>
      <url>/2015/06/29/Map-Set/</url>
      <content type="html"><![CDATA[<p>1.HashSet底层是使用HashMap实现的。当使用add方法将对象添加到Set当中时，实际上是将该对象作为底层所维护的Map对象的key，而value则都是同一个Object对象（该对象我们用不上）；其他的都是通过定义的HashMap对象实现的。</p><p>2.HashMap的底层，</p><p>loadFactor负载因子为0.75，数据结构中的哈希表有关。通过散列函数也就是哈希函数计算。<br>table是一个Entry类型的数组，当需要的时候回重新调整大小，他的长度必须为2的指数。默认生成一个长度为16的Entry类型的数组。</p><p>3.Entry是HashMap的内部类，实现了Map.Entry接口，实现了他的方法。</p><p>4.HashMap底层维护一个数组，我们向HashMap中所放置的对象实际上是存放在该数组中。</p><ol><li><p>当向HashMap中put一对键值时，它会根据key的hashCode值计算出一个位置，该位置就是此对象准备往数组中存放的位置。</p></li><li><p>如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找（Entry类有一个Entry类型的next成员变量，指向了该对象的下一个对象），如果此链上有对象的话，再去使用equals方法进行比较，如果对此链上的某个对象的equals方法比较为false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。</p></li></ol><p>7.HashMap的内存实现布局：</p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java中Map接口实现类HashMap、Map.Entry接口</title>
      <link href="/2015/05/29/Map-HashMap/"/>
      <url>/2015/05/29/Map-HashMap/</url>
      <content type="html"><![CDATA[<p>来谈谈集合中的Map接口，它常用的实现类为HashMap。<br><img src="http://img.blog.csdn.net/20171108170056226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><hr><ul><li>除了类集，Java 2还在java.util中增加了映射。 映射（map）是一个存储关键字和值的关联 或者说是关键字/值对的对象。给定一个关 键字，可以得到它的值。关键字和值都是 对象。关键字必须是唯一的。但值是可以 重复的。有些映射可以接收null关键字和 null值。而有的则不行</li><li>Map接口映射唯一关键字到值。关键字（key）是 以后用于检索值的对象。给定一个关键字和一个 值，可以存储这个值到一个Map对象中。当这个 值被存储以后，就可以使用它的关键字来检索它。 当调用的映射中没有项存在时，其中的几种方法 会引发一个NoSuchElementException异常。而当对 象与映射中的元素不兼容时，引发一个 ClassCastException异常。如果试图使用映射不允 许使用的null对象时，则引发一个 NullPointerException异常。当试图改变一个不允 许修改的映射时，则引发一个 UnsupportedOperationException异常</li><li>映射循环使用两个基本操作：get( )和put( )。使用 put( )方法可以将一个指定了关键字和值的值加入 映射。为了得到值，可以通过将关键字作为参数 来调用get( )方法。调用返回该值。 </li><li>映射不是类集，但可以获得映射的类集“视图”。 为了实现这种功能，可以使用entrySet( )方法，它 返回一个包含了映射中元素的集合（Set）。为了 得到关键字的类集“视图”，可以使用keySet( ) 方法，返回一个Set集合不可以重复。为了得到值的类集“视图”，可以使用 values( )方法，返回一个Collection集合，可以重复。类集“视图”是将映射集成到类集 框架内的手段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line">map.put(&quot;e&quot;, &quot;ee&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line">Set set = map.keySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">String key = (String)iter.next();</span><br><span class="line">String value = (String)map.get(key);</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot;=&quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=aa</span><br><span class="line">b=bb</span><br><span class="line">c=cc</span><br><span class="line">d=dd</span><br><span class="line">e=ee</span><br></pre></td></tr></table></figure><p>遍历Map的两种方式，一种是直接打印输出，另一种是利用Set集合中的iterator（）；方法，首先调用Map的keySet（）方法返回一个Set集合，通过Set集合中key的值可以得到value的值。</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><hr><p>HashMap类使用散列表实现Map接口。这允 许一些基本操作如get( )和put( )的运行时间 保持恒定，即便对大型集合，也是这样的 下面的构造函数定义为：</p><ul><li>HashMap( ) </li><li>HashMap(Map m) </li><li>HashMap(int capacity)</li><li><p>HashMap(int capacity, float fillRatio)</p><p>第一种形式构造一个默认的散列映射。<br>第二种形式用m的元素初始化散列映射。<br>第三种形式将散列映射的容量初始化为 capacity。<br>第四种形式用它的参数同时初始化散列映 射的容量和填充比。容量和填充比的含义 与前面介绍的HashSet中的容量和填充比相同。<br>HashMap实现Map并扩展AbstractMap。它 本身并没有增加任何新的方法<br>应该注意的是散列映射并不保证它的元素 的顺序。因此，元素加入散列映射的顺序 并不一定是它们被迭代函数读出的顺序</p></li></ul><h1 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h1><hr><p> Map.Entry接口使得可以操作映射的输入。 回想由Map接口说明的entrySet( )方法，调 用该方法返回一个包含映射输入的集合 （Set）。这些集合元素的每一个都是一个 Map.Entry对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line"></span><br><span class="line">map.put(&quot;a&quot;, &quot;aa&quot;);</span><br><span class="line">map.put(&quot;b&quot;, &quot;bb&quot;);</span><br><span class="line">map.put(&quot;c&quot;, &quot;cc&quot;);</span><br><span class="line">map.put(&quot;d&quot;, &quot;dd&quot;);</span><br><span class="line"></span><br><span class="line">Set set = map.entrySet();</span><br><span class="line"></span><br><span class="line">for(Iterator iter = set.iterator(); iter.hasNext();)</span><br><span class="line">&#123;</span><br><span class="line">Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line"></span><br><span class="line">String key = (String)entry.getKey();</span><br><span class="line">String value = (String)entry.getValue();</span><br><span class="line"></span><br><span class="line">System.out.println(key + &quot; : &quot; + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a : aa</span><br><span class="line">b : bb</span><br><span class="line">c : cc</span><br><span class="line">d : dd</span><br></pre></td></tr></table></figure><p>Entry对象里面封装了key和value。</p><p>Map是key和value的映射，在Map里面key和value并不是单独存放的，在底层会生成一个entry对象，entry对象里面封装了value和key，所以获得了entry对象就可以同时获得key和value。</p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>java特性</title>
      <link href="/2015/03/26/java%E7%89%B9%E6%80%A7/"/>
      <url>/2015/03/26/java%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>   java最大的特点就是面向对象、可跨平台。Java的三大特性分别是继承（Inheritance）、封装（encapsulation ）、多态。（polymorphism ）。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>继承就是子类继承父类的属性和方法。就是生活中的儿子继承了父亲，是现实生活中的例子在java语言中的一个抽象。java是单继承的，表示一个类智能从另一个类继承，（被继承的类叫做父类（基类base class），继承的类叫做子类），java中的继承使用extends关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">public Parent() &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   当生成子类对象时，Java默认首先调用父类的不带参数的构造方法，然后执行该构造方法，生成父类的对象。接下来，再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象。比如说：没有父亲，就没有孩子】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent&#123;</span><br><span class="line">public Child() &#123;</span><br><span class="line">super(1);</span><br><span class="line">System.out.println(&quot;child&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Child child = new Child();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">//public Parent() &#123;</span><br><span class="line">//System.out.println(&quot;parent&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">public Parent(int i) &#123;</span><br><span class="line">System.out.println(&quot;parent&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   super关键字表示对父类对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果子类使用super（）显式调用父类的某个构造方法，那么在执行的时候就会寻找与super（）所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Apple apple = new Apple();</span><br><span class="line"></span><br><span class="line">System.out.println(apple.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">//String name = &quot;fruit&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">String name = &quot;apple&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于继承的3点：<br>​    </p><ul><li>父类有的，子类也有</li><li>父类没有的，子类可以增加</li><li>父类有的，子类可以改变</li></ul><p>关于继承的注意事项<br>​         </p><ul><li>构造方法不能被继承<ul><li>方法和属性可以被继承</li><li>子类的构造方法隐式地调用父类的不带参数的构造方法</li><li>当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用</li><li>super关键字必须是构造方法中的第一行语句。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class InheritenceTest2</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Dog dog = new Dog();</span><br><span class="line">dog.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is running&quot;);</span><br><span class="line">super.run(); //调用父类的run方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 方法重写（override）：又叫做覆写，子类与父类的方法返回类型一样、方法名称一样、参数一样，这样我们说子类与父类的方法构成了重写方法。</p><p>   当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run()不必放在第一行语句，因此此时父类对象已经构造完毕，先调用父类的run()方法还是先调用子类的run()方法是根据程序的逻辑决定的。<br>​<br>   在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是Java中所有类的直接或间接父类）。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><hr><p>多态（Polymorphism）：我们说子类就是父类（菊花是花，女人是人），因此多态的意思是：父类型的引用可以指向子类的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Flower rose = new Rose(); //多态</span><br><span class="line">rose.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Flower</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;flower is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rose extends Flower</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>方法重载不是面向对象的特征，如果不是晚绑定，就不是多态，而方法重载不是晚绑定而是早绑定。（参考Thinking in java）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Parent parent = new Parent();</span><br><span class="line">//parent.sing();</span><br><span class="line"></span><br><span class="line">//Child child = new Child();</span><br><span class="line">//child.sing();</span><br><span class="line"></span><br><span class="line">Parent p = new Child();</span><br><span class="line">p.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;parent is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;child is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   Parent p = new Child();当使用多态方式调用方法时，首先检查父类中是否有sing()方法，如果没有则编译错误；如果有，再去调用子类的sing()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest2</span><br><span class="line">&#123;</span><br><span class="line">public static  void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal2 = animal;</span><br><span class="line">animal2.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Cat();</span><br><span class="line">Animal animal2 = new Animal();</span><br><span class="line"></span><br><span class="line">animal = animal2;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">Animal animal = cat;</span><br><span class="line">animal.sing();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Animal animal = new Animal();</span><br><span class="line">Cat cat = (Cat)animal;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//向上类型转换</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line"></span><br><span class="line">Animal animal = cat;</span><br><span class="line"></span><br><span class="line">animal.sing();</span><br><span class="line"></span><br><span class="line">//向下类型转换</span><br><span class="line">Animal a = new Cat();</span><br><span class="line"></span><br><span class="line">Cat c = (Cat)a;</span><br><span class="line"></span><br><span class="line">c.sing();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;animal is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;dog is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal</span><br><span class="line">&#123;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;cat is singing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   一共有两种类型的强制类型转换：</p><ol><li>向上类型转换（upcast）：比如说将Cat类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显式指定。<ol><li>向下类型转换（downcast）：比如将Animal类型转换为Cat类型。即将父类型转换为子类型。对于向下类型转换，必须要显式指定（必须要使用强制类型转换）。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest3</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.run();</span><br><span class="line"></span><br><span class="line">//Pear p = (Pear)f;</span><br><span class="line">//p.run();</span><br><span class="line">//是不可以的，父类中没有grow（），强制类型转换后可以</span><br><span class="line">//Fruit f = new Pear();</span><br><span class="line">//f.grow();</span><br><span class="line"></span><br><span class="line">Fruit f = new Pear();</span><br><span class="line"></span><br><span class="line">Pear p = (Pear)f;</span><br><span class="line"></span><br><span class="line">p.grow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;fruit is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pear extends Fruit</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void grow()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;pear is growing&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   当你想使用子类特有的方法，而此方法没有在父类中出现的时候可以使用强制类型转换（向下类型转换）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest4</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A a = null;</span><br><span class="line"></span><br><span class="line">if(args[0].equals(&quot;1&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new B();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;2&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new C();</span><br><span class="line">&#125;</span><br><span class="line">else if(args[0].equals(&quot;3&quot;))</span><br><span class="line">&#123;</span><br><span class="line">a = new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D extends A</span><br><span class="line">&#123;</span><br><span class="line">public void method()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;D&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   晚绑定，编译的时候不知道，等到执行的时候才能确定下来具体的子类。<br>​<br>   Connecting a function call to a function body is called binding.（将函数体和函数调用关联起来，就叫绑定）</p><p>早绑定（Early binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When binding is performed before the program is run (by the compiler and linker), it&apos; s called early binding</span><br><span class="line">在程序运行之前（也就是编译和链接时），执行的绑定是早绑定。</span><br></pre></td></tr></table></figure><p>晚绑定（late binding）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">late binding, which means the binding occurs at runtime, based on the type of the object. When a language implements late binding, there must be some mechanism to determine the  type of the object at runtime and call the appropriate member function.</span><br></pre></td></tr></table></figure><p>早绑定的优点是:</p><ul><li>编译效率</li><li>代码提示(代码智能感知)</li><li>编译时类型检查</li></ul><p>晚绑定的优点是:</p><ul><li>不用申明类型</li><li>对象类型可以随时更改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class PolyTest5</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">public void run(BMW bmw)</span><br><span class="line">&#123;</span><br><span class="line">bmw.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(QQ qq)</span><br><span class="line">&#123;</span><br><span class="line">qq.run();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public void run(Car car)</span><br><span class="line">&#123;</span><br><span class="line">car.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">BMW bmw = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(bmw);</span><br><span class="line"></span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">PolyTest5 test = new PolyTest5();</span><br><span class="line"></span><br><span class="line">Car car = new BMW();</span><br><span class="line"></span><br><span class="line">test.run(car);</span><br><span class="line">//向上类型转换</span><br><span class="line">QQ qq = new QQ();</span><br><span class="line"></span><br><span class="line">test.run(qq);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;car is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BMW extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;BMW is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class QQ extends Car</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;QQ is running&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态屏蔽掉了子类给我们带来的差异性<br>​    </p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><hr><p> 封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问，其实前面用到了封装。</p><p>访问权限符：<br><img src="http://img.blog.csdn.net/20171108110832150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJhaXJpZTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>封装的优点：</p><ol><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ol><p>修改属性的可见性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个值属性提供对外的公共方法访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class EncapTest&#123;</span><br><span class="line"> </span><br><span class="line">   private String name;</span><br><span class="line">   private String idNum;</span><br><span class="line">   private int age;</span><br><span class="line"> </span><br><span class="line">   public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getIdNum()&#123;</span><br><span class="line">      return idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setAge( int newAge)&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String newName)&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setIdNum( String newId)&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用封装解决非法赋值问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package other;</span><br><span class="line">import other.Other;</span><br><span class="line"></span><br><span class="line">class Test2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Student student = new Student();</span><br><span class="line">student.setAge(200);</span><br><span class="line">student.setId(1001);</span><br><span class="line">student.setName(&quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">student.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line">private int id;</span><br><span class="line">private int age;</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Student(int id, int age, String name) &#123;</span><br><span class="line">super();</span><br><span class="line">this.id = id;</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">if(age&lt;0||age&gt;150) &#123;</span><br><span class="line">this.age=0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;Student:id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student:id=1001,name=张三,age=0</span><br></pre></td></tr></table></figure><p>近期系统的学习了java，做了一些知识的总结和思考，以博客的形式展示了出来，希望大家指点。我的第一篇博客完成，希望自己今后能够坚持下来，认真的反思与思考，总结博客，对各方面的知识能够更深入的研究学习。</p><p><a href="https://blog.csdn.net/prairie97" title="csdn博客" target="_blank" rel="noopener">我的csdn博客</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
